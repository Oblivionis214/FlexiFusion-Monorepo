import * as React from 'react';
import React__default, { PropsWithChildren } from 'react';
import { WalletWithSignParams, NotifiFrontendClient, ConnectWalletParams, CardConfigItemV1 as CardConfigItemV1$1, AlertFrequency, FilterOptions, EventTypeConfig as EventTypeConfig$1, BroadcastEventTypeItem as BroadcastEventTypeItem$1, CustomTopicTypeItem as CustomTopicTypeItem$1, FusionHealthCheckEventTypeItem as FusionHealthCheckEventTypeItem$1, FusionToggleEventTypeItem as FusionToggleEventTypeItem$1, XMTPTopicTypeItem as XMTPTopicTypeItem$1, EventTypeItem as EventTypeItem$1, IntercomCardConfigItemV1 } from '@notifi-network/notifi-frontend-client';
import { Uint8SignMessageFunction, AptosSignMessageFunction, AcalaSignMessageFunction, NotifiEnvironment, useNotifiClient } from '@notifi-network/notifi-react-hooks';

declare type Maybe<T> = T | undefined;
declare type InputMaybe<T> = T | undefined;
/** All built-in and custom scalars, mapped to their actual values */
declare type Scalars = {
    ID: {
        input: string;
        output: string;
    };
    String: {
        input: string;
        output: string;
    };
    Boolean: {
        input: boolean;
        output: boolean;
    };
    Int: {
        input: number;
        output: number;
    };
    Float: {
        input: number;
        output: number;
    };
    DateTime: {
        input: string;
        output: string;
    };
    Decimal: {
        input: number;
        output: number;
    };
    Long: {
        input: any;
        output: any;
    };
    TimeSpan: {
        input: any;
        output: any;
    };
};
declare type AccountBalanceChangeDirection = 'INCOMING' | 'OUTGOING';
/** Notifi Alert */
declare type Alert = {
    __typename?: 'Alert';
    createdDate: Scalars['DateTime']['output'];
    filter: Filter;
    filterOptions: Scalars['String']['output'];
    groupName?: Maybe<Scalars['String']['output']>;
    id: Scalars['String']['output'];
    name?: Maybe<Scalars['String']['output']>;
    sourceGroup: SourceGroup;
    targetGroup: TargetGroup;
    updatedDate: Scalars['DateTime']['output'];
};
/** Authorization */
declare type Authorization = {
    __typename?: 'Authorization';
    expiry: Scalars['DateTime']['output'];
    tenantInfo?: Maybe<CorsPolicy>;
    token: Scalars['String']['output'];
};
declare type AvatarDataType = 'STOCK_NOTIFI' | 'URL';
/** Notifi Connected Wallet */
declare type ConnectedWallet = {
    __typename?: 'ConnectedWallet';
    address?: Maybe<Scalars['String']['output']>;
    user?: Maybe<User>;
    walletBlockchain: WalletBlockchain;
};
declare type ConversationParticipantType = 'ADMIN' | 'BANNED' | 'MEMBER' | 'SUPPORT';
/** CorsPolicy for tenant */
declare type CorsPolicy = {
    __typename?: 'CorsPolicy';
    allowedDomains?: Maybe<Array<Maybe<CorsPolicyEntry>>>;
};
declare type CorsPolicyEntry = {
    __typename?: 'CorsPolicyEntry';
    originAddress: Scalars['String']['output'];
};
/** Object used to create a source that can be used on alerts to listen for blockchain events. */
declare type CreateSourceInput = {
    /** Account address on blockchain. */
    blockchainAddress?: InputMaybe<Scalars['String']['input']>;
    /** Fusion event type Id for fusion sources */
    fusionEventTypeId?: InputMaybe<Scalars['String']['input']>;
    /** Friendly name for this Source. */
    name?: InputMaybe<Scalars['String']['input']>;
    /** Type of the BlockAddress being referenced. Can be SolanaWallet, EthereumWallet, TerraWallet, etc. */
    type: SourceType;
};
/** Discord Target */
declare type DiscordTarget = {
    __typename?: 'DiscordTarget';
    createdDate: Scalars['DateTime']['output'];
    discordAccountId?: Maybe<Scalars['String']['output']>;
    discordServerInviteLink?: Maybe<Scalars['String']['output']>;
    discriminator?: Maybe<Scalars['String']['output']>;
    id: Scalars['String']['output'];
    isConfirmed: Scalars['Boolean']['output'];
    name?: Maybe<Scalars['String']['output']>;
    updatedDate: Scalars['DateTime']['output'];
    userStatus: DiscordTargetStatus;
    username?: Maybe<Scalars['String']['output']>;
    verificationLink?: Maybe<Scalars['String']['output']>;
};
declare type DiscordTargetStatus = 'COMPLETE' | 'DISCORD_SERVER_NOT_JOINED' | 'UNVERIFIED';
declare type EmailTarget = {
    __typename?: 'EmailTarget';
    createdDate: Scalars['DateTime']['output'];
    emailAddress?: Maybe<Scalars['String']['output']>;
    id: Scalars['String']['output'];
    isConfirmed: Scalars['Boolean']['output'];
    name?: Maybe<Scalars['String']['output']>;
    updatedDate: Scalars['DateTime']['output'];
};
declare type FcmTarget = {
    __typename?: 'FcmTarget';
    appId?: Maybe<Scalars['String']['output']>;
    createdDate: Scalars['DateTime']['output'];
    deviceId?: Maybe<Scalars['String']['output']>;
    id: Scalars['String']['output'];
    isConfirmed: Scalars['Boolean']['output'];
    name?: Maybe<Scalars['String']['output']>;
    targetPlatform: FcmTargetPlatform;
    token?: Maybe<Scalars['String']['output']>;
    updatedDate: Scalars['DateTime']['output'];
};
declare type FcmTargetPlatform = 'ANDROID' | 'I_OS';
/** Notifi Filter */
declare type Filter = {
    __typename?: 'Filter';
    createdDate: Scalars['DateTime']['output'];
    filterType: FilterType;
    id: Scalars['String']['output'];
    name?: Maybe<Scalars['String']['output']>;
    updatedDate: Scalars['DateTime']['output'];
};
declare type FilterType = 'ASSET_BUYER_EVENTS' | 'ASSET_CATALOG_EVENTS' | 'ASSET_SELLER_EVENTS' | 'BALANCE' | 'BENQI_LENDING_HEALTH_EVENTS' | 'BROADCAST_MESSAGES' | 'COIN_PRICE_CHANGE_EVENTS' | 'DAO_PROPOSAL_EVENTS' | 'DELTA_PRIME_BORROW_RATE_EVENTS' | 'DELTA_PRIME_LENDING_HEALTH_EVENTS' | 'DELTA_PRIME_SUPPLY_RATE_EVENTS' | 'DEPOSITS' | 'DE_FI_YIELD_STRATEGIES' | 'DIRECT_TENANT_MESSAGES' | 'FUSION_SOURCE' | 'LIQUIDATIONS' | 'LIQUIDITY_POOL_PRICE_CHANGES' | 'MULTI_SIG_SAFE_EVENTS' | 'NFT_AUCTIONS' | 'NFT_BACKED_LOANS' | 'NOTIFI_CHAT_MESSAGES' | 'REALM_DAO_PROPOSAL_STATES' | 'STAKING_CONFIRMATION_EVENTS' | 'STAKING_REMINDER_EVENTS' | 'TRIBECA_DAO_PROPOSAL_STATES' | 'VALUE_THRESHOLD' | 'WEB3_CHAT_MESSAGES' | 'WITHDRAWALS';
/** Object used to find tenant configs. */
declare type FindTenantConfigInput = {
    /** The ID of the config to find */
    id: Scalars['String']['input'];
    /** The tenant identifier */
    tenant: Scalars['String']['input'];
    /** The type of config to query */
    type: TenantConfigType;
};
declare type GenericEventIconHint = 'CHART' | 'CHECKMARK' | 'CLOCK' | 'DAO' | 'DOWN_ARROW' | 'FLAG' | 'GRAPH' | 'INFO' | 'MEGAPHONE' | 'PERCENT' | 'STAR' | 'SWAP' | 'UP_ARROW' | 'URGENT' | 'WATCH';
declare type KeyValuePairOfStringAndString = {
    __typename?: 'KeyValuePairOfStringAndString';
    key: Scalars['String']['output'];
    value: Scalars['String']['output'];
};
declare type NftCollectionsReportType = 'HOT' | 'MOST_TRADED';
declare type NotificationCategory = 'BALANCE_CHANGE' | 'CHAT' | 'COIN_PRICE_CHANGE' | 'CREATOR_MESSAGE' | 'DAO_PROPOSAL' | 'NFT_AUCTION';
declare type SmsTarget = {
    __typename?: 'SmsTarget';
    createdDate: Scalars['DateTime']['output'];
    id: Scalars['String']['output'];
    isConfirmed: Scalars['Boolean']['output'];
    name?: Maybe<Scalars['String']['output']>;
    phoneNumber?: Maybe<Scalars['String']['output']>;
    updatedDate: Scalars['DateTime']['output'];
};
/** Notifi Source */
declare type Source = {
    __typename?: 'Source';
    activeAlertCount: Scalars['Long']['output'];
    applicableFilters?: Maybe<Array<Maybe<Filter>>>;
    blockchainAddress: Scalars['String']['output'];
    createdDate: Scalars['DateTime']['output'];
    fusionEventTypeId?: Maybe<Scalars['String']['output']>;
    id: Scalars['String']['output'];
    name?: Maybe<Scalars['String']['output']>;
    type: SourceType;
    updatedDate: Scalars['DateTime']['output'];
};
declare type SourceGroup = {
    __typename?: 'SourceGroup';
    createdDate: Scalars['DateTime']['output'];
    id: Scalars['String']['output'];
    name?: Maybe<Scalars['String']['output']>;
    sources?: Maybe<Array<Maybe<Source>>>;
    updatedDate: Scalars['DateTime']['output'];
};
declare type SourceType = 'ACALA_WALLET' | 'APTOS_WALLET' | 'ARBITRUM_WALLET' | 'AVALANCHE_WALLET' | 'BASE_WALLET' | 'BENQI' | 'BINANCE_WALLET' | 'BONFIDA_NAME_AUCTIONING' | 'BONFIDA_NAME_OFFERS' | 'BROADCAST' | 'COIN_PRICE_CHANGES' | 'DELTA_PRIME' | 'DELTA_PRIME_LENDING_RATES' | 'DIRECT_PUSH' | 'ETHEREUM_WALLET' | 'FUSION_SOURCE' | 'HAWK_SIGHT' | 'HEDGE_PROTOCOL' | 'METAPLEX_AUCTION_HOUSE' | 'NOTIFI_CHAT' | 'OPTIMISM_WALLET' | 'ORCA' | 'POLYGON_WALLET' | 'PORT_FINANCE' | 'REALM_PROPOSALS' | 'SHARKY_PROTOCOL' | 'SNAPSHOT' | 'SOLANA_BONFIDA_AUCTION' | 'SOLANA_JABBER_V1' | 'SOLANA_METAPLEX_AUCTION' | 'SOLANA_SNOWFLAKE' | 'SOLANA_WALLET' | 'SUI_WALLET' | 'TERRA_WALLET' | 'TOPAZ' | 'TRIBECA_PROPOSALS' | 'XMTP' | 'ZKSYNC' | 'ZKSYNC_WALLET';
/** Notifi TargetGroup */
declare type TargetGroup = {
    __typename?: 'TargetGroup';
    createdDate: Scalars['DateTime']['output'];
    discordTargets?: Maybe<Array<Maybe<DiscordTarget>>>;
    emailTargets?: Maybe<Array<Maybe<EmailTarget>>>;
    fcmTargets?: Maybe<Array<Maybe<FcmTarget>>>;
    id: Scalars['String']['output'];
    name?: Maybe<Scalars['String']['output']>;
    smsTargets?: Maybe<Array<Maybe<SmsTarget>>>;
    telegramTargets?: Maybe<Array<Maybe<TelegramTarget>>>;
    updatedDate: Scalars['DateTime']['output'];
    web3Targets?: Maybe<Array<Maybe<Web3Target>>>;
    webhookTargets?: Maybe<Array<Maybe<WebhookTarget>>>;
};
declare type TargetType = 'DISCORD' | 'EMAIL' | 'FCM' | 'PLATFORM' | 'SMS' | 'TELEGRAM' | 'WEB3' | 'WEBHOOK';
declare type TelegramTarget = {
    __typename?: 'TelegramTarget';
    /** Used to confirm the Telegram chat. User must click url and start bot. */
    confirmationUrl?: Maybe<Scalars['String']['output']>;
    createdDate: Scalars['DateTime']['output'];
    id: Scalars['String']['output'];
    isConfirmed: Scalars['Boolean']['output'];
    name?: Maybe<Scalars['String']['output']>;
    telegramId: Scalars['String']['output'];
    updatedDate: Scalars['DateTime']['output'];
};
/** Notifi tenant information */
declare type Tenant = {
    __typename?: 'Tenant';
    dappId: Scalars['String']['output'];
    name: Scalars['String']['output'];
};
declare type TenantConfigType = 'INTERCOM_CARD' | 'SUBSCRIPTION_CARD';
/** Notifi User */
declare type User = {
    __typename?: 'User';
    alerts?: Maybe<Array<Maybe<Alert>>>;
    authorization?: Maybe<Authorization>;
    email?: Maybe<Scalars['String']['output']>;
    emailConfirmed: Scalars['Boolean']['output'];
    id: Scalars['String']['output'];
    profile: UserProfile;
    roles?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
    settings: UserSettings;
};
/** Notifi user profile */
declare type UserProfile = {
    __typename?: 'UserProfile';
    avatarData?: Maybe<Scalars['String']['output']>;
    avatarDataType: AvatarDataType;
    id: Scalars['String']['output'];
    preferredAddress?: Maybe<Scalars['String']['output']>;
    preferredBlockchain: WalletBlockchain;
    preferredName?: Maybe<Scalars['String']['output']>;
    tenantInfo?: Maybe<Tenant>;
};
/** User Settings */
declare type UserSettings = {
    __typename?: 'UserSettings';
    detailedAlertHistoryEnabled: Scalars['Boolean']['output'];
    ftuStage?: Maybe<Scalars['Int']['output']>;
    userHasChatEnabled: Scalars['Boolean']['output'];
};
declare type WalletBlockchain = 'ACALA' | 'APTOS' | 'ARBITRUM' | 'AVALANCHE' | 'BASE' | 'BINANCE' | 'ETHEREUM' | 'EVMOS' | 'INJECTIVE' | 'NEAR' | 'NIBIRU' | 'OFF_CHAIN' | 'OPTIMISM' | 'OSMOSIS' | 'POLYGON' | 'SOLANA' | 'SUI' | 'ZKSYNC';
declare type WalletsActivityReportType = 'MOST_ACTIVE';
declare type Web3Target = {
    __typename?: 'Web3Target';
    accountId?: Maybe<Scalars['String']['output']>;
    createdDate: Scalars['DateTime']['output'];
    id: Scalars['String']['output'];
    isConfirmed: Scalars['Boolean']['output'];
    name?: Maybe<Scalars['String']['output']>;
    targetProtocol: Web3TargetProtocol;
    updatedDate: Scalars['DateTime']['output'];
    walletBlockchain: WalletBlockchain;
};
declare type Web3TargetProtocol = 'XMTP';
declare type WebhookPayloadFormat = 'BROWSER_PUSH_CHROME' | 'BROWSER_PUSH_MOZILLA' | 'BROWSER_PUSH_NOTIFI' | 'PAGER_DUTY' | 'RAW';
declare type WebhookStatus = 'ERROR' | 'OK' | 'RATE_LIMITED' | 'UNCONFIRMED';
declare type WebhookTarget = {
    __typename?: 'WebhookTarget';
    createdDate: Scalars['DateTime']['output'];
    format: WebhookPayloadFormat;
    headers?: Maybe<Array<KeyValuePairOfStringAndString>>;
    id: Scalars['String']['output'];
    name?: Maybe<Scalars['String']['output']>;
    status: WebhookStatus;
    updatedDate: Scalars['DateTime']['output'];
    url: Scalars['String']['output'];
};
declare type AlertFragmentFragment = {
    __typename?: 'Alert';
    id: string;
    groupName?: string | undefined;
    name?: string | undefined;
    filterOptions: string;
    filter: {
        __typename?: 'Filter';
        id: string;
        name?: string | undefined;
        filterType: FilterType;
    };
    sourceGroup: {
        __typename?: 'SourceGroup';
        id: string;
        name?: string | undefined;
        sources?: Array<{
            __typename?: 'Source';
            id: string;
            name?: string | undefined;
            type: SourceType;
            blockchainAddress: string;
            fusionEventTypeId?: string | undefined;
            applicableFilters?: Array<{
                __typename?: 'Filter';
                id: string;
                name?: string | undefined;
                filterType: FilterType;
            } | undefined> | undefined;
        } | undefined> | undefined;
    };
    targetGroup: {
        __typename?: 'TargetGroup';
        id: string;
        name?: string | undefined;
        emailTargets?: Array<{
            __typename?: 'EmailTarget';
            emailAddress?: string | undefined;
            id: string;
            isConfirmed: boolean;
            name?: string | undefined;
        } | undefined> | undefined;
        smsTargets?: Array<{
            __typename?: 'SmsTarget';
            id: string;
            isConfirmed: boolean;
            name?: string | undefined;
            phoneNumber?: string | undefined;
        } | undefined> | undefined;
        telegramTargets?: Array<{
            __typename?: 'TelegramTarget';
            id: string;
            isConfirmed: boolean;
            name?: string | undefined;
            telegramId: string;
            confirmationUrl?: string | undefined;
        } | undefined> | undefined;
        webhookTargets?: Array<{
            __typename?: 'WebhookTarget';
            id: string;
            url: string;
            status: WebhookStatus;
            format: WebhookPayloadFormat;
            name?: string | undefined;
            headers?: Array<{
                __typename?: 'KeyValuePairOfStringAndString';
                key: string;
                value: string;
            }> | undefined;
        } | undefined> | undefined;
        discordTargets?: Array<{
            __typename?: 'DiscordTarget';
            id: string;
            discordAccountId?: string | undefined;
            discriminator?: string | undefined;
            isConfirmed: boolean;
            username?: string | undefined;
            name?: string | undefined;
            userStatus: DiscordTargetStatus;
            verificationLink?: string | undefined;
            discordServerInviteLink?: string | undefined;
        } | undefined> | undefined;
    };
};
declare type ConnectedWalletFragmentFragment = {
    __typename?: 'ConnectedWallet';
    address?: string | undefined;
    walletBlockchain: WalletBlockchain;
};
declare type ConversationMessageFragment = {
    __typename?: 'ConversationMessage';
    id: string;
    userId: string;
    conversationId: string;
    createdDate: string;
    updatedDate: string;
    message: string;
    conversationParticipant?: {
        __typename?: 'ConversationParticipant';
        conversationId: string;
        conversationParticipantType: ConversationParticipantType;
        resolvedName?: string | undefined;
        userId: string;
        walletAddress: string;
        walletBlockchain: WalletBlockchain;
        profile: {
            __typename?: 'UserProfile';
            avatarData?: string | undefined;
            avatarDataType: AvatarDataType;
            id: string;
            preferredAddress?: string | undefined;
            preferredBlockchain: WalletBlockchain;
            preferredName?: string | undefined;
        };
    } | undefined;
};
declare type DiscordTargetFragmentFragment = {
    __typename?: 'DiscordTarget';
    id: string;
    discordAccountId?: string | undefined;
    discriminator?: string | undefined;
    isConfirmed: boolean;
    username?: string | undefined;
    name?: string | undefined;
    userStatus: DiscordTargetStatus;
    verificationLink?: string | undefined;
    discordServerInviteLink?: string | undefined;
};
declare type EmailTargetFragmentFragment = {
    __typename?: 'EmailTarget';
    emailAddress?: string | undefined;
    id: string;
    isConfirmed: boolean;
    name?: string | undefined;
};
declare type FilterFragmentFragment = {
    __typename?: 'Filter';
    id: string;
    name?: string | undefined;
    filterType: FilterType;
};
declare type FusionNotificationHistoryEntryFragmentFragment = {
    __typename: 'FusionNotificationHistoryEntry';
    id: string;
    createdDate: string;
    read: boolean;
    fusionEventVariables: string;
    detail?: {
        __typename: 'AccountBalanceChangedEventDetails';
        walletBlockchain: WalletBlockchain;
        direction: AccountBalanceChangeDirection;
        newValue: number;
        previousValue: number;
        tokenSymbol: string;
        isWhaleWatch: boolean;
    } | {
        __typename: 'BroadcastMessageEventDetails';
        subject?: string | undefined;
        message?: string | undefined;
        messageHtml?: string | undefined;
        messageType: string;
    } | {
        __typename: 'ChatMessageReceivedEventDetails';
        senderName: string;
        conversationId: string;
        messageId: string;
        senderId: string;
        senderBlockchain: WalletBlockchain;
        messageBody: string;
    } | {
        __typename: 'DAOProposalChangedEventDetails';
        tenantName: string;
        description: string;
        state?: string | undefined;
        daoUrl?: string | undefined;
        proposalUrl?: string | undefined;
        proposalTitle?: string | undefined;
    } | {
        __typename: 'DirectTenantMessageEventDetails';
        tenantName: string;
        targetTemplatesJson?: string | undefined;
        templateVariablesJson?: string | undefined;
    } | {
        __typename: 'GenericEventDetails';
        sourceName: string;
        notificationTypeName: string;
        eventDetailsJson?: string | undefined;
        icon: GenericEventIconHint;
        genericMessage: string;
        genericMessageHtml?: string | undefined;
        action?: {
            __typename?: 'GenericEventAction';
            name: string;
            url: string;
        } | undefined;
    } | {
        __typename: 'HealthValueOverThresholdEventDetails';
        name: string;
        value: string;
        threshold: string;
        url: string;
    } | {
        __typename: 'NftAuctionChangedEventDetails';
        auctionUrl?: string | undefined;
        walletBlockchain: WalletBlockchain;
        highBidAmount: number;
        highBidSymbol?: string | undefined;
        imageUrl?: string | undefined;
        auctionTitle: string;
    } | {
        __typename: 'NftCollectionsReportEventDetails';
        type: NftCollectionsReportType;
        providerName: string;
        sourceLink: string;
        collections: Array<{
            __typename?: 'NftCollectionStats';
            collectionId: string;
            name: string;
            imgUrl?: string | undefined;
            volume1Day?: string | undefined;
            volume1DayChange?: string | undefined;
        }>;
    } | {
        __typename: 'WalletsActivityReportEventDetails';
        providerName: string;
        sourceLink: string;
        walletActivityType: WalletsActivityReportType;
        wallets: Array<{
            __typename?: 'WalletsActivityReportWallet';
            address: string;
            volume1Day: string;
            maxPurchase1Day?: string | undefined;
            maxPurchaseName?: string | undefined;
            maxPurchaseImgUrl?: string | undefined;
            maxPurchaseTokenAddress?: string | undefined;
        }>;
    } | undefined;
};
declare type NotificationHistoryEntryFragmentFragment = {
    __typename: 'NotificationHistoryEntry';
    id: string;
    createdDate: string;
    eventId: string;
    read: boolean;
    sourceAddress?: string | undefined;
    category?: NotificationCategory | undefined;
    transactionSignature?: string | undefined;
    targets: Array<{
        __typename?: 'NotificationTarget';
        type: TargetType;
        name?: string | undefined;
    }>;
    detail?: {
        __typename: 'AccountBalanceChangedEventDetails';
        walletBlockchain: WalletBlockchain;
        direction: AccountBalanceChangeDirection;
        newValue: number;
        previousValue: number;
        tokenSymbol: string;
        isWhaleWatch: boolean;
    } | {
        __typename: 'BroadcastMessageEventDetails';
        subject?: string | undefined;
        message?: string | undefined;
        messageHtml?: string | undefined;
        messageType: string;
    } | {
        __typename: 'ChatMessageReceivedEventDetails';
        senderName: string;
        conversationId: string;
        messageId: string;
        senderId: string;
        senderBlockchain: WalletBlockchain;
        messageBody: string;
    } | {
        __typename: 'DAOProposalChangedEventDetails';
        tenantName: string;
        description: string;
        state?: string | undefined;
        daoUrl?: string | undefined;
        proposalUrl?: string | undefined;
        proposalTitle?: string | undefined;
    } | {
        __typename: 'DirectTenantMessageEventDetails';
        tenantName: string;
        targetTemplatesJson?: string | undefined;
        templateVariablesJson?: string | undefined;
    } | {
        __typename: 'GenericEventDetails';
        sourceName: string;
        notificationTypeName: string;
        eventDetailsJson?: string | undefined;
        icon: GenericEventIconHint;
        genericMessage: string;
        genericMessageHtml?: string | undefined;
        action?: {
            __typename?: 'GenericEventAction';
            name: string;
            url: string;
        } | undefined;
    } | {
        __typename: 'HealthValueOverThresholdEventDetails';
        name: string;
        value: string;
        threshold: string;
        url: string;
    } | {
        __typename: 'NftAuctionChangedEventDetails';
        auctionUrl?: string | undefined;
        walletBlockchain: WalletBlockchain;
        highBidAmount: number;
        highBidSymbol?: string | undefined;
        imageUrl?: string | undefined;
        auctionTitle: string;
    } | {
        __typename: 'NftCollectionsReportEventDetails';
        type: NftCollectionsReportType;
        providerName: string;
        sourceLink: string;
        collections: Array<{
            __typename?: 'NftCollectionStats';
            collectionId: string;
            name: string;
            imgUrl?: string | undefined;
            volume1Day?: string | undefined;
            volume1DayChange?: string | undefined;
        }>;
    } | {
        __typename: 'WalletsActivityReportEventDetails';
        providerName: string;
        sourceLink: string;
        walletActivityType: WalletsActivityReportType;
        wallets: Array<{
            __typename?: 'WalletsActivityReportWallet';
            address: string;
            volume1Day: string;
            maxPurchase1Day?: string | undefined;
            maxPurchaseName?: string | undefined;
            maxPurchaseImgUrl?: string | undefined;
            maxPurchaseTokenAddress?: string | undefined;
        }>;
    } | undefined;
};
declare type SmsTargetFragmentFragment = {
    __typename?: 'SmsTarget';
    id: string;
    isConfirmed: boolean;
    name?: string | undefined;
    phoneNumber?: string | undefined;
};
declare type SourceFragmentFragment = {
    __typename?: 'Source';
    id: string;
    name?: string | undefined;
    type: SourceType;
    blockchainAddress: string;
    fusionEventTypeId?: string | undefined;
    applicableFilters?: Array<{
        __typename?: 'Filter';
        id: string;
        name?: string | undefined;
        filterType: FilterType;
    } | undefined> | undefined;
};
declare type SourceGroupFragmentFragment = {
    __typename?: 'SourceGroup';
    id: string;
    name?: string | undefined;
    sources?: Array<{
        __typename?: 'Source';
        id: string;
        name?: string | undefined;
        type: SourceType;
        blockchainAddress: string;
        fusionEventTypeId?: string | undefined;
        applicableFilters?: Array<{
            __typename?: 'Filter';
            id: string;
            name?: string | undefined;
            filterType: FilterType;
        } | undefined> | undefined;
    } | undefined> | undefined;
};
declare type TargetGroupFragmentFragment = {
    __typename?: 'TargetGroup';
    id: string;
    name?: string | undefined;
    emailTargets?: Array<{
        __typename?: 'EmailTarget';
        emailAddress?: string | undefined;
        id: string;
        isConfirmed: boolean;
        name?: string | undefined;
    } | undefined> | undefined;
    smsTargets?: Array<{
        __typename?: 'SmsTarget';
        id: string;
        isConfirmed: boolean;
        name?: string | undefined;
        phoneNumber?: string | undefined;
    } | undefined> | undefined;
    telegramTargets?: Array<{
        __typename?: 'TelegramTarget';
        id: string;
        isConfirmed: boolean;
        name?: string | undefined;
        telegramId: string;
        confirmationUrl?: string | undefined;
    } | undefined> | undefined;
    webhookTargets?: Array<{
        __typename?: 'WebhookTarget';
        id: string;
        url: string;
        status: WebhookStatus;
        format: WebhookPayloadFormat;
        name?: string | undefined;
        headers?: Array<{
            __typename?: 'KeyValuePairOfStringAndString';
            key: string;
            value: string;
        }> | undefined;
    } | undefined> | undefined;
    discordTargets?: Array<{
        __typename?: 'DiscordTarget';
        id: string;
        discordAccountId?: string | undefined;
        discriminator?: string | undefined;
        isConfirmed: boolean;
        username?: string | undefined;
        name?: string | undefined;
        userStatus: DiscordTargetStatus;
        verificationLink?: string | undefined;
        discordServerInviteLink?: string | undefined;
    } | undefined> | undefined;
};
declare type TelegramTargetFragmentFragment = {
    __typename?: 'TelegramTarget';
    id: string;
    isConfirmed: boolean;
    name?: string | undefined;
    telegramId: string;
    confirmationUrl?: string | undefined;
};
declare type UserFragmentFragment = {
    __typename?: 'User';
    email?: string | undefined;
    emailConfirmed: boolean;
    roles?: Array<string | undefined> | undefined;
    authorization?: {
        __typename?: 'Authorization';
        token: string;
        expiry: string;
    } | undefined;
};
declare type FetchDataQuery = {
    __typename?: 'NotifiQuery';
    alert?: Array<{
        __typename?: 'Alert';
        id: string;
        groupName?: string | undefined;
        name?: string | undefined;
        filterOptions: string;
        filter: {
            __typename?: 'Filter';
            id: string;
            name?: string | undefined;
            filterType: FilterType;
        };
        sourceGroup: {
            __typename?: 'SourceGroup';
            id: string;
            name?: string | undefined;
            sources?: Array<{
                __typename?: 'Source';
                id: string;
                name?: string | undefined;
                type: SourceType;
                blockchainAddress: string;
                fusionEventTypeId?: string | undefined;
                applicableFilters?: Array<{
                    __typename?: 'Filter';
                    id: string;
                    name?: string | undefined;
                    filterType: FilterType;
                } | undefined> | undefined;
            } | undefined> | undefined;
        };
        targetGroup: {
            __typename?: 'TargetGroup';
            id: string;
            name?: string | undefined;
            emailTargets?: Array<{
                __typename?: 'EmailTarget';
                emailAddress?: string | undefined;
                id: string;
                isConfirmed: boolean;
                name?: string | undefined;
            } | undefined> | undefined;
            smsTargets?: Array<{
                __typename?: 'SmsTarget';
                id: string;
                isConfirmed: boolean;
                name?: string | undefined;
                phoneNumber?: string | undefined;
            } | undefined> | undefined;
            telegramTargets?: Array<{
                __typename?: 'TelegramTarget';
                id: string;
                isConfirmed: boolean;
                name?: string | undefined;
                telegramId: string;
                confirmationUrl?: string | undefined;
            } | undefined> | undefined;
            webhookTargets?: Array<{
                __typename?: 'WebhookTarget';
                id: string;
                url: string;
                status: WebhookStatus;
                format: WebhookPayloadFormat;
                name?: string | undefined;
                headers?: Array<{
                    __typename?: 'KeyValuePairOfStringAndString';
                    key: string;
                    value: string;
                }> | undefined;
            } | undefined> | undefined;
            discordTargets?: Array<{
                __typename?: 'DiscordTarget';
                id: string;
                discordAccountId?: string | undefined;
                discriminator?: string | undefined;
                isConfirmed: boolean;
                username?: string | undefined;
                name?: string | undefined;
                userStatus: DiscordTargetStatus;
                verificationLink?: string | undefined;
                discordServerInviteLink?: string | undefined;
            } | undefined> | undefined;
        };
    } | undefined> | undefined;
    sourceGroup?: Array<{
        __typename?: 'SourceGroup';
        id: string;
        name?: string | undefined;
        sources?: Array<{
            __typename?: 'Source';
            id: string;
            name?: string | undefined;
            type: SourceType;
            blockchainAddress: string;
            fusionEventTypeId?: string | undefined;
            applicableFilters?: Array<{
                __typename?: 'Filter';
                id: string;
                name?: string | undefined;
                filterType: FilterType;
            } | undefined> | undefined;
        } | undefined> | undefined;
    } | undefined> | undefined;
    connectedWallet?: Array<{
        __typename?: 'ConnectedWallet';
        address?: string | undefined;
        walletBlockchain: WalletBlockchain;
    } | undefined> | undefined;
    source?: Array<{
        __typename?: 'Source';
        id: string;
        name?: string | undefined;
        type: SourceType;
        blockchainAddress: string;
        fusionEventTypeId?: string | undefined;
        applicableFilters?: Array<{
            __typename?: 'Filter';
            id: string;
            name?: string | undefined;
            filterType: FilterType;
        } | undefined> | undefined;
    } | undefined> | undefined;
    targetGroup?: Array<{
        __typename?: 'TargetGroup';
        id: string;
        name?: string | undefined;
        emailTargets?: Array<{
            __typename?: 'EmailTarget';
            emailAddress?: string | undefined;
            id: string;
            isConfirmed: boolean;
            name?: string | undefined;
        } | undefined> | undefined;
        smsTargets?: Array<{
            __typename?: 'SmsTarget';
            id: string;
            isConfirmed: boolean;
            name?: string | undefined;
            phoneNumber?: string | undefined;
        } | undefined> | undefined;
        telegramTargets?: Array<{
            __typename?: 'TelegramTarget';
            id: string;
            isConfirmed: boolean;
            name?: string | undefined;
            telegramId: string;
            confirmationUrl?: string | undefined;
        } | undefined> | undefined;
        webhookTargets?: Array<{
            __typename?: 'WebhookTarget';
            id: string;
            url: string;
            status: WebhookStatus;
            format: WebhookPayloadFormat;
            name?: string | undefined;
            headers?: Array<{
                __typename?: 'KeyValuePairOfStringAndString';
                key: string;
                value: string;
            }> | undefined;
        } | undefined> | undefined;
        discordTargets?: Array<{
            __typename?: 'DiscordTarget';
            id: string;
            discordAccountId?: string | undefined;
            discriminator?: string | undefined;
            isConfirmed: boolean;
            username?: string | undefined;
            name?: string | undefined;
            userStatus: DiscordTargetStatus;
            verificationLink?: string | undefined;
            discordServerInviteLink?: string | undefined;
        } | undefined> | undefined;
    } | undefined> | undefined;
    emailTarget?: Array<{
        __typename?: 'EmailTarget';
        emailAddress?: string | undefined;
        id: string;
        isConfirmed: boolean;
        name?: string | undefined;
    } | undefined> | undefined;
    smsTarget?: Array<{
        __typename?: 'SmsTarget';
        id: string;
        isConfirmed: boolean;
        name?: string | undefined;
        phoneNumber?: string | undefined;
    } | undefined> | undefined;
    telegramTarget?: Array<{
        __typename?: 'TelegramTarget';
        id: string;
        isConfirmed: boolean;
        name?: string | undefined;
        telegramId: string;
        confirmationUrl?: string | undefined;
    } | undefined> | undefined;
    discordTarget?: Array<{
        __typename?: 'DiscordTarget';
        id: string;
        discordAccountId?: string | undefined;
        discriminator?: string | undefined;
        isConfirmed: boolean;
        username?: string | undefined;
        name?: string | undefined;
        userStatus: DiscordTargetStatus;
        verificationLink?: string | undefined;
        discordServerInviteLink?: string | undefined;
    }> | undefined;
    filter?: Array<{
        __typename?: 'Filter';
        id: string;
        name?: string | undefined;
        filterType: FilterType;
    } | undefined> | undefined;
};

interface HardwareLoginPlugin {
    sendMessage: (message: string) => Promise<string>;
}

declare type SolanaParams = Readonly<{
    walletBlockchain: 'SOLANA';
    walletPublicKey: string;
    signMessage: Uint8SignMessageFunction;
    hardwareLoginPlugin: HardwareLoginPlugin;
}>;
declare type EthereumParams = Readonly<{
    walletBlockchain: 'ETHEREUM';
    walletPublicKey: string;
    signMessage: Uint8SignMessageFunction;
}>;
declare type PolygonParams = Readonly<{
    walletBlockchain: 'POLYGON';
    walletPublicKey: string;
    signMessage: Uint8SignMessageFunction;
}>;
declare type ArbitrumParams = Readonly<{
    walletBlockchain: 'ARBITRUM';
    walletPublicKey: string;
    signMessage: Uint8SignMessageFunction;
}>;
declare type BinanceParams = Readonly<{
    walletBlockchain: 'BINANCE';
    walletPublicKey: string;
    signMessage: Uint8SignMessageFunction;
}>;
declare type BaseParams = Readonly<{
    walletBlockchain: 'BASE';
    walletPublicKey: string;
    signMessage: Uint8SignMessageFunction;
}>;
declare type AptosParams = Readonly<{
    walletBlockchain: 'APTOS';
    accountAddress: string;
    walletPublicKey: string;
    signMessage: AptosSignMessageFunction;
}>;
declare type ZksyncParams = Readonly<{
    walletBlockchain: 'ZKSYNC';
    walletPublicKey: string;
    signMessage: Uint8SignMessageFunction;
}>;
declare type AcalaParams = Readonly<{
    walletBlockchain: 'ACALA';
    accountAddress: string;
    walletPublicKey: string;
    signMessage: AcalaSignMessageFunction;
}>;
declare type OptimismParams = Readonly<{
    walletBlockchain: 'OPTIMISM';
    walletPublicKey: string;
    signMessage: Uint8SignMessageFunction;
}>;
declare type NearParams = Readonly<{
    walletBlockchain: 'NEAR';
    accountAddress: string;
    walletPublicKey: string;
    signMessage: Uint8SignMessageFunction;
}>;
declare type InjectiveParams = Readonly<{
    walletBlockchain: 'INJECTIVE';
    accountAddress: string;
    walletPublicKey: string;
    signMessage: Uint8SignMessageFunction;
}>;
declare type OsmosisParams = Readonly<{
    walletBlockchain: 'OSMOSIS';
    accountAddress: string;
    walletPublicKey: string;
    signMessage: Uint8SignMessageFunction;
}>;
declare type NibiruParams = Readonly<{
    walletBlockchain: 'NIBIRU';
    accountAddress: string;
    walletPublicKey: string;
    signMessage: Uint8SignMessageFunction;
}>;
declare type AvalancheParams = Readonly<{
    walletBlockchain: 'AVALANCHE';
    walletPublicKey: string;
    signMessage: Uint8SignMessageFunction;
}>;
declare type SuiParams = Readonly<{
    walletBlockchain: 'SUI';
    accountAddress: string;
    walletPublicKey: string;
    signMessage: Uint8SignMessageFunction;
}>;
declare type MultiWalletParams = Readonly<{
    ownedWallets: ReadonlyArray<WalletWithSignParams>;
}>;
declare type WalletParams = SolanaParams | EthereumParams | PolygonParams | AvalancheParams | ArbitrumParams | BaseParams | BinanceParams | AptosParams | AcalaParams | NearParams | AvalancheParams | OptimismParams | InjectiveParams | OsmosisParams | NibiruParams | SuiParams | ZksyncParams;
declare type NotifiParams = Readonly<{
    alertConfigurations?: Record<string, AlertConfiguration | null>;
    dappAddress: string;
    env: NotifiEnvironment;
    keepSubscriptionData?: boolean;
    multiWallet?: MultiWalletParams;
    isUsingFrontendClient?: boolean;
}> & WalletParams;
declare const NotifiContext: React__default.FC<React__default.PropsWithChildren<NotifiParams>>;

declare type NotifiClientContextData = Readonly<{
    client: ReturnType<typeof useNotifiClient>;
    frontendClient: NotifiFrontendClient;
    isUsingFrontendClient: boolean;
    params: NotifiParams;
    frontendClientStatus: FrontendClientStatus;
    updateFrontendClientStatus: () => void;
}>;
declare type FrontendClientStatus = {
    isExpired: boolean;
    isInitialized: boolean;
    isAuthenticated: boolean;
};
declare const NotifiClientContextProvider: React__default.FC<NotifiParams>;
declare const useNotifiClientContext: () => Readonly<{
    client: ReturnType<typeof useNotifiClient>;
    frontendClient: NotifiFrontendClient;
    isUsingFrontendClient: boolean;
    params: NotifiParams;
    frontendClientStatus: FrontendClientStatus;
    updateFrontendClientStatus: () => void;
}>;

declare type FormErrorMessages = DestinationInputs;
declare type NotifiFormData = Readonly<{
    formState: DestinationInputs;
    formErrorMessages: FormErrorMessages;
    hasChanges: boolean;
    setHasChanges: (value: boolean) => void;
    setEmail: (value: string) => void;
    setEmailErrorMessage: (value: string) => void;
    setPhoneNumber: (value: string) => void;
    setPhoneNumberErrorMessage: (value: string) => void;
    setTelegram: (value: string) => void;
    setTelegramErrorMessage: (value: string) => void;
}>;
declare const NotifiFormProvider: React__default.FC<PropsWithChildren<unknown>>;
declare const useNotifiForm: () => NotifiFormData;

declare type ClientData = Readonly<{
    alerts: ReadonlyArray<AlertFragmentFragment>;
    connectedWallets: ReadonlyArray<ConnectedWallet>;
    emailTargets: ReadonlyArray<EmailTargetFragmentFragment>;
    filters: ReadonlyArray<FilterFragmentFragment>;
    smsTargets: ReadonlyArray<SmsTargetFragmentFragment>;
    sources: ReadonlyArray<SourceFragmentFragment>;
    targetGroups: ReadonlyArray<TargetGroupFragmentFragment>;
    telegramTargets: ReadonlyArray<TelegramTargetFragmentFragment>;
    sourceGroups: ReadonlyArray<SourceGroupFragmentFragment>;
    discordTargets: ReadonlyArray<DiscordTargetFragmentFragment>;
}>;
declare type SubscriptionData = Readonly<{
    alerts: Readonly<Record<string, AlertFragmentFragment>>;
    email: string | null;
    phoneNumber: string | null;
    telegramId: string | null;
    telegramConfirmationUrl: string | null;
    isPhoneNumberConfirmed: boolean | null;
    discordId: string | null;
}>;
declare type InstantSubscribe = Readonly<{
    alertName: string;
    alertConfiguration: AlertConfiguration | null;
}>;
declare type useNotifiSubscribeProps = Readonly<{
    targetGroupName?: string;
}>;
declare const useNotifiSubscribe: ({ targetGroupName, }: useNotifiSubscribeProps) => Readonly<{
    isAuthenticated: boolean;
    isEmailConfirmationSent: boolean;
    isInitialized: boolean;
    isTokenExpired: boolean;
    logIn: () => Promise<SubscriptionData>;
    subscribe: (alertConfigs: Record<string, AlertConfiguration | null>) => Promise<SubscriptionData>;
    subscribeWallet: (walletParams: ConnectWalletParams) => Promise<void>;
    updateWallets: () => Promise<void>;
    instantSubscribe: (subscribeData: InstantSubscribe) => Promise<SubscriptionData>;
    updateTargetGroups: () => Promise<SubscriptionData>;
    resendEmailVerificationLink: (emailId: string) => Promise<string>;
    reload: () => Promise<SubscriptionData>;
}>;

declare type PreviewViewState = Readonly<{
    state: 'preview';
}>;
declare type AlertHistoryViewState = Readonly<{
    state: 'history';
}>;
declare type EditInfoViewState = Readonly<{
    state: 'edit';
}>;
declare type ExpiredTokenViewState = Readonly<{
    state: 'expired';
}>;
declare type VerifyWalletViewState = Readonly<{
    state: 'verify';
}>;
declare type SignUpViewState = Readonly<{
    state: 'signup';
}>;
declare type VerifyOnboardingViewState = Readonly<{
    state: 'verifyonboarding';
}>;
declare type ErrorViewState = Readonly<{
    state: 'error';
    reason: unknown;
}>;
declare type FetchedCardViewState = PreviewViewState | AlertHistoryViewState | EditInfoViewState | VerifyWalletViewState | ExpiredTokenViewState | SignUpViewState | VerifyOnboardingViewState | ErrorViewState;
declare const useFetchedCardState: () => {
    cardView: FetchedCardViewState;
    setCardView: React.Dispatch<React.SetStateAction<FetchedCardViewState>>;
};

declare type ClientFetchSubscriptionCardInput = Omit<FindTenantConfigInput, 'tenant'>;
declare type LoadingState = Readonly<{
    state: 'loading';
}>;
declare type Data = CardConfigItemV1$1;
declare type FetchedState = Readonly<{
    state: 'fetched';
    data: Data;
}>;
declare type SubscriptionCardState = LoadingState | FetchedState | ErrorViewState;
declare const useSubscriptionCard: (input: ClientFetchSubscriptionCardInput) => SubscriptionCardState;

declare type ValueOrRef<ValueType> = Readonly<{
    type: 'ref';
    ref: string | null;
}> | Readonly<{
    type: 'value';
    value: ValueType;
}>;
declare type DirectPushEventTypeItem = Readonly<{
    type: 'directPush';
    name: string;
    directPushId: ValueOrRef<string>;
    tooltipContent?: string;
}>;
declare type BroadcastEventTypeItem = Readonly<{
    type: 'broadcast';
    name: string;
    broadcastId: ValueOrRef<string>;
    tooltipContent?: string;
}>;
declare type FusionTypeBase = {
    name: string;
    type: 'fusion' | 'fusionToggle';
    fusionEventId: ValueOrRef<string>;
    sourceAddress: ValueOrRef<string>;
    tooltipContent?: string;
    maintainSourceGroup?: boolean;
    alertFrequency?: AlertFrequency;
    optOutAtSignup?: boolean;
    displayNameOverride?: string;
};
declare type FusionToggleEventTypeItem = FusionTypeBase & Readonly<{
    selectedUIType: 'TOGGLE';
}>;
declare type FusionHealthCheckEventTypeItem = FusionTypeBase & Readonly<{
    selectedUIType: 'HEALTH_CHECK';
    healthCheckSubtitle: string;
    numberType: NumberTypeSelect;
    checkRatios: CheckRatio[];
    validInputRange?: ValidInputRange;
}>;
declare type ValidInputRange = {
    max: number;
    min: number;
};
declare type FusionMultiThresholdEventTypeItem = FusionTypeBase & Readonly<{
    selectedUIType: 'MULTI_THRESHOLD';
    numberType: NumberTypeSelect;
    subtitle?: string;
    addThresholdTitle?: string;
}>;
declare type FusionEventTypeItem = FusionToggleEventTypeItem | FusionHealthCheckEventTypeItem | FusionMultiThresholdEventTypeItem;
declare type HealthCheckEventTypeItem = Readonly<{
    type: 'healthCheck';
    name: string;
    checkRatios: ValueOrRef<CheckRatio[]>;
    alertFrequency: AlertFrequency;
    tooltipContent?: string;
}>;
declare type RatiosBelow = Readonly<{
    type: 'below';
    ratio: number;
}>;
declare type RatiosAbove = Readonly<{
    type: 'above';
    ratio: number;
}>;
declare type CheckRatio = RatiosBelow | RatiosAbove;
declare type LabelEventTypeItem = Readonly<{
    type: 'label';
    name: string;
    tooltipContent?: string;
}>;
declare type TradingPairEventTypeItem = Readonly<{
    type: 'tradingPair';
    name: string;
    tooltipContent?: string;
    tradingPairs: ValueOrRef<ReadonlyArray<string>>;
}>;
declare type WalletBalanceEventTypeItem = Readonly<{
    type: 'walletBalance';
    name: string;
    tooltipContent?: string;
}>;
declare type PriceChangeDataSource = 'coingecko';
declare type PriceChangeEventTypeItem = Readonly<{
    type: 'priceChange';
    name: string;
    tokenIds: ReadonlyArray<string>;
    dataSource: PriceChangeDataSource;
    tooltipContent: string;
}>;
declare type USER_INTERFACE_TYPE = 'TOGGLE' | 'HEALTH_CHECK' | 'MULTI_THRESHOLD';
declare type NumberTypeSelect = 'percentage' | 'integer' | 'price';
declare type CustomToggleTypeItem = Readonly<{
    filterOptions: FilterOptions;
    selectedUIType: 'TOGGLE';
}>;
declare type CustomHealthCheckItem = Readonly<{
    selectedUIType: 'HEALTH_CHECK';
    healthCheckSubtitle: string;
    numberType: NumberTypeSelect;
    alertFrequency: AlertFrequency;
    checkRatios: CheckRatio[];
}>;
declare type CustomTopicTypeItem = CustomTypeBase & (CustomToggleTypeItem | CustomHealthCheckItem);
declare type UserInterfaceType = CustomTopicTypeItem['selectedUIType'];
declare type CustomTypeBase = {
    type: 'custom';
    name: string;
    tooltipContent: string;
    sourceType: CreateSourceInput['type'];
    filterType: string;
    sourceAddress: ValueOrRef<string>;
};
declare type XMTPTopicTypeItem = {
    type: 'XMTP';
    name: string;
    tooltipContent: string;
    sourceType?: CreateSourceInput['type'];
    filterType: string;
    XMTPTopics: ValueOrRef<ReadonlyArray<string>>;
};
declare type EventTypeItem = DirectPushEventTypeItem | BroadcastEventTypeItem | HealthCheckEventTypeItem | LabelEventTypeItem | TradingPairEventTypeItem | WalletBalanceEventTypeItem | PriceChangeEventTypeItem | CustomTopicTypeItem | XMTPTopicTypeItem;
declare type EventTypeConfig = ReadonlyArray<EventTypeItem>;
declare type InputType = 'WebhookUrlInput' | 'WebhookHeadersInput' | 'DirectPushIdInput' | 'BroadcastIdInput';
declare type InputItem = Readonly<{
    name: string;
    type: InputType;
}>;
declare type InputsConfig = ReadonlyArray<InputItem>;
declare type ContactInfo = Readonly<{
    active: boolean;
}>;
declare type EmailContactInfo = ContactInfo;
declare type DiscordContactInfo = ContactInfo;
declare type CountryCode = string;
declare type SmsContactInfo = ContactInfo & Readonly<{
    supportedCountryCodes: ReadonlyArray<CountryCode>;
}>;
declare type TelegramContactInfo = ContactInfo;
declare type WebhookHeaders = Readonly<Record<string, string>>;
declare type WebhookContactInfo = ContactInfo & Readonly<{
    url: ValueOrRef<string>;
    headers: ValueOrRef<WebhookHeaders>;
}>;
declare type ContactInfoConfig = Readonly<{
    email: EmailContactInfo;
    sms: SmsContactInfo;
    telegram: TelegramContactInfo;
    webhook: WebhookContactInfo;
    discord: DiscordContactInfo;
}>;
declare type CardConfigItemV1 = Readonly<{
    version: 'v1';
    id: string | null;
    name: string;
    eventTypes: EventTypeConfig;
    inputs: InputsConfig;
    contactInfo: ContactInfoConfig;
    titles?: TitleSubtitleConfig;
}>;
declare type TitleSubtitleConfigInactive = Readonly<{
    active: false;
}>;
declare type TitleSubtitleConfigActive = Readonly<{
    active: true;
    editView: string;
    previewView: string;
    historyView: string;
    signupView: string;
    expiredView: string;
    alertDetailsView: string;
    verifyWalletsView: string;
}>;
declare type TitleSubtitleConfig = TitleSubtitleConfigActive | TitleSubtitleConfigInactive;

declare const useUnreadState: () => {
    hasUnreadNotification: boolean;
    unreadNotificationCount: number;
};

declare const useFrontendClientLogin: () => () => Promise<UserFragmentFragment>;

declare type startChatView = Readonly<{
    state: 'startChatView';
}>;
declare type chatWindowView = Readonly<{
    state: 'chatWindowView';
}>;
declare type settingView = Readonly<{
    state: 'settingView';
}>;
declare type loadingView = Readonly<{
    state: 'loadingView';
}>;
declare type IntercomCardView = startChatView | chatWindowView | settingView | loadingView;

declare type DestinationInputs = Record<FormField, string>;
declare type FormField = 'email' | 'phoneNumber' | 'telegram' | 'discord';
declare type DestinationErrorMessageField = {
    field: FormField;
    value: DestinationError;
};
declare type EditFormType = {
    field: FormField;
    value: string;
};
declare type RecoverableError = Readonly<{
    type: 'recoverableError';
    message: string;
    onClick: () => void;
    tooltip?: string;
}>;
declare type UnrecoverableError = Readonly<{
    type: 'unrecoverableError';
    message: string;
    tooltip?: string;
}>;
declare type DestinationError = UnrecoverableError | RecoverableError | undefined;
declare type DestinationErrors = Record<FormField, DestinationError>;

declare type DestinationErrorMessages = DestinationErrors;
declare enum FtuStage {
    Destination = 3,
    Alerts = 2,
    Done = 1
}
declare type NotifiSubscriptionData = Readonly<{
    alerts: Readonly<Record<string, AlertFragmentFragment | undefined>>;
    connectedWallets: ReadonlyArray<ConnectedWalletFragmentFragment>;
    setConnectedWallets: React__default.Dispatch<React__default.SetStateAction<ReadonlyArray<ConnectedWalletFragmentFragment>>>;
    destinationErrorMessages: DestinationErrorMessages;
    email: string;
    params: NotifiParams;
    phoneNumber: string;
    telegramId: string;
    telegramConfirmationUrl?: string;
    useHardwareWallet: boolean;
    useDiscord: boolean;
    /**
     * @deprecated Now this context can be consumed as long as the component is wrapped in NotifiContext
     */
    contextId: string;
    cardView: FetchedCardViewState;
    setCardView: React__default.Dispatch<React__default.SetStateAction<FetchedCardViewState>>;
    intercomCardView: IntercomCardView;
    setIntercomCardView: React__default.Dispatch<React__default.SetStateAction<IntercomCardView>>;
    setAlerts: (alerts: Record<string, AlertFragmentFragment | undefined>) => void;
    setEmail: (email: string) => void;
    setPhoneNumber: (phoneNumber: string) => void;
    setTelegramId: (telegramId: string) => void;
    setUseHardwareWallet: React__default.Dispatch<React__default.SetStateAction<boolean>>;
    setUseDiscord: React__default.Dispatch<React__default.SetStateAction<boolean>>;
    loading: boolean;
    setLoading: (loading: boolean) => void;
    hasChatAlert: boolean;
    setHasChatAlert: (hasChatAlert: boolean) => void;
    conversationId: string;
    setConversationId: (conversationId: string) => void;
    userId: string;
    setUserId: (userId: string) => void;
    setEmailErrorMessage: (value: DestinationError) => void;
    setTelegramConfirmationUrl: (telegramConfirmationUrl: string | undefined) => void;
    setPhoneNumberErrorMessage: (value: DestinationError) => void;
    setDiscordErrorMessage: (value: DestinationError) => void;
    setTelegramErrorMessage: (value: DestinationError) => void;
    resetErrorMessageState: () => void;
    discordTargetData: DiscordTargetFragmentFragment | undefined;
    setDiscordTargetData: React__default.Dispatch<React__default.SetStateAction<DiscordTargetFragmentFragment | undefined>>;
    ftuStage: FtuStage;
    syncFtuStage: (isContactInfoRequired?: boolean) => Promise<void>;
    updateFtuStage: (ftuConfigStep: FtuStage) => Promise<void>;
    render: (newData: FetchDataQuery) => SubscriptionData;
}>;
declare const NotifiSubscriptionContextProvider: React__default.FC<PropsWithChildren<NotifiParams>>;
declare const useNotifiSubscriptionContext: () => NotifiSubscriptionData;

declare type DemoPreview = {
    view: FetchedCardViewState['state'];
    data: CardConfigItemV1$1;
};
declare const defaultDemoConfigV1: CardConfigItemV1$1;
declare type NotifiDemoPreviewContextData = Readonly<{
    demoPreview: DemoPreview;
}>;
declare const NotifiDemoPreviewContextProvider: React__default.FC<PropsWithChildren<DemoPreview>>;
declare const useNotifiDemoPreviewContext: () => Readonly<{
    demoPreview: DemoPreview;
}>;

declare type SingleSourceAlertConfiguration = Readonly<{
    type: 'single';
    sourceType: CreateSourceInput['type'];
    createSource?: Readonly<{
        address: string;
        fusionEventTypeId?: string;
    }>;
    filterType: string;
    filterOptions: FilterOptions | null;
    sourceGroupName?: string;
    maintainSourceGroup?: boolean;
}>;
declare type MultipleSourceAlertConfiguration = Readonly<{
    type: 'multiple';
    sources: ReadonlyArray<CreateSourceInput>;
    filterType: string;
    filterOptions: FilterOptions | null;
    sourceGroupName?: string;
    maintainSourceGroup?: boolean;
}>;
declare type AlertConfiguration = SingleSourceAlertConfiguration | MultipleSourceAlertConfiguration;
declare const chatConfiguration: () => AlertConfiguration;
declare const customThresholdConfiguration: ({ alertFrequency, threshold, filterType, thresholdDirection, sourceType, sourceAddress, }: Readonly<{
    alertFrequency: FilterOptions['alertFrequency'];
    threshold: number;
    filterType: string;
    thresholdDirection: FilterOptions['thresholdDirection'];
    sourceType: CreateSourceInput['type'];
    sourceAddress: string;
}>) => AlertConfiguration;
declare const customToggleConfiguration: ({ filterType, filterOptions, sourceType, sourceAddress, }: Readonly<{
    filterType: string;
    filterOptions: FilterOptions;
    sourceType: CreateSourceInput['type'];
    sourceAddress: string;
}>) => AlertConfiguration;
declare type XMTPTopic = Readonly<{
    address: string | null;
    walletBlockchain: string;
}>;
declare const XMTPToggleConfiguration: ({ XMTPTopics, }: Readonly<{
    XMTPTopics: ReadonlyArray<string>;
}>) => AlertConfiguration;
declare const broadcastMessageConfiguration: ({ topicName, }: Readonly<{
    topicName: string;
}>) => AlertConfiguration;
declare const fusionToggleConfiguration: ({ fusionId, fusionSourceAddress, maintainSourceGroup, alertFrequency, }: Readonly<{
    fusionId: string;
    fusionSourceAddress: string;
    maintainSourceGroup?: boolean | undefined;
    alertFrequency: FilterOptions['alertFrequency'] | undefined;
}>) => AlertConfiguration;
declare type FusionToggleConfiguration = {
    fusionId: string;
    fusionSourceAddress: string;
    maintainSourceGroup?: boolean;
    alertFrequency: FilterOptions['alertFrequency'];
    threshold: number;
    thresholdDirection: FilterOptions['thresholdDirection'];
};
declare const fusionHealthCheckConfiguration: (props: FusionToggleConfiguration) => AlertConfiguration;
declare const directMessageConfiguration: (params?: Readonly<{
    type?: string;
}>) => AlertConfiguration;
declare const healthThresholdConfiguration: ({ alertFrequency, percentage, thresholdDirection, }: Readonly<{
    alertFrequency: FilterOptions['alertFrequency'];
    percentage: number;
    thresholdDirection: FilterOptions['thresholdDirection'];
}>) => AlertConfiguration;
declare const hedgeProtocolConfiguration: ({ walletAddress, }: Readonly<{
    walletAddress: string;
}>) => AlertConfiguration;
declare const tradingPairConfiguration: ({ tradingPair, above, price, }: Readonly<{
    tradingPair: string;
    above: boolean;
    price: number;
}>) => AlertConfiguration;
declare const walletBalanceConfiguration: ({ connectedWallets, }: Readonly<{
    connectedWallets: ReadonlyArray<ConnectedWalletFragmentFragment>;
}>) => AlertConfiguration;
declare const priceChangeConfiguration: ({ tokenIds, }: Readonly<{
    tokenIds: ReadonlyArray<string>;
}>) => AlertConfiguration;
declare const createConfigurations: (eventTypes: EventTypeConfig$1, inputs: Record<string, unknown>, connectedWallets: NotifiSubscriptionData['connectedWallets']) => Record<string, AlertConfiguration>;

declare type DeepPartialReadonly<T> = T extends object ? Readonly<{
    [Key in keyof T]?: DeepPartialReadonly<T[Key]>;
}> : T;

declare type AlertNotificationViewProps = Readonly<{
    notificationTitle: string | undefined;
    notificationImage?: JSX.Element;
    notificationSubject: string | undefined;
    notificationDate: string;
    notificationMessage: string | undefined;
    classNames?: Readonly<{
        notificationContent?: string;
        notificationDate?: string;
        notificationImage?: string;
        notificationMessage?: string;
        notificationRow?: string;
        notificationSubject?: string;
        notificationTitle?: string;
    }>;
    handleAlertEntrySelection?: () => void;
}>;

declare type NotifiToggleProps = Readonly<{
    classNames?: Readonly<{
        container?: string;
        input?: string;
        slider?: string;
    }>;
    disabled: boolean;
    checked: boolean;
    setChecked: React__default.Dispatch<React__default.SetStateAction<boolean>>;
    intercomToggleStyle?: string;
}>;
declare const NotifiToggle: React__default.FC<NotifiToggleProps>;

declare type NotifiTooltipProps = Readonly<{
    classNames?: Readonly<{
        container?: string;
        icon?: string;
        tooltip?: string;
        tooltipLabel?: string;
    }>;
    content: string;
}>;
declare const NotifiTooltip: React__default.FC<NotifiTooltipProps>;

declare type EventTypeBroadcastRowProps = Readonly<{
    classNames?: DeepPartialReadonly<{
        container: string;
        label: string;
        toggle: NotifiToggleProps['classNames'];
        tooltip: NotifiTooltipProps['classNames'];
    }>;
    disabled: boolean;
    config: BroadcastEventTypeItem$1;
    inputs: Record<string, unknown>;
}>;
declare const EventTypeBroadcastRow: React__default.FC<EventTypeBroadcastRowProps>;

declare type EventTypeCustomHealthCheckRowProps = Readonly<{
    classNames?: DeepPartialReadonly<{
        container: string;
        label: string;
        content: string;
        button: string;
        toggle: NotifiToggleProps['classNames'];
        buttonContainer: string;
        errorMessage: string;
        tooltip: NotifiTooltipProps['classNames'];
    }>;
    disabled: boolean;
    config: CustomTopicTypeItem$1;
    inputs: Record<string, unknown>;
}>;
declare const EventTypeCustomHealthCheckRow: React__default.FC<EventTypeCustomHealthCheckRowProps>;

declare type EventTypeCustomToggleRowProps = Readonly<{
    classNames?: DeepPartialReadonly<{
        container: string;
        label: string;
        toggle: NotifiToggleProps['classNames'];
        tooltip: NotifiTooltipProps['classNames'];
    }>;
    disabled: boolean;
    config: CustomTopicTypeItem$1;
    inputs: Record<string, unknown>;
}>;
declare const EventTypeCustomToggleRow: React__default.FC<EventTypeCustomToggleRowProps>;

declare type EventTypeDirectPushRowProps = Readonly<{
    classNames?: DeepPartialReadonly<{
        container: string;
        label: string;
        toggle: NotifiToggleProps['classNames'];
        tooltip: NotifiTooltipProps['classNames'];
    }>;
    disabled: boolean;
    config: DirectPushEventTypeItem;
    inputs: Record<string, unknown>;
}>;
declare const EventTypeDirectPushRow: React__default.FC<EventTypeDirectPushRowProps>;

declare type EventTypeHealthCheckRowProps = Readonly<{
    classNames?: DeepPartialReadonly<{
        container: string;
        label: string;
        content: string;
        button: string;
        buttonContainer: string;
        errorMessage: string;
        toggle: NotifiToggleProps['classNames'];
        tooltip: NotifiTooltipProps['classNames'];
    }>;
    disabled: boolean;
    config: HealthCheckEventTypeItem;
}>;
declare const EventTypeHealthCheckRow: React__default.FC<EventTypeHealthCheckRowProps>;

declare type EventTypeLabelRowProps = Readonly<{
    classNames?: DeepPartialReadonly<{
        container: string;
        label: string;
        tooltip: NotifiTooltipProps['classNames'];
    }>;
    config: LabelEventTypeItem;
}>;
declare const EventTypeLabelRow: React__default.FC<EventTypeLabelRowProps>;

declare type EventTypePriceChangeRowProps = Readonly<{
    classNames?: DeepPartialReadonly<{
        container: string;
        label: string;
        toggle: NotifiToggleProps['classNames'];
        tooltip: NotifiTooltipProps['classNames'];
    }>;
    disabled: boolean;
    config: PriceChangeEventTypeItem;
    inputs: Record<string, unknown>;
}>;
declare const EventTypePriceChangeRow: React__default.FC<EventTypePriceChangeRowProps>;

declare type EventTypeTradingPairsRowProps = Readonly<{
    classNames?: DeepPartialReadonly<{
        container: string;
        label: string;
        addPair: string;
        tooltip: NotifiTooltipProps['classNames'];
        tradingPairAlertRow: TradingPairAlertRowProps['classNames'];
        tradingPairSettingsRow: TradingPairSettingsRowProps['classNames'];
    }>;
    config: TradingPairEventTypeItem;
    inputs: Record<string, unknown>;
}>;
declare const EventTypeTradingPairsRow: React__default.FC<EventTypeTradingPairsRowProps>;
declare type TradingPairAlertRowProps = Readonly<{
    classNames?: DeepPartialReadonly<{
        container: string;
        textContainer: string;
        name: string;
        description: string;
        deleteIcon: string;
    }>;
    alertName: string;
    inputs: Record<string, unknown>;
}>;
declare const TradingPairAlertRow: React__default.FC<TradingPairAlertRowProps>;
declare type TradingPairSettingsRowProps = Readonly<{
    classNames?: DeepPartialReadonly<{
        buttonContainer: string;
        radioButton: string;
        container: string;
        dropdown: string;
        dropdownContainer: string;
        label: string;
        option: string;
        priceInput: string;
        priceInputContainer: string;
        saveButton: string;
    }>;
    config: TradingPairEventTypeItem;
    inputs: Record<string, unknown>;
    onSave: () => void;
}>;
declare const TradingPairSettingsRow: React__default.FC<TradingPairSettingsRowProps>;

declare type EventTypeFusionMultiThresholdRowProps = Readonly<{
    classNames?: DeepPartialReadonly<{
        container: string;
        content: string;
        label: string;
        addThreshold: string;
        tooltip: NotifiTooltipProps['classNames'];
        fusionMultiThresholdAlertRow: FusionMultiThresholdAlertRowProps['classNames'];
        fusionMultiThresholdSettingsRow: FusionMultiThresholdSettingsRowProps['classNames'];
    }>;
    config: FusionMultiThresholdEventTypeItem;
    inputs: Record<string, unknown>;
}>;
declare const EventTypeFusionMultiThresholdRow: React__default.FC<EventTypeFusionMultiThresholdRowProps>;
declare type FusionMultiThresholdAlertRowProps = Readonly<{
    classNames?: DeepPartialReadonly<{
        container: string;
        textContainer: string;
        name: string;
        description: string;
        deleteIcon: string;
    }>;
    alertName: string;
    inputs: Record<string, unknown>;
}>;
declare const FusionMultiThresholdAlertRow: React__default.FC<FusionMultiThresholdAlertRowProps>;
declare type FusionMultiThresholdSettingsRowProps = Readonly<{
    classNames?: DeepPartialReadonly<{
        buttonContainer: string;
        radioButton: string;
        container: string;
        label: string;
        option: string;
        thresholdInput: string;
        thresholdInputContainer: string;
        saveButton: string;
    }>;
    config: FusionMultiThresholdEventTypeItem;
    inputs: Record<string, unknown>;
    onSave: () => void;
}>;
declare const FusionMultiThresholdSettingsRow: React__default.FC<FusionMultiThresholdSettingsRowProps>;

declare type EventTypeUnsupportedRowProps = Readonly<{
    classNames?: DeepPartialReadonly<{
        container: string;
        label: string;
    }>;
}>;
declare const EventTypeUnsupportedRow: React__default.FC<EventTypeUnsupportedRowProps>;

declare type EventTypeWalletBalanceRowProps = Readonly<{
    classNames?: DeepPartialReadonly<{
        container: string;
        label: string;
        toggle: NotifiToggleProps['classNames'];
        tooltip: NotifiTooltipProps['classNames'];
    }>;
    disabled: boolean;
    config: WalletBalanceEventTypeItem;
    inputs: Record<string, unknown>;
}>;
declare const EventTypeWalletBalanceRow: React__default.FC<EventTypeWalletBalanceRowProps>;

declare type NotifiDisclosureStatementProps = Readonly<{
    classNames?: DeepPartialReadonly<{
        container: string;
        label: string;
        hyperlink: string;
    }>;
    disclosureCopy: string;
}>;

declare type NotifiFooterProps = Readonly<{
    classNames?: DeepPartialReadonly<{
        container: string;
        poweredBy: string;
        logoSvg: string;
        link: string;
        spacer: string;
        disclosure: NotifiDisclosureStatementProps['classNames'];
    }>;
    copy?: DeepPartialReadonly<{
        poweredBy: string;
        learnMore: string;
        disclosure: string;
    }>;
}>;
declare const NotifiFooter: React__default.FC<NotifiFooterProps>;

declare type Props$3 = React__default.SVGProps<SVGSVGElement>;

declare type Props$2 = React__default.SVGProps<SVGSVGElement>;

declare type Props$1 = React__default.SVGProps<SVGSVGElement>;

declare const icons: {
    readonly back: React__default.FC<Props$1>;
    readonly close: React__default.FC<Props$2>;
    readonly settings: React__default.FC<Props$3>;
};
declare type AlertActionIconProps = Readonly<{
    name: keyof typeof icons;
    className?: string;
}>;

declare type NotifiAlertBoxButtonProps = Readonly<{
    name: AlertActionIconProps['name'];
    onClick: () => void;
}>;
declare type NotifiAlertBoxProps = Readonly<{
    classNames?: DeepPartialReadonly<{
        container: string;
        btnLeft: string;
        content: string;
        btnRight: string;
        iconSvg: string;
        spacer: string;
    }>;
    leftIcon?: NotifiAlertBoxButtonProps;
    rightIcon?: NotifiAlertBoxButtonProps;
}>;

declare type ErrorStateCardProps = Readonly<{
    copy?: DeepPartialReadonly<{
        header: string;
    }>;
    reason: unknown;
    classNames?: Readonly<{
        NotifiAlertBox?: NotifiAlertBoxProps['classNames'];
        label?: string;
        errorMessage?: string;
    }>;
    onClose?: () => void;
}>;

declare type LoadingStateCardProps = Readonly<{
    spinnerSize?: string;
    ringColor?: string;
    copy?: DeepPartialReadonly<{
        header: string;
        content: string;
    }>;
    classNames?: Readonly<{
        container?: string;
        label?: string;
        NotifiAlertBox?: NotifiAlertBoxProps['classNames'];
    }>;
    onClose?: () => void;
}>;

declare type NotifiSubscribeButtonProps = Readonly<{
    classNames?: Readonly<{
        button?: string;
        label?: string;
    }>;
    buttonText: string;
    data: CardConfigItemV1$1;
    inputs: Record<string, unknown>;
}>;
declare const NotifiSubscribeButton: React__default.FC<NotifiSubscribeButtonProps>;

declare type NotifiInputSeparators = {
    emailSeparator?: {
        classNames?: {
            container: string;
            content: string;
        };
        content: string;
    };
    smsSeparator?: {
        classNames?: {
            container: string;
            content: string;
        };
        content: string;
    };
    telegramSeparator?: {
        classNames?: {
            container: string;
            content: string;
        };
        content: string;
    };
};
declare type NotifiInputFieldsText = {
    label?: {
        email?: string;
        sms?: string;
        telegram?: string;
    };
    placeholderText?: {
        email?: string;
        sms?: string;
        telegram?: string;
    };
};
declare type NotifiSubscriptionCardProps = Readonly<{
    copy?: DeepPartialReadonly<{
        ErrorStateCard: ErrorStateCardProps['copy'];
        FetchedStateCard: FetchedStateCardProps['copy'];
        LoadingStateCard: LoadingStateCardProps['copy'];
    }>;
    classNames?: Readonly<{
        container?: string;
        ErrorStateCard?: ErrorStateCardProps['classNames'];
        FetchedStateCard?: FetchedStateCardProps['classNames'];
        LoadingStateCard?: LoadingStateCardProps['classNames'];
        NotifiSubscribeButton?: NotifiSubscribeButtonProps['classNames'];
        NotifiFooter?: NotifiFooterProps['classNames'];
    }>;
    loadingSpinnerSize?: string;
    loadingRingColor?: string;
    disclosureCopy?: string;
    inputLabels?: NotifiInputFieldsText;
    darkMode?: boolean;
    cardId: string;
    inputs?: Record<string, unknown>;
    inputSeparators?: NotifiInputSeparators;
    onClose?: () => void;
}>;
declare const NotifiSubscriptionCard: React__default.FC<React__default.PropsWithChildren<NotifiSubscriptionCardProps>>;

declare type AlertDetailsProps = Readonly<{
    notificationEntry: NotificationHistoryEntry;
    classNames?: Readonly<{
        detailsContainer?: string;
        BackArrowIcon?: string;
    }>;
}>;

declare type ConfigAlertModalProps = Readonly<{
    classNames?: {
        container?: string;
        overlay?: string;
        alertsPanel?: AlertsPanelProps['classNames'];
        headerContainer?: string;
        backIcon?: string;
        headerTitle?: string;
        footerContainer?: string;
        ctaIcon?: string;
    };
    updateFtuStage: (step: FtuStage) => void;
    data: CardConfigItemV1$1;
    inputDisabled: boolean;
    inputs: Record<string, unknown>;
}>;

declare type ConfigDestinationModalProps = Readonly<{
    classNames?: {
        container?: string;
        overlay?: string;
        headerContainer?: string;
        headerTitle?: string;
        footerContainer?: string;
        emailContainer?: string;
        emailLabel?: string;
        emailLabelIcon?: string;
        emailHelpPhrase?: string;
        emailAddress?: string;
        emailResendLink?: string;
        smsContainer?: string;
        smsLabel?: string;
        smsLabelIcon?: string;
        phoneNumber?: string;
        telegramContainer?: string;
        telegramLabel?: string;
        telegramLabelIcon?: string;
        telegramId?: string;
        discordContainer?: string;
        discordLabel?: string;
        discordLabelIcon?: string;
        verifiedButton?: string;
        verifyButtonMessage?: string;
        verifyButtonContainer?: string;
    };
    updateFtuStage: (step: FtuStage) => void;
    contactInfo: CardConfigItemV1$1['contactInfo'];
}>;

declare type SignupBannerProps = Readonly<{
    data: CardConfigItemV1$1;
    classNames?: DeepPartialReadonly<{
        banner: string;
        bannerImage: string;
        bannerLabel: string;
        bannerContent: string;
        bannerTitle: string;
        bannerSubject: string;
        bannerButton: string;
    }>;
}>;

declare type VerifyBannerProps = Readonly<{
    classNames?: DeepPartialReadonly<{
        bannerContainer?: string;
        bannerImage?: string;
        bannerImageContainer?: string;
        bannerLabel?: string;
        bannerContent?: string;
        bannerTitle?: string;
        bannerSubject?: string;
        bannerButton?: string;
    }>;
    unVerifiedDestinations: ReadonlyArray<FormField>;
}>;

declare type AlertListPreviewProps = Readonly<{
    alertList?: DeepPartialReadonly<{
        container: string;
        listItem: string;
    }>;
    eventTypes: CardConfigItemV1$1['eventTypes'];
    copy?: DeepPartialReadonly<{
        description: string;
    }>;
    classNames?: DeepPartialReadonly<{
        checkmarkIcon: string;
        container: string;
        description: string;
        eventListItem: string;
    }>;
}>;
declare const AlertListPreview: React__default.FC<AlertListPreviewProps>;

declare type NotifiDiscordToggleProps = Readonly<{
    disabled: boolean;
    classNames?: DeepPartialReadonly<{
        container: string;
        label: string;
        toggle: NotifiToggleProps['classNames'];
    }>;
}>;

declare type NotifiHwWalletToggleProps = Readonly<{
    disabled: boolean;
    classNames?: DeepPartialReadonly<{
        container: string;
        label: string;
        toggle: NotifiToggleProps['classNames'];
    }>;
}>;

declare type NotifiSmsInputProps = Readonly<{
    classNames?: DeepPartialReadonly<{
        container: string;
        input: string;
        dropdownContainer: string;
        dropdownOption: string;
        dropdownSelectField: string;
        label: string;
        errorMessage: string;
    }>;
    copy?: DeepPartialReadonly<{
        placeholder: string;
        label: string;
    }>;
    disabled: boolean;
    allowedCountryCodes: string[];
    intercomSmsInputStyle?: string;
    intercomSmsDropdownContainerStyle?: string;
    intercomSmsDropdownSelectStyle?: string;
    intercomSmsInputContainerStyle?: string;
    intercomView?: boolean;
}>;
declare const NotifiSmsInput: React__default.FC<NotifiSmsInputProps>;

declare type NotifiTelegramInputProps = Readonly<{
    classNames?: DeepPartialReadonly<{
        container: string;
        input: string;
        label: string;
        button: string;
        errorMessage: string;
    }>;
    copy?: DeepPartialReadonly<{
        placeholder: string;
        label: string;
    }>;
    disabled: boolean;
    intercomTelegramInputStyle?: string;
    intercomTelegramInputContainerStyle?: string;
    intercomView?: boolean;
    hasChatAlert?: boolean;
}>;
declare const NotifiTelegramInput: React__default.FC<NotifiTelegramInputProps>;

declare type InputFieldsProps = {
    data: CardConfigItemV1$1;
    inputSeparators?: NotifiInputSeparators;
    inputTextFields?: NotifiInputFieldsText;
    allowedCountryCodes: string[];
    inputDisabled: boolean;
    hideContactInputs?: boolean;
    classNames?: Readonly<{
        NotifiEmailInput?: NotifiEmailInputProps['classNames'];
        NotifiSmsInput?: NotifiSmsInputProps['classNames'];
        NotifiTelegramInput?: NotifiTelegramInputProps['classNames'];
        NotifiHwWalletToggle?: NotifiHwWalletToggleProps['classNames'];
        NotifiDiscordToggle?: NotifiDiscordToggleProps['classNames'];
    }>;
};
declare const InputFields: React__default.FC<InputFieldsProps>;

declare type EditCardViewProps = Readonly<{
    buttonText: string;
    data: CardConfigItemV1$1;
    inputDisabled: boolean;
    showPreview?: boolean;
    copy?: Readonly<{
        AlertListPreview?: AlertListPreviewProps['copy'];
    }>;
    classNames?: Readonly<{
        AlertListPreview?: AlertListPreviewProps['classNames'];
        NotifiInputContainer?: string;
        InputFields?: DeepPartialReadonly<InputFieldsProps['classNames']>;
        NotifiSubscribeButton?: NotifiSubscribeButtonProps['classNames'];
        NotifiInputHeading?: string;
    }>;
    inputSeparators?: NotifiInputSeparators;
    inputTextFields?: NotifiInputFieldsText;
    allowedCountryCodes: string[];
    inputs: Record<string, unknown>;
}>;
declare const EditCardView: React__default.FC<EditCardViewProps>;

declare type ExpiredTokenViewCardProps = {
    classNames?: {
        container?: string;
        title?: string;
        subtitle?: string;
        button?: string;
        buttonLabel?: string;
    };
};

declare type NotificationHistoryEntry = FusionNotificationHistoryEntryFragmentFragment | NotificationHistoryEntryFragmentFragment;
declare type AlertHistoryViewProps = Readonly<{
    noAlertDescription?: string;
    isHidden: boolean;
    data: CardConfigItemV1$1;
    copy?: {
        loadingHeader?: string;
        loadingContent?: string;
        loadingSpinnerSize?: string;
        loadingRingColor?: string;
    };
    classNames?: DeepPartialReadonly<{
        title: string;
        header: string;
        manageAlertLink: string;
        noAlertDescription: string;
        notificationDate: string;
        notificationSubject: string;
        notificationMessage: string;
        notificationImage: string;
        notificationList: string;
        emptyAlertsBellIcon: string;
        historyContainer: string;
        virtuoso: string;
        AlertCard: AlertNotificationViewProps['classNames'];
        LoadingStateCard: LoadingStateCardProps['classNames'];
    }>;
    setAlertEntry: React__default.Dispatch<React__default.SetStateAction<NotificationHistoryEntry | undefined>>;
}>;
declare const AlertHistoryView: React__default.FC<AlertHistoryViewProps>;

declare type EventTypeFusionHealthCheckRowProps = Readonly<{
    classNames?: DeepPartialReadonly<{
        container: string;
        label: string;
        content: string;
        button: string;
        toggle: NotifiToggleProps['classNames'];
        buttonContainer: string;
        errorMessage: string;
        tooltip: NotifiTooltipProps['classNames'];
    }>;
    disabled: boolean;
    config: FusionHealthCheckEventTypeItem$1;
    inputs: Record<string, unknown>;
}>;

declare type EventTypeFusionRowProps = Readonly<{
    classNames?: DeepPartialReadonly<{
        container: string;
        label: string;
        toggle: NotifiToggleProps['classNames'];
        tooltip: NotifiTooltipProps['classNames'];
    }>;
    disabled: boolean;
    config: FusionToggleEventTypeItem$1;
    inputs: Record<string, unknown>;
}>;

declare type EventTypeXMPTRowProps = Readonly<{
    classNames?: DeepPartialReadonly<{
        container: string;
        label: string;
        toggle: NotifiToggleProps['classNames'];
        tooltip: NotifiTooltipProps['classNames'];
    }>;
    disabled: boolean;
    config: XMTPTopicTypeItem$1;
    inputs: Record<string, unknown>;
}>;

declare type AlertsPanelProps = Readonly<{
    data: CardConfigItemV1$1;
    inputDisabled: boolean;
    classNames?: Readonly<{
        EventTypeContainer?: string;
        EventTypeBroadcastRow?: EventTypeBroadcastRowProps['classNames'];
        EventTypeCustomHealthCheckRow?: EventTypeCustomHealthCheckRowProps['classNames'];
        EventTypeDirectPushRow?: EventTypeDirectPushRowProps['classNames'];
        EventTypeHealthCheckRow?: EventTypeHealthCheckRowProps['classNames'];
        EventTypeLabelRow?: EventTypeLabelRowProps['classNames'];
        EventTypePriceChangeRow?: EventTypePriceChangeRowProps['classNames'];
        EventTypeTradingPairsRow?: EventTypeTradingPairsRowProps['classNames'];
        EventTypeFusionMultiThresholdRow?: EventTypeFusionMultiThresholdRowProps['classNames'];
        EventTypeUnsupportedRow?: EventTypeUnsupportedRowProps['classNames'];
        EventTypeWalletBalanceRow?: EventTypeWalletBalanceRowProps['classNames'];
        EventTypeXMTPRow?: EventTypeXMPTRowProps['classNames'];
        EventTypeFusionToggleRow?: EventTypeFusionRowProps['classNames'];
        EventTypeFusionHealthCheckRow?: EventTypeFusionHealthCheckRowProps['classNames'];
    }>;
    inputs: Record<string, unknown>;
}>;
declare const AlertsPanel: React__default.FC<AlertsPanelProps>;

declare type UserInfoSection = {
    container: string;
    label: string;
    confirmationLink: string;
    confirmationLabel: string;
    errorMessageContainer: string;
    errorMessage: string;
    tooltipContent: string;
};
declare type UserInfoPanelProps = {
    classNames?: DeepPartialReadonly<{
        alertHistory: string;
        container: string;
        email?: UserInfoSection;
        telegram?: UserInfoSection;
        discord?: UserInfoSection;
        sms?: UserInfoSection;
        EditButton: string;
        myWallet?: UserInfoSection;
    }>;
    contactInfo: CardConfigItemV1['contactInfo'];
    confirmationLabels?: {
        email?: string;
        telegram?: string;
    };
};
declare const UserInfoPanel: React__default.FC<UserInfoPanelProps>;

declare type PreviewCardProps = Readonly<{
    classNames?: {
        NotifiPreviewCardSeparator?: string;
        NotifiPreviewCardContainer?: string;
        AlertsPanel?: DeepPartialReadonly<AlertsPanelProps['classNames']>;
        backArrowContainer?: string;
        UserInfoPanel?: DeepPartialReadonly<UserInfoPanelProps['classNames']>;
        NotifiPreviewCardTitle?: string;
        NotifiPreviewCardDividerLine?: string;
    };
    data: CardConfigItemV1$1;
    inputDisabled: boolean;
    inputs: Record<string, unknown>;
}>;
declare const PreviewCard: React__default.FC<PreviewCardProps>;

declare type NotifiCardButtonProps = Readonly<{
    classNames?: Readonly<{
        button?: string;
        label?: string;
    }>;
    buttonText: string;
    disabled?: boolean;
    onClick?: () => void;
}>;

declare type VerifyWalletViewProps = Readonly<{
    classNames?: Readonly<{
        NotifiVerifyContainer?: string;
        NotifiInputHeading?: string;
        NotifiCardButtonProps?: NotifiCardButtonProps['classNames'];
    }>;
    buttonText: string;
    data: CardConfigItemV1$1;
    inputs: Record<string, unknown>;
}>;

declare type SubscriptionCardV1Props = Readonly<{
    copy?: DeepPartialReadonly<{
        EditCard: EditCardViewProps['copy'];
        AlertHistory: AlertHistoryViewProps['copy'];
        expiredHeader: string;
        manageAlertsHeader: string;
        signUpHeader: string;
        editHeader: string;
        verifyWalletsHeader: string;
        historyHeader: string;
        detailHeader: string;
    }>;
    classNames?: DeepPartialReadonly<{
        alertContainer: string;
        AlertHistoryView: AlertHistoryViewProps['classNames'];
        AlertDetailsCard: AlertDetailsProps['classNames'];
        PreviewCard: PreviewCardProps['classNames'];
        HistoryCard?: AlertHistoryViewProps['classNames'];
        EditCard: EditCardViewProps['classNames'];
        ExpiredTokenView: ExpiredTokenViewCardProps['classNames'];
        VerifyWalletView: VerifyWalletViewProps['classNames'];
        NotifiAlertBox: NotifiAlertBoxProps['classNames'];
        ErrorStateCard: string;
        ConfigDestinationModal: ConfigDestinationModalProps['classNames'];
        signupBanner: SignupBannerProps['classNames'];
        ConfigAlertModal: ConfigAlertModalProps['classNames'];
        dividerLine: string;
        verifyBanner: VerifyBannerProps['classNames'];
    }>;
    inputDisabled: boolean;
    data: CardConfigItemV1$1;
    inputs: Record<string, unknown>;
    inputLabels?: NotifiInputFieldsText;
    inputSeparators?: NotifiInputSeparators;
    onClose?: () => void;
}>;
declare const SubscriptionCardV1: React__default.FC<SubscriptionCardV1Props>;

declare type FetchedStateCardProps = Readonly<{
    classNames?: Readonly<{
        SubscriptionCardV1?: SubscriptionCardV1Props['classNames'];
    }>;
    copy?: Readonly<{
        SubscriptionCardV1?: SubscriptionCardV1Props['copy'];
    }>;
    card: FetchedState;
    inputDisabled: boolean;
    inputs: Record<string, unknown>;
    inputLabels?: NotifiInputFieldsText;
    inputSeparators?: NotifiInputSeparators;
    onClose?: () => void;
}>;
declare const FetchedStateCard: React__default.FC<FetchedStateCardProps>;

declare type ResolveFunc<T> = (name: string, valueOrRef: ValueOrRef<T>, inputs: Record<string, unknown>) => T;
declare const resolveStringRef: ResolveFunc<string>;
declare const resolveStringArrayRef: ResolveFunc<readonly string[]>;

declare const SubscriptionCardUnsupported: React__default.FC;

declare type AlertDetailsContents = {
    topContent: string;
    bottomContent: string;
    bottomContentHtml?: string;
    otherContent?: string;
};
declare const validateIsSupported: (entry?: NotificationHistoryEntry) => boolean;
declare const getAlertNotificationViewBaseProps: (notification: NotificationHistoryEntry) => AlertNotificationViewProps;
declare const getAlertDetailsContents: (notification: NotificationHistoryEntry) => AlertDetailsContents;

declare const subscribeAlertByFrontendClient: (frontendClient: NotifiFrontendClient, alertDetail: Readonly<{
    eventType: EventTypeItem$1;
    inputs: Record<string, unknown>;
}>) => Promise<SubscriptionData>;
declare const unsubscribeAlertByFrontendClient: (frontendClient: NotifiFrontendClient, alertDetail: Readonly<{
    eventType: EventTypeItem$1;
    inputs: Record<string, unknown>;
}>) => Promise<void>;
declare const subscribeAlertsByFrontendClient: (frontendClient: NotifiFrontendClient, eventTypes: EventTypeConfig$1, inputs: Record<string, unknown>) => Promise<SubscriptionData>;

/**
 * @description Returns an array of the object's keys with the correct type.
 * @example
 * const destinations: Record<FormField, string> = { email: 'email', phoneNumber: 'phoneNumber' };
 * const keys = objectKeys(destinations); // type of Keys is FormField[] instead of string[] (which is the default type of Object.keys)
 */
declare const objectKeys: <T extends Record<keyof T, unknown>>(object: T) => (keyof T)[];

declare type NotifiEmailInputProps = Readonly<{
    classNames?: DeepPartialReadonly<{
        container: string;
        input: string;
        label: string;
        errorMessage: string;
        button: string;
    }>;
    copy?: DeepPartialReadonly<{
        placeholder: string;
        label: string;
    }>;
    disabled: boolean;
    intercomEmailInputStyle?: string;
    intercomEmailInputContainerStyle?: string;
    intercomView?: boolean;
    hasChatAlert?: boolean;
}>;
declare const NotifiEmailInput: React__default.FC<NotifiEmailInputProps>;

declare type Props = React__default.SVGProps<SVGSVGElement>;
declare const NotifiLogo: React__default.FC<Props>;

declare type ChatMessageDateProps = Readonly<{
    classNames?: Readonly<{
        container: string;
        content: string;
        body: string;
    }>;
    createdDate: string;
    isStartDate?: boolean;
}>;
declare const ChatMessageDate: React__default.FC<ChatMessageDateProps>;

declare type ChatWindowIntroSectionProps = Readonly<{
    classNames?: Readonly<{
        container: string;
        content: string;
        date: ChatMessageDateProps['classNames'];
    }>;
    startDate: string;
    inVirtualContainerStyle?: string;
    chatIntroQuestion: string;
}>;
declare const ChatWindowIntroSection: React__default.FC<React__default.PropsWithChildren<ChatWindowIntroSectionProps>>;

declare type MessageDirection = 'INCOMING' | 'OUTGOING';
declare type MessagesBlockFeedEntry = Readonly<{
    type: 'MESSAGES_BLOCK';
    direction: MessageDirection;
    messages: ConversationMessageFragment[];
}>;
declare type FeedEntry = {
    id: string;
    timestamp: string;
    isSameDate: boolean | undefined;
} & MessagesBlockFeedEntry;

declare type MessageGroupProps = Readonly<{
    classNames?: Readonly<{
        messageGroupContainer: string;
        messageContainer: string;
        messageBody: string;
        timeStamp: string;
        sender: string;
    }>;
    messages: ConversationMessageFragment[];
    direction: string;
}>;
declare const MessageGroup: React__default.FC<MessageGroupProps>;

declare type MessageListProps = Readonly<{
    classNames?: Readonly<{
        container: string;
        messageGroup: MessageGroupProps['classNames'];
        avatar: string;
    }>;
    feed: FeedEntry;
}>;
declare const MessageList: React__default.FC<MessageListProps>;

declare type SendMessageSectionProps = Readonly<{
    classNames?: Readonly<{
        container: string;
        textarea: string;
        button: string;
    }>;
    sendConversationMessages: (message: string) => void;
}>;
declare const SendMessageSection: React__default.FC<SendMessageSectionProps>;

declare type ChatMessageSectionProps = Readonly<{
    classNames?: Readonly<{
        chatWindowIntro: ChatWindowIntroSectionProps['classNames'];
        messageList: MessageListProps['classNames'];
        date: ChatMessageDateProps['classNames'];
        sendMessageSection: SendMessageSectionProps['classNames'];
    }>;
    chatIntroQuestion: string;
}>;
declare const ChatMessageSection: React__default.FC<ChatMessageSectionProps>;

declare type ChatWindowHeaderProps = Readonly<{
    classNames?: Readonly<{
        container: string;
        content: string;
    }>;
    chatWindowHeaderContent: string;
}>;
declare const ChatWindowHeader: React__default.FC<ChatWindowHeaderProps>;

declare type NotifiIntercomChatWindowContainerProps = Readonly<{
    classNames?: Readonly<{
        container: string;
        header?: ChatWindowHeaderProps['classNames'];
        chatMessageSection?: ChatMessageSectionProps['classNames'];
        sendMessageSection?: SendMessageSectionProps['classNames'];
    }>;
    chatIntroQuestion: string;
    chatWindowHeaderContent: string;
}>;
declare const NotifiIntercomChatWindowContainer: React__default.FC<React__default.PropsWithChildren<NotifiIntercomChatWindowContainerProps>>;

declare type NotifiStartChatButtonProps = Readonly<{
    classNames?: Readonly<{
        button?: string;
        label?: string;
    }>;
    disabled: boolean;
    onClick: () => void;
}>;
declare const NotifiStartChatButton: React__default.FC<NotifiStartChatButtonProps>;

declare type SettingHeaderProps = Readonly<{
    classNames?: Readonly<{
        container: string;
        content: string;
    }>;
}>;
declare const SettingHeader: React__default.FC<SettingHeaderProps>;

declare type IntercomCardProps = Readonly<{
    classNames?: Readonly<{
        container?: string;
        title?: string;
        subtitle1?: string;
        subtitle2?: string;
        NotifiStartChatButton?: NotifiStartChatButtonProps['classNames'];
        NotifiIntercomChatWindowContainer?: NotifiIntercomChatWindowContainerProps['classNames'];
        NotifiIntercomSettingHeader: SettingHeaderProps['classNames'];
        errorMessage: string;
    }>;
    inputLabels?: NotifiInputFieldsText;
    inputs?: Record<string, string | undefined>;
    inputSeparators?: NotifiInputSeparators;
    data: IntercomCardConfigItemV1;
}>;
declare const IntercomCard: React__default.FC<React__default.PropsWithChildren<IntercomCardProps>>;

declare type NotifiIntercomCardProps = Readonly<{
    classNames?: Readonly<{
        container?: string;
        title?: string;
        subtitle1?: string;
        subtitle2?: string;
        ErrorStateCard?: ErrorStateCardProps['classNames'];
        LoadingStateCard?: LoadingStateCardProps['classNames'];
        NotifiStartChatButton?: NotifiStartChatButtonProps['classNames'];
        NotifiIntercomChatWindowContainer?: NotifiIntercomChatWindowContainerProps['classNames'];
        NotifiIntercomSettingHeader: SettingHeaderProps['classNames'];
        errorMessage: string;
    }>;
    inputLabels?: NotifiInputFieldsText;
    darkMode?: boolean;
    inputs?: Record<string, string | undefined>;
    inputSeparators?: NotifiInputSeparators;
    cardId: string;
}>;
declare const NotifiIntercomCard: React__default.FC<React__default.PropsWithChildren<NotifiIntercomCardProps>>;

declare const NotifiIntercomCardContainer: React__default.FC<React__default.PropsWithChildren<NotifiIntercomCardProps>>;

declare type NotifiIntercomFTUNotificationTargetSectionProps = Readonly<{
    classNames?: Readonly<{
        NotifiEmailInput?: NotifiEmailInputProps['classNames'];
        NotifiSmsInput?: NotifiSmsInputProps['classNames'];
        NotifiTelegramInput?: NotifiTelegramInputProps['classNames'];
        container: string;
        label: string;
        toggle: NotifiToggleProps['classNames'];
    }>;
    data: IntercomCardConfigItemV1;
    inputs: Record<string, unknown>;
    inputTextFields?: NotifiInputFieldsText;
    inputSeparators?: NotifiInputSeparators;
}>;
declare const NotifiIntercomFTUNotificationTargetSection: React__default.FC<NotifiIntercomFTUNotificationTargetSectionProps>;

export { AcalaParams, AlertConfiguration, AlertHistoryView, AlertHistoryViewProps, AlertHistoryViewState, AlertListPreview, AlertListPreviewProps, AlertsPanel, AlertsPanelProps, AptosParams, ArbitrumParams, AvalancheParams, BaseParams, BinanceParams, BroadcastEventTypeItem, CardConfigItemV1, ChatMessageDate, ChatMessageDateProps, ChatMessageSection, ChatMessageSectionProps, ChatWindowHeader, ChatWindowHeaderProps, ChatWindowIntroSection, ChatWindowIntroSectionProps, CheckRatio, ClientData, ContactInfo, ContactInfoConfig, CountryCode, CustomHealthCheckItem, CustomToggleTypeItem, CustomTopicTypeItem, CustomTypeBase, Data, DeepPartialReadonly, DemoPreview, DestinationError, DestinationErrorMessageField, DestinationErrorMessages, DestinationErrors, DestinationInputs, DirectPushEventTypeItem, DiscordContactInfo, EditCardView, EditCardViewProps, EditFormType, EditInfoViewState, EmailContactInfo, ErrorViewState, EthereumParams, EventTypeBroadcastRow, EventTypeBroadcastRowProps, EventTypeConfig, EventTypeCustomHealthCheckRow, EventTypeCustomHealthCheckRowProps, EventTypeCustomToggleRow, EventTypeCustomToggleRowProps, EventTypeDirectPushRow, EventTypeDirectPushRowProps, EventTypeFusionMultiThresholdRow, EventTypeFusionMultiThresholdRowProps, EventTypeHealthCheckRow, EventTypeHealthCheckRowProps, EventTypeItem, EventTypeLabelRow, EventTypeLabelRowProps, EventTypePriceChangeRow, EventTypePriceChangeRowProps, EventTypeTradingPairsRow, EventTypeTradingPairsRowProps, EventTypeUnsupportedRow, EventTypeUnsupportedRowProps, EventTypeWalletBalanceRow, EventTypeWalletBalanceRowProps, ExpiredTokenViewState, FetchedCardViewState, FetchedState, FetchedStateCard, FetchedStateCardProps, FormErrorMessages, FormField, FrontendClientStatus, FtuStage, FusionEventTypeItem, FusionHealthCheckEventTypeItem, FusionMultiThresholdAlertRow, FusionMultiThresholdAlertRowProps, FusionMultiThresholdEventTypeItem, FusionMultiThresholdSettingsRow, FusionMultiThresholdSettingsRowProps, FusionToggleEventTypeItem, FusionTypeBase, HardwareLoginPlugin, HealthCheckEventTypeItem, InjectiveParams, InputFields, InputFieldsProps, InputItem, InputType, InputsConfig, InstantSubscribe, IntercomCard, IntercomCardProps, LabelEventTypeItem, LoadingState, MessageGroup, MessageGroupProps, MessageList, MessageListProps, MultiWalletParams, MultipleSourceAlertConfiguration, NearParams, NibiruParams, NotifiClientContextData, NotifiClientContextProvider, NotifiContext, NotifiDemoPreviewContextData, NotifiDemoPreviewContextProvider, NotifiEmailInput, NotifiEmailInputProps, NotifiFooter, NotifiFooterProps, NotifiFormData, NotifiFormProvider, NotifiInputFieldsText, NotifiInputSeparators, NotifiIntercomCard, NotifiIntercomCardContainer, NotifiIntercomCardProps, NotifiIntercomChatWindowContainer, NotifiIntercomChatWindowContainerProps, NotifiIntercomFTUNotificationTargetSection, NotifiIntercomFTUNotificationTargetSectionProps, NotifiLogo, NotifiParams, NotifiSmsInput, NotifiSmsInputProps, NotifiStartChatButton, NotifiStartChatButtonProps, NotifiSubscribeButton, NotifiSubscribeButtonProps, NotifiSubscriptionCard, NotifiSubscriptionCardProps, NotifiSubscriptionContextProvider, NotifiSubscriptionData, NotifiTelegramInput, NotifiTelegramInputProps, NotifiToggle, NotifiToggleProps, NotifiTooltip, NotifiTooltipProps, NotificationHistoryEntry, NumberTypeSelect, OptimismParams, OsmosisParams, PolygonParams, PreviewCard, PreviewCardProps, PreviewViewState, PriceChangeDataSource, PriceChangeEventTypeItem, Props, RecoverableError, SendMessageSection, SendMessageSectionProps, SettingHeader, SettingHeaderProps, SignUpViewState, SingleSourceAlertConfiguration, SmsContactInfo, SolanaParams, SubscriptionCardState, SubscriptionCardUnsupported, SubscriptionCardV1, SubscriptionCardV1Props, SubscriptionData, SuiParams, TelegramContactInfo, TitleSubtitleConfig, TitleSubtitleConfigActive, TitleSubtitleConfigInactive, TradingPairAlertRow, TradingPairAlertRowProps, TradingPairEventTypeItem, TradingPairSettingsRow, TradingPairSettingsRowProps, USER_INTERFACE_TYPE, UnrecoverableError, UserInfoPanel, UserInfoPanelProps, UserInfoSection, UserInterfaceType, ValueOrRef, VerifyOnboardingViewState, VerifyWalletViewState, WalletBalanceEventTypeItem, WebhookContactInfo, WebhookHeaders, XMTPToggleConfiguration, XMTPTopic, XMTPTopicTypeItem, ZksyncParams, broadcastMessageConfiguration, chatConfiguration, createConfigurations, customThresholdConfiguration, customToggleConfiguration, defaultDemoConfigV1, directMessageConfiguration, fusionHealthCheckConfiguration, fusionToggleConfiguration, getAlertDetailsContents, getAlertNotificationViewBaseProps, healthThresholdConfiguration, hedgeProtocolConfiguration, objectKeys, priceChangeConfiguration, resolveStringArrayRef, resolveStringRef, subscribeAlertByFrontendClient, subscribeAlertsByFrontendClient, tradingPairConfiguration, unsubscribeAlertByFrontendClient, useFetchedCardState, useFrontendClientLogin, useNotifiClientContext, useNotifiDemoPreviewContext, useNotifiForm, useNotifiSubscribe, useNotifiSubscriptionContext, useSubscriptionCard, useUnreadState, validateIsSupported, walletBalanceConfiguration };
