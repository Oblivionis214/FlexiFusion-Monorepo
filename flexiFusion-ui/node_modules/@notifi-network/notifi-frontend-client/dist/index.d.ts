import { Types, Operations, NotifiService } from '@notifi-network/notifi-graphql';

declare type NotifiEnvironment = 'Production' | 'Staging' | 'Development' | 'Local';
declare type NotifiEnvironmentConfiguration = Readonly<{
    env: NotifiEnvironment;
    tenantId: string;
    storageOption?: Readonly<{
        driverType?: 'LocalForage' | 'InMemory';
    }>;
}>;
declare type NotifiConfigWithPublicKey = Readonly<{
    walletBlockchain: 'ETHEREUM' | 'POLYGON' | 'ARBITRUM' | 'AVALANCHE' | 'BINANCE' | 'OPTIMISM' | 'SOLANA' | 'ZKSYNC' | 'BASE';
    walletPublicKey: string;
}> & NotifiEnvironmentConfiguration;
declare type NotifiConfigWithPublicKeyAndAddress = Readonly<{
    walletBlockchain: 'SUI' | 'NEAR' | 'INJECTIVE' | 'APTOS' | 'ACALA' | 'OSMOSIS' | 'NIBIRU';
    authenticationKey: string;
    accountAddress: string;
}> & NotifiEnvironmentConfiguration;
declare type NotifiFrontendConfiguration = NotifiConfigWithPublicKey | NotifiConfigWithPublicKeyAndAddress;
declare type ConfigFactoryInput = ConfigFactoryInputPublicKeyAndAddress | ConfigFactoryInputPublicKey;
declare const checkIsConfigWithPublicKeyAndAddress: (config: NotifiFrontendConfiguration) => config is NotifiConfigWithPublicKeyAndAddress;
declare type ConfigFactoryInputPublicKeyAndAddress = {
    account: Readonly<{
        address: string;
        publicKey: string;
    }>;
    tenantId: string;
    env: NotifiEnvironment;
    walletBlockchain: NotifiConfigWithPublicKeyAndAddress['walletBlockchain'];
    storageOption?: NotifiEnvironmentConfiguration['storageOption'];
};
declare type ConfigFactoryInputPublicKey = {
    account: Readonly<{
        publicKey: string;
    }>;
    tenantId: string;
    env: NotifiEnvironment;
    walletBlockchain: NotifiConfigWithPublicKey['walletBlockchain'];
    storageOption?: NotifiEnvironmentConfiguration['storageOption'];
};
declare type FrontendClientConfigFactory<T extends NotifiFrontendConfiguration> = (args: T extends NotifiConfigWithPublicKeyAndAddress ? ConfigFactoryInputPublicKeyAndAddress : ConfigFactoryInputPublicKey) => NotifiFrontendConfiguration;
declare const newFrontendConfig: (config: ConfigFactoryInput) => NotifiFrontendConfiguration;
declare const envUrl: (env: NotifiEnvironment) => string;

declare const notNullOrEmpty: <T>(item: T | null | undefined) => item is T;

declare type AlertFrequency = 'ALWAYS' | 'SINGLE' | 'QUARTER_HOUR' | 'HOURLY' | 'DAILY' | 'THREE_MINUTES';
declare type ValueItemConfig = Readonly<{
    key: string;
    op: 'lt' | 'lte' | 'eq' | 'gt' | 'gte';
    value: string;
}>;
declare type ThresholdDirection = 'above' | 'below';
declare type FilterOptions = Partial<{
    alertFrequency: AlertFrequency;
    directMessageType: string;
    threshold: number;
    delayProcessingUntil: string;
    thresholdDirection: ThresholdDirection;
    values: Readonly<{
        and: ReadonlyArray<ValueItemConfig>;
    } | {
        or: ReadonlyArray<ValueItemConfig>;
    }>;
    tradingPair: string;
}>;

declare type ValueOrRef<ValueType> = Readonly<{
    type: 'ref';
    ref: string | null;
}> | Readonly<{
    type: 'value';
    value: ValueType;
}>;
declare type DirectPushEventTypeItem = Readonly<{
    type: 'directPush';
    name: string;
    directPushId: ValueOrRef<string>;
    tooltipContent?: string;
    optOutAtSignup?: boolean;
}>;
declare type FusionTypeBase = {
    name: string;
    type: 'fusion' | 'fusionToggle';
    fusionEventId: ValueOrRef<string>;
    sourceAddress: ValueOrRef<string>;
    tooltipContent?: string;
    maintainSourceGroup?: boolean;
    alertFrequency?: AlertFrequency;
    optOutAtSignup?: boolean;
    displayNameOverride?: string;
};
declare type FusionToggleEventTypeItem = FusionTypeBase & Readonly<{
    selectedUIType: 'TOGGLE';
}>;
declare type FusionHealthCheckEventTypeItem = FusionTypeBase & Readonly<{
    selectedUIType: 'HEALTH_CHECK';
    healthCheckSubtitle: string;
    numberType: NumberTypeSelect;
    checkRatios: CheckRatio[];
    validInputRange?: ValidInputRange;
}>;
declare type ValidInputRange = {
    max: number;
    min: number;
};
declare type FusionMultiThreshholdEventTypeItem = FusionTypeBase & Readonly<{
    selectedUIType: 'MULTI_THRESHOLD';
    numberType: NumberTypeSelect;
    subtitle?: string;
    addThreshholdTitle?: string;
}>;
declare type FusionEventTypeItem = FusionToggleEventTypeItem | FusionHealthCheckEventTypeItem | FusionMultiThreshholdEventTypeItem;
declare type BroadcastEventTypeItem = Readonly<{
    type: 'broadcast';
    name: string;
    broadcastId: ValueOrRef<string>;
    tooltipContent?: string;
    optOutAtSignup?: boolean;
    displayNameOverride?: string;
}>;
declare type HealthCheckEventTypeItem = Readonly<{
    type: 'healthCheck';
    name: string;
    checkRatios: ValueOrRef<CheckRatio[]>;
    alertFrequency: AlertFrequency;
    tooltipContent?: string;
    optOutAtSignup?: boolean;
}>;
declare type LabelEventTypeItem = Readonly<{
    type: 'label';
    name: string;
    tooltipContent?: string;
    optOutAtSignup?: boolean;
}>;
declare type TradingPairEventTypeItem = Readonly<{
    type: 'tradingPair';
    name: string;
    tooltipContent?: string;
    tradingPairs: ValueOrRef<ReadonlyArray<string>>;
    optOutAtSignup?: boolean;
}>;
declare type PriceChangeDataSource = 'coingecko';
declare type PriceChangeEventTypeItem = Readonly<{
    type: 'priceChange';
    name: string;
    tokenIds: ReadonlyArray<string>;
    dataSource: PriceChangeDataSource;
    tooltipContent: string;
    optOutAtSignup?: boolean;
}>;
declare type WalletBalanceEventTypeItem = Readonly<{
    type: 'walletBalance';
    name: string;
    tooltipContent?: string;
    optOutAtSignup?: boolean;
}>;
declare type CustomTypeBase = {
    type: 'custom';
    name: string;
    tooltipContent: string;
    sourceType: Types.SourceType;
    filterType: string;
    sourceAddress: ValueOrRef<string>;
    optOutAtSignup?: boolean;
};
declare type CustomToggleTypeItem = Readonly<{
    filterOptions: FilterOptions;
    selectedUIType: 'TOGGLE';
    optOutAtSignup?: boolean;
}>;
declare type NumberTypeSelect = 'percentage' | 'integer' | 'price';
declare type CustomHealthCheckItem = Readonly<{
    selectedUIType: 'HEALTH_CHECK';
    healthCheckSubtitle: string;
    numberType: NumberTypeSelect;
    alertFrequency: AlertFrequency;
    checkRatios: CheckRatio[];
    optOutAtSignup?: boolean;
}>;
declare type RatiosBelow = Readonly<{
    type: 'below';
    ratio: number;
}>;
declare type RatiosAbove = Readonly<{
    type: 'above';
    ratio: number;
}>;
declare type CheckRatio = RatiosBelow | RatiosAbove;
declare type CustomTopicTypeItem = CustomTypeBase & (CustomToggleTypeItem | CustomHealthCheckItem);
declare type XMTPTopicTypeItem = {
    type: 'XMTP';
    name: string;
    tooltipContent: string;
    sourceType?: Types.SourceType;
    filterType: string;
    XMTPTopics: ValueOrRef<ReadonlyArray<string>>;
    optOutAtSignup?: boolean;
};
declare type CreateSupportConversationEventTypeItem = {
    type: 'createSupportConversation';
    name: string;
    sourceType: Types.SourceType;
    filterType: string;
    alertFrequency: AlertFrequency;
    optOutAtSignup?: boolean;
};
declare type EventTypeItem = DirectPushEventTypeItem | BroadcastEventTypeItem | HealthCheckEventTypeItem | TradingPairEventTypeItem | LabelEventTypeItem | PriceChangeEventTypeItem | CustomTopicTypeItem | FusionEventTypeItem | WalletBalanceEventTypeItem | XMTPTopicTypeItem | CreateSupportConversationEventTypeItem;
declare type EventTypeConfig = ReadonlyArray<EventTypeItem>;
declare type InputType = 'WebhookUrlInput' | 'WebhookHeadersInput' | 'DirectPushIdInput' | 'BroadcastIdInput';
declare type InputItem = Readonly<{
    name: string;
    type: InputType;
}>;
declare type InputsConfig = ReadonlyArray<InputItem>;
declare type ContactInfo = Readonly<{
    active: boolean;
}>;
declare type EmailContactInfo = ContactInfo;
declare type DiscordContactInfo = ContactInfo;
declare type CountryCode = string;
declare type SmsContactInfo = ContactInfo & Readonly<{
    supportedCountryCodes: ReadonlyArray<CountryCode>;
}>;
declare type TelegramContactInfo = ContactInfo;
declare type WebhookHeaders = Readonly<Record<string, string>>;
declare type WebhookContactInfo = ContactInfo & Readonly<{
    url: ValueOrRef<string>;
    headers: ValueOrRef<WebhookHeaders>;
}>;
declare type ContactInfoConfig = Readonly<{
    email: EmailContactInfo;
    sms: SmsContactInfo;
    telegram: TelegramContactInfo;
    webhook: WebhookContactInfo;
    discord: DiscordContactInfo;
}>;
declare type CardConfigItemV1 = Readonly<{
    version: 'v1';
    id: string | null;
    name: string;
    eventTypes: EventTypeConfig;
    inputs: InputsConfig;
    contactInfo: ContactInfoConfig;
    isContactInfoRequired?: boolean;
    titles?: TitleSubtitleConfig;
}>;
declare type TitleSubtitleConfigInactive = Readonly<{
    active: false;
}>;
declare type TitleSubtitleConfigActive = Readonly<{
    active: true;
    editView: string;
    previewView: string;
    historyView: string;
    signupView: string;
    expiredView: string;
    alertDetailsView: string;
    verifyWalletsView: string;
}>;
declare type TitleSubtitleConfig = TitleSubtitleConfigActive | TitleSubtitleConfigInactive;

declare type LabelItemConfigs<Config> = Readonly<{
    [K in LabelType]: Config;
}>;
declare const LABEL_TYPE_MENU_LABELS: LabelItemConfigs<string>;
declare type LabelType = 'ChatCompanyName' | 'ChatFTUTitle' | 'ChatFTUDescription' | 'ChatFTUSubTitle' | 'ChatBannerTitle' | 'ChatIntroQuestion';
declare type LabelItem = {
    name: string | null;
    type: LabelType;
    label: keyof typeof LABEL_TYPE_MENU_LABELS;
};
declare type LabelsConfig = Array<LabelItem>;
declare type IntercomCardConfigItemV1 = Readonly<{
    version: 'IntercomV1';
    id: string | null;
    name: string;
    labels: LabelsConfig;
    contactInfo: ContactInfoConfig;
}>;

declare const packFilterOptions: (clientOptions: Readonly<FilterOptions> | null) => string;

declare const normalizeHexString: (input: string) => string;
declare type TradingPairInputs = {
    pair: string;
    direction: 'below' | 'above';
    price: number;
};
declare type HealthCheckEventInputsWithIndex = {
    index: number;
    [key: string]: unknown;
};
declare type HealthCheckEventInputsWithCustomPercentage = {
    thresholdDirection: ThresholdDirection;
    customPercentage: number;
    [key: string]: unknown;
};
declare type HealthCheckInputs = HealthCheckEventInputsWithIndex | HealthCheckEventInputsWithCustomPercentage;
declare const ensureSourceAndFilters: (service: Operations.CreateSourceService & Operations.GetSourcesService & Operations.GetSourceGroupsService & Operations.CreateSourceGroupService & Operations.UpdateSourceGroupService & Operations.GetConnectedWalletsService, eventType: EventTypeItem, inputs: Record<string, unknown>) => Promise<Readonly<{
    sourceGroup: Types.SourceGroupFragmentFragment;
    filter: Types.FilterFragmentFragment;
    filterOptions: FilterOptions;
}>>;

declare type CreateFunc<CreateService, T> = (service: CreateService, value: string) => Promise<T>;
declare type FetchFunc<GetService, T> = (service: GetService) => Promise<Array<T | undefined> | undefined>;
declare type IdentifyFunc<T> = (arg: T | undefined) => string | undefined;
declare type ValueTransformFunc = (value: string) => string;
declare const ensureTarget: <CreateService, GetService, T extends Readonly<{
    id: string;
}>>(create: CreateFunc<CreateService, T>, fetch: FetchFunc<GetService, T>, identify: IdentifyFunc<T>, valueTransform?: ValueTransformFunc) => (service: CreateService & GetService, value: string | undefined) => Promise<string | undefined>;
declare const ensureEmail: (service: Readonly<{
    createEmailTarget: (variables: Types.Exact<{
        name: string;
        value: string;
    }>) => Promise<Types.CreateEmailTargetMutation>;
}> & Readonly<{
    getEmailTargets: (variables: Types.Exact<{
        [key: string]: never;
    }>) => Promise<Types.GetEmailTargetsQuery>;
}>, value: string | undefined) => Promise<string | undefined>;
declare const ensureSms: (service: Readonly<{
    createSmsTarget: (variables: Types.Exact<{
        name: string;
        value: string;
    }>) => Promise<Types.CreateSmsTargetMutation>;
}> & Readonly<{
    getSmsTargets: (variables: Types.Exact<{
        [key: string]: never;
    }>) => Promise<Types.GetSmsTargetsQuery>;
}>, value: string | undefined) => Promise<string | undefined>;
declare const ensureTelegram: (service: Readonly<{
    createTelegramTarget: (variables: Types.Exact<{
        name: string;
        value: string;
    }>) => Promise<Types.CreateTelegramTargetMutation>;
}> & Readonly<{
    getTelegramTargets: (variables: Types.Exact<{
        [key: string]: never;
    }>) => Promise<Types.GetTelegramTargetsQuery>;
}>, value: string | undefined) => Promise<string | undefined>;
declare const ensureDiscord: (service: Readonly<{
    createDiscordTarget: (variables: Types.Exact<{
        name: string;
        value: string;
    }>) => Promise<Types.CreateDiscordTargetMutation>;
}> & Readonly<{
    getDiscordTargets: (variables: Types.Exact<{
        [key: string]: never;
    }>) => Promise<Types.GetDiscordTargetsQuery>;
}>, value: string | undefined) => Promise<string | undefined>;
declare type EnsureWebhookParams$1 = Omit<Types.CreateWebhookTargetMutationVariables, 'name'>;
declare const ensureWebhook: (service: Operations.CreateWebhookTargetService & Operations.GetWebhookTargetsService, params: EnsureWebhookParams$1 | undefined) => Promise<string | undefined>;

declare type StorageDriver = Readonly<{
    get: <T>(key: string) => Promise<T | null>;
    set: <T>(key: string, newValue: T | null) => Promise<void>;
    has: (key: string) => Promise<boolean>;
}>;
declare type GetStorageType<Key extends string, T> = Readonly<{
    [key in `get${Capitalize<Key>}`]: () => Promise<T | null>;
}>;
declare type SetStorageType<Key extends string, T> = Readonly<{
    [key in `set${Capitalize<Key>}`]: (newValue: T | null) => Promise<void>;
}>;
declare type HasStorageType<Key extends string> = Readonly<{
    [key in `has${Capitalize<Key>}`]: () => Promise<boolean>;
}>;
declare type StorageType<Key extends string, T> = GetStorageType<Key, T> & SetStorageType<Key, T> & HasStorageType<Key>;
declare type Authorization = Readonly<{
    token: string;
    expiry: string;
}>;
declare type AuthorizationStorage = StorageType<'authorization', Authorization>;
declare type Roles = ReadonlyArray<string>;
declare type RolesStorage = StorageType<'roles', Roles>;
declare type NotifiStorage = AuthorizationStorage & RolesStorage;
declare class NotifiFrontendStorage implements NotifiStorage {
    private _driver;
    constructor(_driver: StorageDriver);
    getAuthorization(): Promise<Authorization | null>;
    setAuthorization(newValue: Authorization | null): Promise<void>;
    hasAuthorization(): Promise<boolean>;
    getRoles(): Promise<Roles | null>;
    setRoles(newValue: Roles | null): Promise<void>;
    hasRoles(): Promise<boolean>;
}

declare const createInMemoryStorageDriver: (config: NotifiFrontendConfiguration) => StorageDriver;

declare const createLocalForageStorageDriver: (config: NotifiFrontendConfiguration) => StorageDriver;

declare type SignMessageParams = Readonly<{
    walletBlockchain: 'SOLANA';
    signMessage: Uint8SignMessageFunction;
}> | Readonly<{
    walletBlockchain: 'ETHEREUM' | 'POLYGON' | 'ARBITRUM' | 'AVALANCHE' | 'BINANCE' | 'INJECTIVE' | 'OSMOSIS' | 'NIBIRU' | 'OPTIMISM' | 'ZKSYNC' | 'BASE';
    signMessage: Uint8SignMessageFunction;
}> | Readonly<{
    walletBlockchain: 'APTOS';
    signMessage: AptosSignMessageFunction;
}> | Readonly<{
    walletBlockchain: 'ACALA';
    signMessage: AcalaSignMessageFunction;
}> | Readonly<{
    walletBlockchain: 'NEAR';
    signMessage: Uint8SignMessageFunction;
}> | Readonly<{
    walletBlockchain: 'SUI';
    signMessage: Uint8SignMessageFunction;
}>;
declare type WalletWithSignParams = Readonly<{
    displayName?: string;
}> & WalletWithSignMessage;
declare type WalletWithSignMessage = Readonly<{
    walletBlockchain: 'SOLANA';
    walletPublicKey: string;
    signMessage: Uint8SignMessageFunction;
}> | Readonly<{
    walletBlockchain: 'ETHEREUM' | 'POLYGON' | 'ARBITRUM' | 'AVALANCHE' | 'BINANCE' | 'OPTIMISM' | 'ZKSYNC' | 'BASE';
    walletPublicKey: string;
    signMessage: Uint8SignMessageFunction;
}> | Readonly<{
    walletBlockchain: 'APTOS';
    accountAddress: string;
    walletPublicKey: string;
    signMessage: AptosSignMessageFunction;
}> | Readonly<{
    walletBlockchain: 'ACALA';
    accountAddress: string;
    walletPublicKey: string;
    signMessage: AcalaSignMessageFunction;
}> | Readonly<{
    walletBlockchain: 'NEAR';
    accountAddress: string;
    walletPublicKey: string;
    signMessage: Uint8SignMessageFunction;
}> | Readonly<{
    walletBlockchain: 'SUI';
    accountAddress: string;
    walletPublicKey: string;
    signMessage: Uint8SignMessageFunction;
}>;
declare type ConnectWalletParams = Readonly<{
    walletParams: WalletWithSignParams;
    connectWalletConflictResolutionTechnique: Types.ConnectWalletInput['connectWalletConflictResolutionTechnique'];
}>;
declare type Uint8SignMessageFunction = (message: Uint8Array) => Promise<Uint8Array>;
declare type AptosSignMessageFunction = (message: string, nonce: number) => Promise<string>;
declare type hexString = `0x${string}`;
declare type AcalaSignMessageFunction = (acalaAddress: string, message: string) => Promise<hexString>;
declare type CardConfigType = CardConfigItemV1 | IntercomCardConfigItemV1;
declare type BeginLoginProps = Omit<Types.BeginLogInByTransactionInput, 'dappAddress'>;
declare type CompleteLoginProps = Omit<Types.CompleteLogInByTransactionInput, 'dappAddress' | 'randomUuid'>;
declare type EnsureWebhookParams = Omit<Types.CreateWebhookTargetMutationVariables, 'name'>;
declare type FindSubscriptionCardParams = Omit<Types.FindTenantConfigInput, 'tenant'>;
declare const SIGNING_MESSAGE = "Sign in with Notifi \n\n    No password needed or gas is needed. \n\n    Clicking \u201CApprove\u201D only means you have proved this wallet is owned by you! \n\n    This request will not trigger any transaction or cost any gas fees. \n\n    Use of our website and service is subject to our terms of service and privacy policy. \n \n 'Nonce:' ";
declare type SupportedCardConfigType = CardConfigItemV1;
declare type UserState = Readonly<{
    status: 'loggedOut';
} | {
    status: 'authenticated';
    authorization: Authorization;
    roles: Roles;
} | {
    status: 'expired';
    authorization: Authorization;
}>;
declare class NotifiFrontendClient {
    private _configuration;
    private _service;
    private _storage;
    constructor(_configuration: NotifiFrontendConfiguration, _service: NotifiService, _storage: NotifiStorage);
    private _clientRandomUuid;
    private _userState;
    get userState(): UserState | null;
    initialize(): Promise<UserState>;
    logOut(): Promise<UserState>;
    logIn(signMessageParams: SignMessageParams): Promise<Types.UserFragmentFragment>;
    private _signMessage;
    private _handleLogInResult;
    fetchData(): Promise<Types.FetchDataQuery>;
    beginLoginViaTransaction({ walletBlockchain, walletAddress, }: BeginLoginProps): Promise<Types.BeginLogInByTransactionResult>;
    completeLoginViaTransaction({ walletBlockchain, walletAddress, transactionSignature, }: CompleteLoginProps): Promise<Types.CompleteLogInByTransactionMutation>;
    getTargetGroups(): Promise<ReadonlyArray<Types.TargetGroupFragmentFragment>>;
    ensureTargetGroup({ name, emailAddress, phoneNumber, telegramId, webhook, discordId, }: Readonly<{
        name: string;
        emailAddress?: string;
        phoneNumber?: string;
        telegramId?: string;
        webhook?: EnsureWebhookParams;
        discordId?: string;
    }>): Promise<Types.TargetGroupFragmentFragment>;
    private _updateTargetGroup;
    getSourceGroups(): Promise<ReadonlyArray<Types.SourceGroupFragmentFragment>>;
    getAlerts(): Promise<ReadonlyArray<Types.AlertFragmentFragment>>;
    ensureAlert({ eventType, inputs, targetGroupName, }: Readonly<{
        eventType: EventTypeItem;
        inputs: Record<string, unknown>;
        targetGroupName?: string;
    }>): Promise<Types.AlertFragmentFragment>;
    deleteAlert({ id, }: Readonly<{
        id: string;
    }>): Promise<void>;
    updateWallets(): Promise<Readonly<{
        sourceGroup: Types.SourceGroupFragmentFragment;
        filter: Types.FilterFragmentFragment;
        filterOptions: Partial<{
            alertFrequency: AlertFrequency;
            directMessageType: string;
            threshold: number;
            delayProcessingUntil: string;
            thresholdDirection: ThresholdDirection;
            values: Readonly<{
                and: readonly Readonly<{
                    key: string;
                    op: "lt" | "lte" | "eq" | "gt" | "gte";
                    value: string;
                }>[];
            } | {
                or: readonly Readonly<{
                    key: string;
                    op: "lt" | "lte" | "eq" | "gt" | "gte";
                    value: string;
                }>[];
            }>;
            tradingPair: string;
        }>;
    }>>;
    /**
     *@deprecated
     *@description Use getFusionNotificationHistory instead
     */
    getNotificationHistory(variables: Types.GetNotificationHistoryQueryVariables): Promise<Readonly<{
        pageInfo: Types.PageInfoFragmentFragment;
        nodes: ReadonlyArray<Types.NotificationHistoryEntryFragmentFragment>;
    }>>;
    getUnreadNotificationHistoryCount(): Promise<Types.GetUnreadNotificationHistoryCountQuery['unreadNotificationHistoryCount']>;
    getUserSettings(): Promise<Types.GetUserSettingsQuery['userSettings']>;
    getFusionNotificationHistory(variables: Types.GetFusionNotificationHistoryQueryVariables): Promise<Readonly<Types.GetFusionNotificationHistoryQuery['fusionNotificationHistory']>>;
    fetchSubscriptionCard(variables: FindSubscriptionCardParams): Promise<CardConfigType>;
    copyAuthorization(config: NotifiFrontendConfiguration): Promise<void>;
    sendEmailTargetVerification({ targetId, }: Readonly<{
        targetId: string;
    }>): Promise<string>;
    subscribeWallet(params: ConnectWalletParams): Promise<Types.ConnectWalletMutation>;
    getConversationMessages(input: Types.GetConversationMessagesQueryVariables): Promise<Types.GetConversationMessagesQuery>;
    sendConversationMessages(input: Types.SendConversationMessageMutationVariables): Promise<Types.SendConversationMessageMutation>;
    createSupportConversation(input: Types.CreateSupportConversationMutationVariables): Promise<Types.CreateSupportConversationMutation>;
    createDiscordTarget(input: string): Promise<{
        __typename?: "DiscordTarget" | undefined;
        id: string;
        discordAccountId?: string | undefined;
        discriminator?: string | undefined;
        isConfirmed: boolean;
        username?: string | undefined;
        name?: string | undefined;
        userStatus: Types.DiscordTargetStatus;
        verificationLink?: string | undefined;
        discordServerInviteLink?: string | undefined;
    }>;
    markFusionNotificationHistoryAsRead(input: Types.MarkFusionNotificationHistoryAsReadMutationVariables): Promise<Types.MarkFusionNotificationHistoryAsReadMutation>;
    updateUserSettings(input: Types.UpdateUserSettingsMutationVariables): Promise<Types.UpdateUserSettingsMutation>;
}

declare const newNotifiStorage: (config: NotifiFrontendConfiguration) => NotifiFrontendStorage;
declare const newNotifiService: (config: NotifiFrontendConfiguration) => NotifiService;
declare const newFrontendClient: (args: ConfigFactoryInput) => NotifiFrontendClient;

export { AcalaSignMessageFunction, AlertFrequency, AptosSignMessageFunction, Authorization, AuthorizationStorage, BroadcastEventTypeItem, CardConfigItemV1, CardConfigType, CheckRatio, ConfigFactoryInput, ConfigFactoryInputPublicKey, ConfigFactoryInputPublicKeyAndAddress, ConnectWalletParams, ContactInfo, ContactInfoConfig, CountryCode, CreateFunc, CreateSupportConversationEventTypeItem, CustomHealthCheckItem, CustomToggleTypeItem, CustomTopicTypeItem, CustomTypeBase, DirectPushEventTypeItem, DiscordContactInfo, EmailContactInfo, EnsureWebhookParams$1 as EnsureWebhookParams, EventTypeConfig, EventTypeItem, FetchFunc, FilterOptions, FrontendClientConfigFactory, FusionEventTypeItem, FusionHealthCheckEventTypeItem, FusionMultiThreshholdEventTypeItem, FusionToggleEventTypeItem, FusionTypeBase, GetStorageType, HasStorageType, HealthCheckEventInputsWithCustomPercentage, HealthCheckEventInputsWithIndex, HealthCheckEventTypeItem, HealthCheckInputs, IdentifyFunc, InputItem, InputType, InputsConfig, IntercomCardConfigItemV1, LABEL_TYPE_MENU_LABELS, LabelEventTypeItem, LabelItem, LabelType, LabelsConfig, NotifiConfigWithPublicKey, NotifiConfigWithPublicKeyAndAddress, NotifiEnvironment, NotifiEnvironmentConfiguration, NotifiFrontendClient, NotifiFrontendConfiguration, NotifiFrontendStorage, NotifiStorage, NumberTypeSelect, PriceChangeDataSource, PriceChangeEventTypeItem, Roles, RolesStorage, SIGNING_MESSAGE, SetStorageType, SignMessageParams, SmsContactInfo, StorageDriver, StorageType, SupportedCardConfigType, TelegramContactInfo, ThresholdDirection, TitleSubtitleConfig, TitleSubtitleConfigActive, TitleSubtitleConfigInactive, TradingPairEventTypeItem, TradingPairInputs, Uint8SignMessageFunction, UserState, ValidInputRange, ValueItemConfig, ValueOrRef, ValueTransformFunc, WalletBalanceEventTypeItem, WalletWithSignMessage, WalletWithSignParams, WebhookContactInfo, WebhookHeaders, XMTPTopicTypeItem, checkIsConfigWithPublicKeyAndAddress, createInMemoryStorageDriver, createLocalForageStorageDriver, ensureDiscord, ensureEmail, ensureSms, ensureSourceAndFilters, ensureTarget, ensureTelegram, ensureWebhook, envUrl, newFrontendClient, newFrontendConfig, newNotifiService, newNotifiStorage, normalizeHexString, notNullOrEmpty, packFilterOptions };
