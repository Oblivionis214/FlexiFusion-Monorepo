var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

// lib/configuration/NotifiFrontendConfiguration.ts
var checkIsConfigWithPublicKeyAndAddress = (config) => {
  return "accountAddress" in config;
};
var configFactoryPublicKey = (args) => {
  return {
    tenantId: args.tenantId,
    env: args.env,
    walletBlockchain: args.walletBlockchain,
    walletPublicKey: args.account.publicKey,
    storageOption: args.storageOption
  };
};
var configFactoryPublicKeyAndAddress = (args) => {
  return {
    tenantId: args.tenantId,
    env: args.env,
    walletBlockchain: args.walletBlockchain,
    authenticationKey: args.account.publicKey,
    accountAddress: args.account.address,
    storageOption: args.storageOption
  };
};
var validateConfigInput = (config) => {
  return "address" in config.account;
};
var newFrontendConfig = (config) => {
  return validateConfigInput(config) ? configFactoryPublicKeyAndAddress(config) : configFactoryPublicKey(config);
};
var envUrl = (env) => {
  switch (env) {
    case "Development":
      return "https://api.dev.notifi.network/gql";
    case "Local":
      return "https://localhost:5001/gql";
    case "Production":
      return "https://api.notifi.network/gql";
    case "Staging":
      return "https://api.stg.notifi.network/gql";
  }
};

// lib/utils/notNullOrEmpty.ts
var notNullOrEmpty = (item) => {
  return item !== void 0 && item !== null;
};

// lib/utils/packFilterOptions.ts
var packFilterOptions = (clientOptions) => {
  if (clientOptions === null) {
    return "{}";
  }
  return JSON.stringify(clientOptions);
};

// lib/utils/areIdsEqual.ts
var areIdsEqual = (ids, items) => {
  const idSet = new Set(ids);
  return items.length === idSet.size && items.every((it) => it !== void 0 && idSet.has(it.id));
};

// lib/utils/resolveRef.ts
var createRefResolver = (validator) => {
  return (name, valueOrRef, inputs) => {
    if (valueOrRef.type === "value") {
      return valueOrRef.value;
    } else {
      if (valueOrRef.ref === null) {
        throw new Error(`Invalid configuration: Ref ${name} is null`);
      }
      const runtimeInput = inputs[valueOrRef.ref];
      if (validator(runtimeInput)) {
        return runtimeInput;
      } else {
        throw new Error(`Invalid value provided for ${name}: ${runtimeInput}`);
      }
    }
  };
};
var resolveStringRef = createRefResolver(
  (item) => {
    return typeof item === "string";
  }
);
var resolveNumberRef = createRefResolver(
  (item) => {
    return typeof item === "number" && !Number.isNaN(item);
  }
);
var resolveStringArrayRef = createRefResolver(
  (item) => {
    return Array.isArray(item) && item.every((element) => typeof element === "string");
  }
);
var resolveCheckRatioArrayRef = createRefResolver(
  (item) => {
    return Array.isArray(item) && item.every(
      (element) => typeof element === "object" && typeof element.type === "string" && typeof element.ratio === "number" && !Number.isNaN(element.ratio)
    );
  }
);

// lib/client/ensureSource.ts
var ensureDirectPushSource = async (service, _eventType, _inputs) => {
  const sourcesQuery = await service.getSources({});
  const sources = sourcesQuery.source;
  const source = sources == null ? void 0 : sources.find(
    (it) => it !== void 0 && it.type === "DIRECT_PUSH"
  );
  if (source === void 0) {
    throw new Error("Failed to identify direct push source");
  }
  return source;
};
var ensureFusionSource = async (service, eventType, inputs) => {
  const address = resolveStringRef(
    eventType.name,
    eventType.sourceAddress,
    inputs
  );
  const eventTypeId = resolveStringRef(
    eventType.name,
    eventType.fusionEventId,
    inputs
  );
  const sourcesQuery = await service.getSources({});
  const sources = sourcesQuery.source;
  const existing = sources == null ? void 0 : sources.find(
    (it) => it !== void 0 && it.type === "FUSION_SOURCE" && it.blockchainAddress === address && it.fusionEventTypeId === eventTypeId
  );
  if (existing !== void 0) {
    return existing;
  }
  const createMutation = await service.createSource({
    type: "FUSION_SOURCE",
    blockchainAddress: address,
    fusionEventTypeId: eventTypeId
  });
  const source = createMutation.createSource;
  if (source === void 0) {
    throw new Error("Failed to create source");
  }
  return source;
};
var ensureBroadcastSource = async (service, eventType, inputs) => {
  const sourcesQuery = await service.getSources({});
  const sources = sourcesQuery.source;
  if (sources === void 0) {
    throw new Error("Failed to fetch sources");
  }
  const address = resolveStringRef(
    eventType.name,
    eventType.broadcastId,
    inputs
  );
  const existing = sources.find(
    (it) => (it == null ? void 0 : it.type) === "BROADCAST" && it.blockchainAddress === address
  );
  if (existing !== void 0) {
    return existing;
  }
  const createMutation = await service.createSource({
    type: "BROADCAST",
    blockchainAddress: address
  });
  const result = createMutation.createSource;
  if (result === void 0) {
    throw new Error("Failed to create source");
  }
  return result;
};
var ensureTradingPairSource = async (service, _eventType, _inputs) => {
  const sourcesQuery = await service.getSources({});
  const sources = sourcesQuery.source;
  const source = sources == null ? void 0 : sources.find((it) => (it == null ? void 0 : it.type) === "DIRECT_PUSH");
  if (source === void 0) {
    throw new Error("Failed to identify trading pair source (=directPush)");
  }
  return source;
};
var ensurePriceChangeSources = async (service, eventType, _inputs) => {
  const sourcesQuery = await service.getSources({});
  const sources = sourcesQuery.source;
  if (sources === void 0) {
    throw new Error("Failed to fetch sources");
  }
  const results = [];
  const sourcesToCreate = new Set(eventType.tokenIds);
  sources.forEach((existing) => {
    if ((existing == null ? void 0 : existing.type) === "COIN_PRICE_CHANGES") {
      sourcesToCreate.delete(existing.blockchainAddress);
      results.push(existing);
    }
  });
  if (sourcesToCreate.size > 0) {
    let createSourcePromise = Promise.resolve();
    sourcesToCreate.forEach((tokenId) => {
      createSourcePromise = createSourcePromise.then(async () => {
        const result = await service.createSource({
          type: "COIN_PRICE_CHANGES",
          blockchainAddress: tokenId
        });
        const source = result.createSource;
        if (source !== void 0) {
          results.push(source);
        }
      });
    });
    await createSourcePromise;
  }
  return results;
};
var ensureWalletBalanceSources = async (service, _eventType, _inputs) => {
  const connectedWalletsQuery = await service.getConnectedWallets({});
  const connectedWallets = connectedWalletsQuery.connectedWallet;
  if (!connectedWallets) {
    throw new Error("Failed to fetch connected wallets");
  }
  const connectedWalletSources = connectedWallets.map((it) => {
    var _a;
    const sourceType = ((wallet) => {
      switch (wallet) {
        case "ACALA":
          return "ACALA_WALLET";
        case "APTOS":
          return "APTOS_WALLET";
        case "ARBITRUM":
          return "ARBITRUM_WALLET";
        case "AVALANCHE":
          return "AVALANCHE_WALLET";
        case "BINANCE":
          return "BINANCE_WALLET";
        case "ETHEREUM":
          return "ETHEREUM_WALLET";
        case "BASE":
          return "ETHEREUM_WALLET";
        case "POLYGON":
          return "POLYGON_WALLET";
        case "SOLANA":
          return "SOLANA_WALLET";
        case "OPTIMISM":
          return "OPTIMISM_WALLET";
        case "SUI":
          return "SUI_WALLET";
        case "ZKSYNC":
          return "ZKSYNC_WALLET";
        default:
          throw new Error("Unsupported walletType");
      }
    })(it == null ? void 0 : it.walletBlockchain);
    const sourceAddress = (_a = it == null ? void 0 : it.address) != null ? _a : "";
    return {
      name: `${sourceType} ${sourceAddress}`,
      blockchainAddress: sourceAddress,
      type: sourceType
    };
  });
  const sourcesQuery = await service.getSources({});
  const sources = sourcesQuery.source;
  if (sources === void 0) {
    throw new Error("Failed to fetch sources");
  }
  const promises = connectedWalletSources.map(async (connectedWalletSource) => {
    const found = sources.find(
      (source) => (source == null ? void 0 : source.name) === connectedWalletSource.name
    );
    if (found) {
      return found;
    }
    const { createSource: newSource } = await service.createSource(
      connectedWalletSource
    );
    if (!newSource) {
      throw new Error(`Failed to create ${connectedWalletSource.type} source`);
    }
    return newSource;
  });
  const ensuredSources = await Promise.all(promises);
  return ensuredSources;
};
var normalizeSourceAddress = (sourceType, blockchainAddress) => {
  switch (sourceType) {
    case "ETHEREUM_WALLET":
    case "POLYGON_WALLET":
    case "ARBITRUM_WALLET":
    case "BINANCE_WALLET":
    case "OPTIMISM_WALLET":
    case "AVALANCHE_WALLET":
    case "ZKSYNC_WALLET":
    case "BENQI":
    case "DELTA_PRIME":
    case "DELTA_PRIME_LENDING_RATES":
    case "APTOS_WALLET":
      return normalizeHexString(blockchainAddress);
    default:
      return blockchainAddress;
  }
};
var normalizeHexString = (input) => {
  let result = input;
  if (input !== "") {
    result = input.toLowerCase();
    if (!result.startsWith("0x")) {
      result = "0x" + result;
    }
  }
  return result;
};
var ensureCustomSources = async (service, eventType, inputs) => {
  const sourcesQuery = await service.getSources({});
  const sources = sourcesQuery.source;
  if (sources === void 0) {
    throw new Error("Failed to fetch sources");
  }
  const address = resolveStringRef(
    eventType.name,
    eventType.sourceAddress,
    inputs
  );
  const sourceAddress = normalizeSourceAddress(eventType.sourceType, address);
  const existing = sources.find(
    (it) => (it == null ? void 0 : it.type) === eventType.sourceType && it.blockchainAddress === sourceAddress
  );
  if (existing !== void 0) {
    return existing;
  }
  const createMutation = await service.createSource({
    type: eventType.sourceType,
    blockchainAddress: sourceAddress
  });
  const result = createMutation.createSource;
  if (result === void 0) {
    throw new Error("Failed to create source");
  }
  return result;
};
var ensureXMTPSources = async (service, eventType, inputs) => {
  const sourcesQuery = await service.getSources({});
  const sources = sourcesQuery.source;
  if (sources === void 0) {
    throw new Error("Failed to fetch sources");
  }
  const XMTPTopics = resolveStringArrayRef(
    eventType.name,
    eventType.XMTPTopics,
    inputs
  );
  const XMTPTopicSources = XMTPTopics.map((topic) => ({
    name: topic,
    blockchainAddress: topic,
    type: "XMTP"
  }));
  const promises = XMTPTopicSources.map(async (source) => {
    const found = sources.find(
      (it) => (it == null ? void 0 : it.type) === "XMTP" && it.name === source.name
    );
    if (found) {
      return found;
    }
    const { createSource: newSource } = await service.createSource(source);
    if (!newSource) {
      throw new Error("Failed to create XMTP source");
    }
    return newSource;
  });
  const ensuredSources = await Promise.all(promises);
  return ensuredSources;
};
var ensureHealthCheckSources = async (service, _eventType, _inputs) => {
  const sourcesQuery = await service.getSources({});
  const sources = sourcesQuery.source;
  const source = sources == null ? void 0 : sources.find((it) => (it == null ? void 0 : it.type) === "DIRECT_PUSH");
  if (source === void 0) {
    throw new Error("Failed to identify Health Check source (=directPush)");
  }
  return source;
};
var ensureCreateSupportConversationSources = async (service, eventType, _inputs) => {
  const sourcesQuery = await service.getSources({});
  const sources = sourcesQuery.source;
  const source = sources == null ? void 0 : sources.find((it) => (it == null ? void 0 : it.type) === "NOTIFI_CHAT");
  if (source) {
    return source;
  }
  const createMutation = await service.createSource({
    type: eventType.sourceType,
    blockchainAddress: "*"
  });
  const newSource = createMutation.createSource;
  if (newSource === void 0) {
    throw new Error("Failed to create source");
  }
  return newSource;
};
var ensureSources = async (service, eventType, inputs) => {
  switch (eventType.type) {
    case "directPush": {
      const source = await ensureDirectPushSource(service, eventType, inputs);
      return [source];
    }
    case "broadcast": {
      const source = await ensureBroadcastSource(service, eventType, inputs);
      return [source];
    }
    case "tradingPair": {
      const source = await ensureTradingPairSource(service, eventType, inputs);
      return [source];
    }
    case "priceChange": {
      const sources = await ensurePriceChangeSources(
        service,
        eventType,
        inputs
      );
      return sources;
    }
    case "walletBalance": {
      const sources = await ensureWalletBalanceSources(
        service,
        eventType,
        inputs
      );
      return sources;
    }
    case "custom": {
      const source = await ensureCustomSources(service, eventType, inputs);
      return [source];
    }
    case "XMTP": {
      const sources = await ensureXMTPSources(service, eventType, inputs);
      return sources;
    }
    case "healthCheck": {
      const source = await ensureHealthCheckSources(service, eventType, inputs);
      return [source];
    }
    case "fusionToggle":
    case "fusion": {
      const source = await ensureFusionSource(service, eventType, inputs);
      return [source];
    }
    case "createSupportConversation": {
      const source = await ensureCreateSupportConversationSources(
        service,
        eventType,
        inputs
      );
      return [source];
    }
    case "label": {
      throw new Error("Unsupported event type");
    }
  }
};
var ensureSourceGroup = async (service, name, sourceIds) => {
  var _a, _b;
  const sourceGroupsQuery = await service.getSourceGroups({});
  const existing = (_a = sourceGroupsQuery.sourceGroup) == null ? void 0 : _a.find(
    (it) => it !== void 0 && it.name === name
  );
  if (existing === void 0) {
    const createMutation = await service.createSourceGroup({
      name,
      sourceIds
    });
    const createResult = createMutation.createSourceGroup;
    if (createResult === void 0) {
      throw new Error("Failed to create source group");
    }
    return createResult;
  }
  if (areIdsEqual(sourceIds, (_b = existing.sources) != null ? _b : [])) {
    return existing;
  }
  const updateMutation = await service.updateSourceGroup({
    id: existing.id,
    name,
    sourceIds
  });
  const updateResult = updateMutation.updateSourceGroup;
  if (updateResult === void 0) {
    throw new Error("Failed to update source group");
  }
  return updateResult;
};
var getDirectPushFilter = (source, eventType, inputs) => {
  var _a;
  const filter = (_a = source.applicableFilters) == null ? void 0 : _a.find(
    (it) => (it == null ? void 0 : it.filterType) === "DIRECT_TENANT_MESSAGES"
  );
  if (filter === void 0) {
    throw new Error("Failed to retrieve filter");
  }
  const type = resolveStringRef(eventType.name, eventType.directPushId, inputs);
  const filterOptions = {
    directMessageType: type
  };
  return {
    filter,
    filterOptions
  };
};
var getBroadcastFilter = (source, _eventType, _inputs) => {
  var _a;
  const filter = (_a = source.applicableFilters) == null ? void 0 : _a.find(
    (it) => (it == null ? void 0 : it.filterType) === "BROADCAST_MESSAGES"
  );
  if (filter === void 0) {
    throw new Error("Failed to retrieve filter");
  }
  return {
    filter,
    filterOptions: {}
  };
};
var tradingPairInputsValidator = (inputs) => {
  if (typeof inputs.direction !== "string" || typeof inputs.price !== "number" || typeof inputs.pair !== "string") {
    return false;
  }
  return true;
};
var getTradingPairFilter = (source, eventType, inputs) => {
  var _a;
  const filter = (_a = source.applicableFilters) == null ? void 0 : _a.find(
    (it) => (it == null ? void 0 : it.filterType) === "DIRECT_TENANT_MESSAGES"
  );
  if (filter === void 0) {
    throw new Error("Failed to retrieve TradingPair filter (=directMessage)");
  }
  const tradingPairs = resolveStringArrayRef(
    eventType.name,
    eventType.tradingPairs,
    inputs
  );
  if (tradingPairs.length === 0)
    throw new Error("No trading pairs found");
  const tradingPair = tradingPairInputsValidator(inputs) ? inputs.pair : tradingPairs[0];
  const value = tradingPairInputsValidator(inputs) ? inputs.price.toFixed(8) : "1.00000000";
  return {
    filter,
    filterOptions: {
      tradingPair,
      values: {
        and: [
          {
            key: "spotPrice",
            op: inputs.direction === "above" ? "gt" : "lt",
            value
          }
        ]
      }
    }
  };
};
var getPriceChangeFilter = (sources, _eventType, _inputs) => {
  const filter = sources.flatMap((it) => {
    var _a;
    return (_a = it.applicableFilters) != null ? _a : [];
  }).find((it) => (it == null ? void 0 : it.filterType) === "COIN_PRICE_CHANGE_EVENTS");
  if (filter === void 0) {
    throw new Error("Failed to retrieve filter");
  }
  return {
    filter,
    filterOptions: {}
  };
};
var getWalletBalanceSourceFilter = (source, _eventType, _inputs) => {
  var _a;
  const filter = (_a = source.applicableFilters) == null ? void 0 : _a.find(
    (it) => (it == null ? void 0 : it.filterType) === "BALANCE"
  );
  if (filter === void 0) {
    throw new Error("Failed to retrieve filter: wallet balance");
  }
  return {
    filter,
    filterOptions: {}
  };
};
var getFusionSourceFilter = (source, eventType, inputs) => {
  var _a, _b;
  const filter = (_a = source.applicableFilters) == null ? void 0 : _a.find(
    (it) => (it == null ? void 0 : it.filterType) === "FUSION_SOURCE"
  );
  if (filter === void 0) {
    throw new Error("Failed to retrieve fusion source filter");
  }
  let filterOptions = {};
  if (eventType.selectedUIType === "TOGGLE" || eventType.selectedUIType === "MULTI_THRESHOLD") {
    if (eventType.alertFrequency !== void 0) {
      filterOptions = {
        alertFrequency: eventType.alertFrequency
      };
    }
  } else if (eventType.selectedUIType === "HEALTH_CHECK") {
    const healthRatioKey = `${eventType.name}__healthRatio`;
    if (!inputs[healthRatioKey]) {
      inputs[`${eventType.name}__healthRatio`] = eventType.checkRatios[1].ratio;
    }
    const healthRatio = resolveNumberRef(
      healthRatioKey,
      { type: "ref", ref: healthRatioKey },
      inputs
    );
    const thresholdDirectionKey = `${eventType.name}__healthThresholdDirection`;
    if (!inputs[thresholdDirectionKey]) {
      inputs[thresholdDirectionKey] = eventType.checkRatios[0].type === "above" ? "above" : "below";
    }
    const thresholdDirection = (_b = resolveStringRef(
      thresholdDirectionKey,
      { type: "ref", ref: thresholdDirectionKey },
      inputs
    )) != null ? _b : eventType.checkRatios[0].ratio;
    if (!healthRatio || !thresholdDirection) {
      throw new Error("Failed to retrieve health ratio or direction");
    }
    filterOptions = {
      alertFrequency: eventType.alertFrequency,
      threshold: eventType.numberType === "percentage" ? healthRatio / 100 : healthRatio,
      thresholdDirection: thresholdDirection === "above" ? "above" : "below"
    };
  }
  return {
    filter,
    filterOptions
  };
};
var getCustomFilterOptions = (eventType, inputs) => {
  var _a, _b;
  switch (eventType.selectedUIType) {
    case "TOGGLE":
      return eventType.filterOptions;
    case "HEALTH_CHECK": {
      const healthRatioKey = `${eventType.name}__healthRatio`;
      const healthRatio = (_a = resolveNumberRef(
        healthRatioKey,
        { type: "ref", ref: healthRatioKey },
        inputs
      )) != null ? _a : eventType.checkRatios[0].ratio;
      const thresholdDirectionKey = `${eventType.name}__healthThresholdDirection`;
      const thresholdDirection = (_b = resolveStringRef(
        thresholdDirectionKey,
        { type: "ref", ref: thresholdDirectionKey },
        inputs
      )) != null ? _b : eventType.checkRatios[0].ratio;
      if (!healthRatio || !thresholdDirection) {
        throw new Error("Failed to retrieve health ratio or direction");
      }
      return {
        alertFrequency: eventType.alertFrequency,
        threshold: eventType.numberType === "percentage" ? healthRatio / 100 : healthRatio,
        thresholdDirection: thresholdDirection === "above" ? "above" : "below"
      };
    }
  }
};
var getCustomFilter = (source, eventType, inputs) => {
  var _a;
  const filter = (_a = source.applicableFilters) == null ? void 0 : _a.find(
    (it) => (it == null ? void 0 : it.filterType) === eventType.filterType
  );
  if (filter === void 0) {
    throw new Error("Failed to retrieve filter");
  }
  return {
    filter,
    filterOptions: getCustomFilterOptions(eventType, inputs)
  };
};
var getXMTPFilter = (source, _eventType, _inputs) => {
  var _a;
  const filter = (_a = source.applicableFilters) == null ? void 0 : _a.find(
    (it) => (it == null ? void 0 : it.filterType) === "WEB3_CHAT_MESSAGES"
  );
  if (filter === void 0) {
    throw new Error("Failed to retrieve filter: XMTP");
  }
  return {
    filter,
    filterOptions: {}
  };
};
var getCreateSupportConversationFilter = (source, eventType, _inputs) => {
  var _a;
  const filter = (_a = source.applicableFilters) == null ? void 0 : _a.find(
    (it) => (it == null ? void 0 : it.filterType) === "NOTIFI_CHAT_MESSAGES"
  );
  if (filter === void 0) {
    throw new Error("Failed to retrieve filter: CreateSupportConversation");
  }
  return {
    filter,
    filterOptions: {
      alertFrequency: eventType.alertFrequency
    }
  };
};
var checkInputsIsWithIndex = (inputs) => {
  if ("index" in inputs) {
    return true;
  }
  return false;
};
var getHealthCheckFilter = (source, eventType, inputs) => {
  var _a;
  const filter = (_a = source.applicableFilters) == null ? void 0 : _a.find(
    (it) => (it == null ? void 0 : it.filterType) === "VALUE_THRESHOLD"
  );
  if (filter === void 0) {
    throw new Error("Failed to retrieve filter: healthCheck");
  }
  const checkRatios = resolveCheckRatioArrayRef(
    eventType.name,
    eventType.checkRatios,
    inputs
  );
  let threshold = checkRatios[0].ratio;
  let thresholdDirection = checkRatios[0].type;
  const checkInputsIsWithCustomPercentage = (inputs2) => {
    if ("customPercentage" in inputs2 && "thresholdDirection" in inputs2) {
      return true;
    }
    return false;
  };
  if (checkInputsIsWithIndex(inputs)) {
    threshold = checkRatios[inputs.index].ratio;
    thresholdDirection = checkRatios[inputs.index].type;
  } else if (checkInputsIsWithCustomPercentage(inputs)) {
    threshold = inputs.customPercentage;
    thresholdDirection = inputs.thresholdDirection;
  }
  return {
    filter,
    filterOptions: {
      alertFrequency: eventType.alertFrequency,
      threshold,
      thresholdDirection
    }
  };
};
var ensureSourceAndFilters = async (service, eventType, inputs) => {
  const sources = await ensureSources(service, eventType, inputs);
  const sourceGroup = await ensureSourceGroup(
    service,
    eventType.name,
    sources.map((it) => it.id)
  );
  switch (eventType.type) {
    case "directPush": {
      const { filter, filterOptions } = getDirectPushFilter(
        sources[0],
        eventType,
        inputs
      );
      return {
        sourceGroup,
        filter,
        filterOptions
      };
    }
    case "broadcast": {
      const { filter, filterOptions } = getBroadcastFilter(
        sources[0],
        eventType,
        inputs
      );
      return {
        sourceGroup,
        filter,
        filterOptions
      };
    }
    case "tradingPair": {
      if (!tradingPairInputsValidator(inputs)) {
        throw new Error("Invalid tradingPair inputs");
      }
      const { filter, filterOptions } = getTradingPairFilter(
        sources[0],
        eventType,
        inputs
      );
      return {
        sourceGroup,
        filter,
        filterOptions
      };
    }
    case "priceChange": {
      const { filter, filterOptions } = getPriceChangeFilter(
        sources,
        eventType,
        inputs
      );
      return {
        sourceGroup,
        filter,
        filterOptions
      };
    }
    case "custom": {
      const { filter, filterOptions } = getCustomFilter(
        sources[0],
        eventType,
        inputs
      );
      return {
        sourceGroup,
        filter,
        filterOptions
      };
    }
    case "XMTP": {
      const { filter, filterOptions } = getXMTPFilter(
        sources[0],
        eventType,
        inputs
      );
      return {
        sourceGroup,
        filter,
        filterOptions
      };
    }
    case "healthCheck": {
      const { filter, filterOptions } = getHealthCheckFilter(
        sources[0],
        eventType,
        inputs
      );
      return {
        sourceGroup,
        filter,
        filterOptions
      };
    }
    case "label": {
      throw new Error("Unsupported event type");
    }
    case "walletBalance": {
      const { filter, filterOptions } = getWalletBalanceSourceFilter(
        sources[0],
        eventType,
        inputs
      );
      return {
        sourceGroup,
        filter,
        filterOptions
      };
    }
    case "fusionToggle":
    case "fusion": {
      const { filter, filterOptions } = getFusionSourceFilter(
        sources[0],
        eventType,
        inputs
      );
      return {
        sourceGroup,
        filter,
        filterOptions
      };
    }
    case "createSupportConversation": {
      const { filter, filterOptions } = getCreateSupportConversationFilter(
        sources[0],
        eventType,
        inputs
      );
      return {
        sourceGroup,
        filter,
        filterOptions
      };
    }
  }
};

// lib/client/ensureTarget.ts
var ensureTarget = (create, fetch, identify, valueTransform) => {
  return async (service, value) => {
    if (value === void 0) {
      return void 0;
    }
    const existing = await fetch(service);
    const transformedValue = valueTransform !== void 0 ? valueTransform(value) : value;
    const found = existing == null ? void 0 : existing.find((it) => identify(it) === transformedValue);
    if (found !== void 0) {
      return found.id;
    }
    const created = await create(service, transformedValue);
    return created.id;
  };
};
var ensureEmail = ensureTarget(
  async (service, value) => {
    const mutation = await service.createEmailTarget({
      name: value.toLowerCase(),
      value: value.toLowerCase()
    });
    const result = mutation.createEmailTarget;
    if (result === void 0) {
      throw new Error("Failed to create email target");
    }
    return result;
  },
  async (service) => {
    const query = await service.getEmailTargets({});
    return query.emailTarget;
  },
  (arg) => {
    var _a;
    return (_a = arg == null ? void 0 : arg.emailAddress) == null ? void 0 : _a.toLowerCase();
  },
  (value) => value.toLowerCase()
);
var ensureSms = ensureTarget(
  async (service, value) => {
    const mutation = await service.createSmsTarget({
      name: value,
      value
    });
    const result = mutation.createSmsTarget;
    if (result === void 0) {
      throw new Error("Failed to create sms target");
    }
    return result;
  },
  async (service) => {
    const query = await service.getSmsTargets({});
    return query.smsTarget;
  },
  (arg) => arg == null ? void 0 : arg.phoneNumber
);
var ensureTelegram = ensureTarget(
  async (service, value) => {
    const mutation = await service.createTelegramTarget({
      name: value.toLowerCase(),
      value: value.toLowerCase()
    });
    const result = mutation.createTelegramTarget;
    if (result === void 0) {
      throw new Error("Failed to create telegramTarget");
    }
    return result;
  },
  async (service) => {
    const query = await service.getTelegramTargets({});
    return query.telegramTarget;
  },
  (arg) => {
    var _a;
    return (_a = arg == null ? void 0 : arg.telegramId) == null ? void 0 : _a.toLowerCase();
  },
  (value) => value.toLowerCase()
);
var ensureDiscord = ensureTarget(
  async (service, value) => {
    const mutation = await service.createDiscordTarget({
      name: value,
      value
    });
    const result = mutation.createDiscordTarget;
    if (result === void 0) {
      throw new Error("Failed to create discordTarget");
    }
    return result;
  },
  async (service) => {
    const query = await service.getDiscordTargets({});
    return query.discordTarget;
  },
  (arg) => arg == null ? void 0 : arg.name,
  () => "Default"
);
var ensureWebhook = async (service, params) => {
  if (params === void 0) {
    return void 0;
  }
  const query = await service.getWebhookTargets({});
  const existing = query.webhookTarget;
  const found = existing == null ? void 0 : existing.find(
    (it) => (it == null ? void 0 : it.url.toLowerCase()) === params.url.toLowerCase() && (it == null ? void 0 : it.format) === params.format
  );
  if (found !== void 0) {
    return found.id;
  }
  const mutation = await service.createWebhookTarget(__spreadProps(__spreadValues({}, params), {
    name: params.url.toLowerCase(),
    url: params.url.toLowerCase()
  }));
  const created = mutation.createWebhookTarget;
  if (created === void 0) {
    throw new Error("Failed to create webhook target");
  }
  return created.id;
};

// lib/storage/InMemoryStorageDriver.ts
var getEnvPrefix = (env) => {
  switch (env) {
    case "Production":
      return "notifi-jwt";
    case "Development":
      return "notifi-jwt:dev";
    case "Staging":
      return "notifi-jwt:stg";
    case "Local":
      return "notifi-jwt:local";
  }
};
var createInMemoryStorageDriver = (config) => {
  let keyPrefix = `${getEnvPrefix(config.env)}:${config.tenantId}:${config.walletBlockchain}`;
  if (checkIsConfigWithPublicKeyAndAddress(config)) {
    keyPrefix += `:${config.accountAddress}:${config.authenticationKey}`;
  } else {
    keyPrefix += `:${config.walletPublicKey}`;
  }
  const storageBackend = {};
  const storageDriver = {
    get: (key) => {
      const newKey = `${keyPrefix}:${key}`;
      let result = null;
      if (newKey in storageBackend) {
        const json = storageBackend[newKey];
        result = JSON.parse(json);
      }
      return Promise.resolve(result);
    },
    set: (key, newValue) => {
      const newKey = `${keyPrefix}:${key}`;
      if (newValue === null) {
        delete storageBackend[newKey];
      } else {
        storageBackend[newKey] = JSON.stringify(newValue);
      }
      return Promise.resolve();
    },
    has: (key) => {
      const newKey = `${keyPrefix}:${key}`;
      return Promise.resolve(newKey in storageBackend);
    }
  };
  return storageDriver;
};

// lib/storage/NotifiFrontendStorage.ts
var KEY_AUTHORIZATION = "authorization";
var KEY_ROLES = "roles";
var NotifiFrontendStorage = class {
  constructor(_driver) {
    this._driver = _driver;
  }
  getAuthorization() {
    return this._driver.get(KEY_AUTHORIZATION);
  }
  setAuthorization(newValue) {
    return this._driver.set(KEY_AUTHORIZATION, newValue);
  }
  hasAuthorization() {
    return this._driver.has(KEY_AUTHORIZATION);
  }
  getRoles() {
    return this._driver.get(KEY_ROLES);
  }
  setRoles(newValue) {
    return this._driver.set(KEY_ROLES, newValue);
  }
  hasRoles() {
    return this._driver.has(KEY_ROLES);
  }
};

// lib/storage/LocalForageStorageDriver.ts
import localforage from "localforage";
localforage.config({
  name: "notifi"
});
var getEnvPrefix2 = (env) => {
  switch (env) {
    case "Production":
      return "notifi-jwt";
    case "Development":
      return "notifi-jwt:dev";
    case "Staging":
      return "notifi-jwt:stg";
    case "Local":
      return "notifi-jwt:local";
  }
};
var createLocalForageStorageDriver = (config) => {
  let keyPrefix = `${getEnvPrefix2(config.env)}:${config.tenantId}:${config.walletBlockchain}`;
  if (checkIsConfigWithPublicKeyAndAddress(config)) {
    keyPrefix += `:${config.accountAddress}:${config.authenticationKey}`;
  } else {
    keyPrefix += `:${config.walletPublicKey}`;
  }
  const storageDriver = {
    get: async (key) => {
      const item = await localforage.getItem(`${keyPrefix}:${key}`);
      return item;
    },
    set: async (key, newValue) => {
      await localforage.setItem(`${keyPrefix}:${key}`, newValue);
    },
    has: async (key) => {
      const keys = await localforage.keys();
      return keys.indexOf(`${keyPrefix}:${key}`) >= 0;
    }
  };
  return storageDriver;
};

// lib/client/NotifiFrontendClient.ts
var SIGNING_MESSAGE = `Sign in with Notifi 

    No password needed or gas is needed. 

    Clicking \u201CApprove\u201D only means you have proved this wallet is owned by you! 

    This request will not trigger any transaction or cost any gas fees. 

    Use of our website and service is subject to our terms of service and privacy policy. 
 
 'Nonce:' `;
var NotifiFrontendClient = class {
  constructor(_configuration, _service, _storage) {
    this._configuration = _configuration;
    this._service = _service;
    this._storage = _storage;
    this._clientRandomUuid = null;
    this._userState = null;
  }
  get userState() {
    return this._userState;
  }
  async initialize() {
    const [storedAuthorization, roles] = await Promise.all([
      this._storage.getAuthorization(),
      this._storage.getRoles()
    ]);
    let authorization = storedAuthorization;
    if (authorization === null) {
      this._service.setJwt(void 0);
      const logOutStatus = {
        status: "loggedOut"
      };
      this._userState = logOutStatus;
      return logOutStatus;
    }
    const expiryDate = new Date(authorization.expiry);
    const now = /* @__PURE__ */ new Date();
    if (expiryDate <= now) {
      this._service.setJwt(void 0);
      const expiredStatus = {
        status: "expired",
        authorization
      };
      this._userState = expiredStatus;
      return expiredStatus;
    }
    const refreshTime = /* @__PURE__ */ new Date();
    refreshTime.setDate(now.getDate() + 7);
    if (expiryDate < refreshTime) {
      try {
        const refreshMutation = await this._service.refreshAuthorization({});
        const newAuthorization = refreshMutation.refreshAuthorization;
        if (newAuthorization !== void 0) {
          this._storage.setAuthorization(newAuthorization);
          authorization = newAuthorization;
        }
      } catch (e) {
        console.log("Failed to refresh Notifi token", e);
      }
    }
    this._service.setJwt(authorization.token);
    const userState = {
      status: "authenticated",
      authorization,
      roles: roles != null ? roles : []
    };
    this._userState = userState;
    return userState;
  }
  async logOut() {
    await Promise.all([
      this._storage.setAuthorization(null),
      this._storage.setRoles(null),
      this._service.logOut()
    ]);
    return {
      status: "loggedOut"
    };
  }
  async logIn(signMessageParams) {
    const timestamp = Math.round(Date.now() / 1e3);
    const signature = await this._signMessage({
      signMessageParams,
      timestamp
    });
    const { tenantId, walletBlockchain } = this._configuration;
    let loginResult = void 0;
    switch (walletBlockchain) {
      case "BASE":
      case "ETHEREUM":
      case "POLYGON":
      case "ARBITRUM":
      case "AVALANCHE":
      case "BINANCE":
      case "OPTIMISM":
      case "ZKSYNC":
      case "SOLANA": {
        const result = await this._service.logInFromDapp({
          walletBlockchain,
          walletPublicKey: this._configuration.walletPublicKey,
          dappAddress: tenantId,
          timestamp,
          signature
        });
        loginResult = result.logInFromDapp;
        break;
      }
      case "SUI":
      case "ACALA":
      case "NEAR":
      case "INJECTIVE":
      case "OSMOSIS":
      case "NIBIRU":
      case "APTOS": {
        const result = await this._service.logInFromDapp({
          walletBlockchain,
          walletPublicKey: this._configuration.authenticationKey,
          accountId: this._configuration.accountAddress,
          dappAddress: tenantId,
          timestamp,
          signature
        });
        loginResult = result.logInFromDapp;
        break;
      }
    }
    if (loginResult === void 0) {
      return Promise.reject("Failed to login");
    }
    await this._handleLogInResult(loginResult);
    return loginResult;
  }
  async _signMessage({
    signMessageParams,
    timestamp
  }) {
    if (this._configuration.walletBlockchain !== signMessageParams.walletBlockchain) {
      throw new Error(
        "Sign message params and configuration must have the same blockchain"
      );
    }
    switch (signMessageParams.walletBlockchain) {
      case "ETHEREUM":
      case "POLYGON":
      case "ARBITRUM":
      case "AVALANCHE":
      case "BINANCE":
      case "OPTIMISM": {
        const { walletPublicKey, tenantId } = this._configuration;
        const messageBuffer = new TextEncoder().encode(
          `${SIGNING_MESSAGE}${walletPublicKey}${tenantId}${timestamp.toString()}`
        );
        const signedBuffer = await signMessageParams.signMessage(messageBuffer);
        const signature = normalizeHexString(
          Buffer.from(signedBuffer).toString("hex")
        );
        return signature;
      }
      case "OSMOSIS":
      case "ZKSYNC":
      case "INJECTIVE": {
        const { authenticationKey, tenantId } = this._configuration;
        const messageBuffer = new TextEncoder().encode(
          `${SIGNING_MESSAGE}${authenticationKey}${tenantId}${timestamp.toString()}`
        );
        const signedBuffer = await signMessageParams.signMessage(messageBuffer);
        const signature = Buffer.from(signedBuffer).toString("base64");
        return signature;
      }
      case "SOLANA": {
        const { walletPublicKey, tenantId } = this._configuration;
        const messageBuffer = new TextEncoder().encode(
          `${SIGNING_MESSAGE}${walletPublicKey}${tenantId}${timestamp.toString()}`
        );
        const signedBuffer = await signMessageParams.signMessage(messageBuffer);
        const signature = Buffer.from(signedBuffer).toString("base64");
        return signature;
      }
      case "ACALA": {
        const { accountAddress, tenantId } = this._configuration;
        const message = `${SIGNING_MESSAGE}${accountAddress}${tenantId}${timestamp.toString()}`;
        const signedBuffer = await signMessageParams.signMessage(
          accountAddress,
          message
        );
        return signedBuffer;
      }
      case "APTOS": {
        const signature = await signMessageParams.signMessage(
          SIGNING_MESSAGE,
          timestamp
        );
        return signature;
      }
      case "SUI": {
        const { accountAddress, tenantId } = this._configuration;
        const messageBuffer = new TextEncoder().encode(
          `${SIGNING_MESSAGE}${accountAddress}${tenantId}${timestamp.toString()}`
        );
        const signedBuffer = await signMessageParams.signMessage(messageBuffer);
        const signature = signedBuffer.toString();
        return signature;
      }
      case "NEAR": {
        const { authenticationKey, accountAddress, tenantId } = this._configuration;
        const message = `${`ed25519:` + authenticationKey}${tenantId}${accountAddress}${timestamp.toString()}`;
        const textAsBuffer = new TextEncoder().encode(message);
        const hashBuffer = await window.crypto.subtle.digest(
          "SHA-256",
          textAsBuffer
        );
        const messageBuffer = new Uint8Array(hashBuffer);
        const signedBuffer = await signMessageParams.signMessage(messageBuffer);
        const signature = Buffer.from(signedBuffer).toString("base64");
        return signature;
      }
      default:
        return "Chain not yet supported";
    }
  }
  async _handleLogInResult(user) {
    const authorization = user == null ? void 0 : user.authorization;
    const saveAuthorizationPromise = authorization !== void 0 ? this._storage.setAuthorization(authorization) : Promise.resolve();
    const roles = user == null ? void 0 : user.roles;
    const saveRolesPromise = roles !== void 0 ? this._storage.setRoles(roles.filter(notNullOrEmpty)) : Promise.resolve();
    if (authorization && roles) {
      const userState = {
        status: "authenticated",
        authorization,
        roles: roles.filter((role) => !!role)
      };
      this._userState = userState;
    }
    await Promise.all([saveAuthorizationPromise, saveRolesPromise]);
  }
  async fetchData() {
    return this._service.fetchData({});
  }
  async beginLoginViaTransaction({
    walletBlockchain,
    walletAddress
  }) {
    const { tenantId } = this._configuration;
    const result = await this._service.beginLogInByTransaction({
      walletAddress,
      walletBlockchain,
      dappAddress: tenantId
    });
    const nonce = result.beginLogInByTransaction.nonce;
    if (nonce === null) {
      throw new Error("Failed to begin login process");
    }
    const ruuid = crypto.randomUUID();
    this._clientRandomUuid = ruuid;
    const encoder = new TextEncoder();
    const data = encoder.encode(nonce + ruuid);
    const hashBuffer = await crypto.subtle.digest("SHA-256", data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const logValue = "Notifi Auth: 0x" + hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
    return { nonce: logValue };
  }
  async completeLoginViaTransaction({
    walletBlockchain,
    walletAddress,
    transactionSignature
  }) {
    const { tenantId } = this._configuration;
    const clientRandomUuid = this._clientRandomUuid;
    this._clientRandomUuid = null;
    if (clientRandomUuid === null) {
      throw new Error(
        "BeginLoginViaTransaction is required to be called first"
      );
    }
    const result = await this._service.completeLogInByTransaction({
      walletAddress,
      walletBlockchain,
      dappAddress: tenantId,
      randomUuid: clientRandomUuid,
      transactionSignature
    });
    await this._handleLogInResult(result.completeLogInByTransaction);
    return result;
  }
  async getTargetGroups() {
    var _a, _b;
    const query = await this._service.getTargetGroups({});
    const results = (_b = (_a = query.targetGroup) == null ? void 0 : _a.filter(notNullOrEmpty)) != null ? _b : [];
    return results;
  }
  async ensureTargetGroup({
    name,
    emailAddress,
    phoneNumber,
    telegramId,
    webhook,
    discordId
  }) {
    var _a;
    const [
      targetGroupsQuery,
      emailTargetId,
      smsTargetId,
      telegramTargetId,
      webhookTargetId,
      discordTargetId
    ] = await Promise.all([
      this._service.getTargetGroups({}),
      ensureEmail(this._service, emailAddress),
      ensureSms(this._service, phoneNumber),
      ensureTelegram(this._service, telegramId),
      ensureWebhook(this._service, webhook),
      ensureDiscord(this._service, discordId)
    ]);
    const emailTargetIds = emailTargetId === void 0 ? [] : [emailTargetId];
    const smsTargetIds = smsTargetId === void 0 ? [] : [smsTargetId];
    const telegramTargetIds = telegramTargetId === void 0 ? [] : [telegramTargetId];
    const webhookTargetIds = webhookTargetId === void 0 ? [] : [webhookTargetId];
    const discordTargetIds = discordTargetId === void 0 ? [] : [discordTargetId];
    const existing = (_a = targetGroupsQuery.targetGroup) == null ? void 0 : _a.find(
      (it) => (it == null ? void 0 : it.name) === name
    );
    if (existing !== void 0) {
      return this._updateTargetGroup({
        existing,
        emailTargetIds,
        smsTargetIds,
        telegramTargetIds,
        webhookTargetIds,
        discordTargetIds
      });
    }
    const createMutation = await this._service.createTargetGroup({
      name,
      emailTargetIds,
      smsTargetIds,
      telegramTargetIds,
      webhookTargetIds,
      discordTargetIds
    });
    if (createMutation.createTargetGroup === void 0) {
      throw new Error("Failed to create target group");
    }
    return createMutation.createTargetGroup;
  }
  async _updateTargetGroup({
    existing,
    emailTargetIds,
    smsTargetIds,
    telegramTargetIds,
    webhookTargetIds,
    discordTargetIds
  }) {
    var _a, _b, _c, _d, _e, _f;
    if (areIdsEqual(emailTargetIds, (_a = existing.emailTargets) != null ? _a : []) && areIdsEqual(smsTargetIds, (_b = existing.smsTargets) != null ? _b : []) && areIdsEqual(telegramTargetIds, (_c = existing.telegramTargets) != null ? _c : []) && areIdsEqual(webhookTargetIds, (_d = existing.webhookTargets) != null ? _d : []) && areIdsEqual(discordTargetIds, (_e = existing.discordTargets) != null ? _e : [])) {
      return existing;
    }
    const updateMutation = await this._service.updateTargetGroup({
      id: existing.id,
      name: (_f = existing.name) != null ? _f : existing.id,
      emailTargetIds,
      smsTargetIds,
      telegramTargetIds,
      webhookTargetIds,
      discordTargetIds
    });
    const updated = updateMutation.updateTargetGroup;
    if (updated === void 0) {
      throw new Error("Failed to update target group");
    }
    return updated;
  }
  async getSourceGroups() {
    var _a, _b;
    const query = await this._service.getSourceGroups({});
    const results = (_b = (_a = query.sourceGroup) == null ? void 0 : _a.filter(notNullOrEmpty)) != null ? _b : [];
    return results;
  }
  async getAlerts() {
    var _a, _b;
    const query = await this._service.getAlerts({});
    return (_b = (_a = query.alert) == null ? void 0 : _a.filter(notNullOrEmpty)) != null ? _b : [];
  }
  async ensureAlert({
    eventType,
    inputs,
    targetGroupName = "Default"
  }) {
    var _a, _b;
    const [alertsQuery, targetGroupsQuery, sourceAndFilters] = await Promise.all([
      this._service.getAlerts({}),
      this._service.getTargetGroups({}),
      ensureSourceAndFilters(this._service, eventType, inputs)
    ]);
    const targetGroup = (_a = targetGroupsQuery.targetGroup) == null ? void 0 : _a.find(
      (it) => (it == null ? void 0 : it.name) === targetGroupName
    );
    if (targetGroup === void 0) {
      throw new Error("Target group does not exist");
    }
    const { sourceGroup, filter, filterOptions } = sourceAndFilters;
    const packedOptions = packFilterOptions(filterOptions);
    const existing = (_b = alertsQuery.alert) == null ? void 0 : _b.find(
      (it) => it !== void 0 && it.name === eventType.name
    );
    if (existing !== void 0) {
      if (existing.sourceGroup.id === sourceGroup.id && existing.targetGroup.id === targetGroup.id && existing.filter.id === filter.id && existing.filterOptions === packedOptions) {
        return existing;
      }
      await this.deleteAlert({
        id: existing.id
      });
    }
    const mutation = await this._service.createAlert({
      name: eventType.name,
      sourceGroupId: sourceGroup.id,
      filterId: filter.id,
      targetGroupId: targetGroup.id,
      filterOptions: packedOptions,
      groupName: "managed"
    });
    const created = mutation.createAlert;
    if (created === void 0) {
      throw new Error("Failed to create alert");
    }
    return created;
  }
  async deleteAlert({
    id
  }) {
    var _a;
    const mutation = await this._service.deleteAlert({ id });
    const result = (_a = mutation.deleteAlert) == null ? void 0 : _a.id;
    if (result === void 0) {
      throw new Error("Failed to delete alert");
    }
  }
  async updateWallets() {
    const walletEventTypeItem = {
      name: "User Wallets",
      type: "walletBalance"
    };
    const result = await ensureSourceAndFilters(
      this._service,
      walletEventTypeItem,
      {}
    );
    return result;
  }
  /**
   *@deprecated
   *@description Use getFusionNotificationHistory instead
   */
  async getNotificationHistory(variables) {
    var _a, _b;
    const query = await this._service.getNotificationHistory(variables);
    const nodes = (_a = query.notificationHistory) == null ? void 0 : _a.nodes;
    const pageInfo = (_b = query.notificationHistory) == null ? void 0 : _b.pageInfo;
    if (nodes === void 0 || pageInfo === void 0) {
      throw new Error("Failed to fetch notification history");
    }
    return { pageInfo, nodes };
  }
  async getUnreadNotificationHistoryCount() {
    const query = await this._service.getUnreadNotificationHistoryCount({});
    const result = query.unreadNotificationHistoryCount;
    if (!result) {
      throw new Error("Failed to fetch unread notification history count");
    }
    return result;
  }
  async getUserSettings() {
    const query = await this._service.getUserSettings({});
    const result = query.userSettings;
    if (!result) {
      throw new Error("Failed to fetch user settings");
    }
    return result;
  }
  async getFusionNotificationHistory(variables) {
    var _a, _b;
    const query = await this._service.getFusionNotificationHistory(variables);
    const nodes = (_a = query.fusionNotificationHistory) == null ? void 0 : _a.nodes;
    const pageInfo = (_b = query.fusionNotificationHistory) == null ? void 0 : _b.pageInfo;
    if (nodes === void 0 || pageInfo === void 0) {
      throw new Error("Failed to fetch notification history");
    }
    return { pageInfo, nodes };
  }
  async fetchSubscriptionCard(variables) {
    const query = await this._service.findTenantConfig({
      input: __spreadProps(__spreadValues({}, variables), {
        tenant: this._configuration.tenantId
      })
    });
    const result = query.findTenantConfig;
    if (result === void 0) {
      throw new Error("Failed to find tenant config");
    }
    const value = result.dataJson;
    if (value === void 0) {
      throw new Error("Invalid config data");
    }
    const obj = JSON.parse(value);
    let card = void 0;
    switch (obj.version) {
      case "v1": {
        card = obj;
        break;
      }
      case "IntercomV1": {
        card = obj;
      }
    }
    if (card === void 0) {
      throw new Error("Unsupported config format");
    }
    return card;
  }
  async copyAuthorization(config) {
    var _a;
    const auth = await this._storage.getAuthorization();
    const roles = await this._storage.getRoles();
    const driver = ((_a = config.storageOption) == null ? void 0 : _a.driverType) === "InMemory" ? createInMemoryStorageDriver(config) : createLocalForageStorageDriver(config);
    const otherStorage = new NotifiFrontendStorage(driver);
    await Promise.all([
      otherStorage.setAuthorization(auth),
      otherStorage.setRoles(roles)
    ]);
  }
  async sendEmailTargetVerification({
    targetId
  }) {
    var _a;
    const emailTarget = await this._service.sendEmailTargetVerificationRequest({
      targetId
    });
    const id = (_a = emailTarget.sendEmailTargetVerificationRequest) == null ? void 0 : _a.id;
    if (id === void 0) {
      throw new Error(`Unknown error requesting verification`);
    }
    return id;
  }
  async subscribeWallet(params) {
    const { walletBlockchain, signMessage, walletPublicKey } = params.walletParams;
    const signMessageParams = {
      walletBlockchain,
      signMessage
    };
    if (this._userState && this._userState.status === "authenticated") {
      await this.logIn(signMessageParams);
    }
    const timestamp = Math.round(Date.now() / 1e3);
    const signature = await this._signMessage({
      signMessageParams,
      timestamp
    });
    const connectedWallet = await this._service.connectWallet({
      walletBlockchain,
      walletPublicKey,
      accountId: walletBlockchain === "APTOS" || walletBlockchain === "ACALA" || walletBlockchain === "NEAR" || walletBlockchain === "SUI" ? params.walletParams.accountAddress : void 0,
      signature,
      timestamp,
      connectWalletConflictResolutionTechnique: params.connectWalletConflictResolutionTechnique
    });
    return connectedWallet;
  }
  async getConversationMessages(input) {
    const query = await this._service.getConversationMessages(input);
    return query;
  }
  async sendConversationMessages(input) {
    const mutation = await this._service.sendConversationMessages(input);
    return mutation;
  }
  async createSupportConversation(input) {
    const mutation = await this._service.createSupportConversation(input);
    return mutation;
  }
  async createDiscordTarget(input) {
    const mutation = await this._service.createDiscordTarget({
      name: input,
      value: input
    });
    return mutation.createDiscordTarget;
  }
  async markFusionNotificationHistoryAsRead(input) {
    const mutation = await this._service.markFusionNotificationHistoryAsRead(
      input
    );
    return mutation;
  }
  async updateUserSettings(input) {
    const mutation = await this._service.updateUserSettings(input);
    return mutation;
  }
};

// lib/client/clientFactory.ts
import { NotifiService } from "@notifi-network/notifi-graphql";
import { GraphQLClient } from "graphql-request";
var newNotifiStorage = (config) => {
  var _a;
  const driver = ((_a = config.storageOption) == null ? void 0 : _a.driverType) === "InMemory" ? createInMemoryStorageDriver(config) : createLocalForageStorageDriver(config);
  return new NotifiFrontendStorage(driver);
};
var newNotifiService = (config) => {
  const url = envUrl(config.env);
  const client = new GraphQLClient(url);
  return new NotifiService(client);
};
var newFrontendClient = (args) => {
  const config = newFrontendConfig(args);
  const service = newNotifiService(config);
  const storage = newNotifiStorage(config);
  return new NotifiFrontendClient(config, service, storage);
};

// lib/models/IntercomCardConfig.ts
var LABEL_TYPE_MENU_LABELS = {
  ChatCompanyName: "Chat Company Name",
  ChatFTUTitle: "Chat FTU Title",
  ChatFTUDescription: "Chat FTU Description",
  ChatFTUSubTitle: "Chat FTU Sub Title",
  ChatBannerTitle: "Chat Banner Title",
  ChatIntroQuestion: "Chat Intro Question"
};
export {
  LABEL_TYPE_MENU_LABELS,
  NotifiFrontendClient,
  NotifiFrontendStorage,
  SIGNING_MESSAGE,
  checkIsConfigWithPublicKeyAndAddress,
  createInMemoryStorageDriver,
  createLocalForageStorageDriver,
  ensureDiscord,
  ensureEmail,
  ensureSms,
  ensureSourceAndFilters,
  ensureTarget,
  ensureTelegram,
  ensureWebhook,
  envUrl,
  newFrontendClient,
  newFrontendConfig,
  newNotifiService,
  newNotifiStorage,
  normalizeHexString,
  notNullOrEmpty,
  packFilterOptions
};
