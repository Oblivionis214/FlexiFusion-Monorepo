"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SIGNING_MESSAGE = exports.NotifiClientError = void 0;
const react_1 = require("react");
const ensureSource_1 = __importStar(require("../utils/ensureSource"));
const ensureSourceGroup_1 = __importDefault(require("../utils/ensureSourceGroup"));
const ensureTarget_1 = require("../utils/ensureTarget");
const ensureTargetGroup_1 = __importDefault(require("../utils/ensureTargetGroup"));
const ensureTargetIds_1 = __importDefault(require("../utils/ensureTargetIds"));
const fetchDataImpl_1 = __importDefault(require("../utils/fetchDataImpl"));
const packFilterOptions_1 = __importDefault(require("../utils/packFilterOptions"));
const storage_1 = __importDefault(require("../utils/storage"));
const useNotifiConfig_1 = __importDefault(require("./useNotifiConfig"));
const useNotifiService_1 = __importDefault(require("./useNotifiService"));
class NotifiClientError extends Error {
    constructor(underlying) {
        super('NotifiClient encountered an error');
        this.underlying = underlying;
    }
}
exports.NotifiClientError = NotifiClientError;
const projectData = (internalData) => {
    if (internalData == null) {
        return null;
    }
    const { alerts, connectedWallets, emailTargets, filters, smsTargets, sources, targetGroups, sourceGroups, telegramTargets, discordTargets, } = internalData;
    return {
        alerts,
        connectedWallets,
        emailTargets,
        filters,
        smsTargets,
        sourceGroups,
        sources,
        targetGroups,
        telegramTargets,
        discordTargets,
    };
};
// Don't split this line into multiple lines due to some packagers or other build modules that
// modify the string literal, which then causes authentication to fail due to different strings
exports.SIGNING_MESSAGE = `Sign in with Notifi \n\n    No password needed or gas is needed. \n\n    Clicking “Approve” only means you have proved this wallet is owned by you! \n\n    This request will not trigger any transaction or cost any gas fees. \n\n    Use of our website and service is subject to our terms of service and privacy policy. \n \n 'Nonce:' `;
const signMessage = async ({ params, dappAddress, signer, timestamp, }) => {
    switch (params.walletBlockchain) {
        case 'INJECTIVE':
        case 'OSMOSIS':
        case 'NIBIRU':
        case 'SOLANA': {
            if (signer.walletBlockchain !== params.walletBlockchain) {
                throw new Error('Signer and config have different walletBlockchain');
            }
            const { walletPublicKey } = params;
            const messageBuffer = new TextEncoder().encode(`${exports.SIGNING_MESSAGE}${walletPublicKey}${dappAddress}${timestamp.toString()}`);
            const signedBuffer = await signer.signMessage(messageBuffer);
            const signature = Buffer.from(signedBuffer).toString('base64');
            return signature;
        }
        case 'ARBITRUM':
        case 'POLYGON':
        case 'BINANCE':
        case 'OPTIMISM':
        case 'AVALANCHE':
        case 'ZKSYNC':
        case 'BASE':
        case 'ETHEREUM': {
            if (signer.walletBlockchain !== params.walletBlockchain) {
                throw new Error('Signer and config have different walletBlockchain');
            }
            const { walletPublicKey } = params;
            const messageBuffer = new TextEncoder().encode(`${exports.SIGNING_MESSAGE}${walletPublicKey}${dappAddress}${timestamp.toString()}`);
            const signedBuffer = await signer.signMessage(messageBuffer);
            const signature = Buffer.from(signedBuffer).toString('hex');
            return signature;
        }
        case 'APTOS': {
            if (signer.walletBlockchain !== 'APTOS') {
                throw new Error('Signer and config have different walletBlockchain');
            }
            const signature = await signer.signMessage(exports.SIGNING_MESSAGE, timestamp);
            return signature;
        }
        case 'ACALA': {
            if (signer.walletBlockchain !== 'ACALA') {
                throw new Error('Signer and config have different walletBlockchain');
            }
            const { accountAddress } = params;
            if (accountAddress === undefined || accountAddress === null) {
                throw new Error('Must provide Acala Address to sign');
            }
            const message = `${exports.SIGNING_MESSAGE}${accountAddress}${dappAddress}${timestamp.toString()}`;
            const signedBuffer = await signer.signMessage(accountAddress, message);
            return signedBuffer;
        }
        case 'NEAR': {
            if (signer.walletBlockchain !== 'NEAR') {
                throw new Error('Signer and config have different walletBlockchain');
            }
            const { walletPublicKey, accountAddress } = params;
            const message = `${`ed25519:` + walletPublicKey}${dappAddress}${accountAddress}${timestamp.toString()}`;
            const textAsBuffer = new TextEncoder().encode(message);
            const hashBuffer = await window.crypto.subtle.digest('SHA-256', textAsBuffer);
            const messageBuffer = new Uint8Array(hashBuffer);
            const signedBuffer = await signer.signMessage(messageBuffer);
            const signature = Buffer.from(signedBuffer).toString('base64');
            return signature;
        }
        case 'SUI': {
            if (signer.walletBlockchain !== 'SUI') {
                throw new Error('Signer and config have different walletBlockchain');
            }
            const { walletPublicKey } = params;
            const messageBuffer = new TextEncoder().encode(`${exports.SIGNING_MESSAGE}${walletPublicKey}${dappAddress}${timestamp.toString()}`);
            const signedBuffer = await signer.signMessage(messageBuffer);
            const signature = signedBuffer.toString();
            return signature;
        }
    }
};
/**
 * React hook for Notifi SDK
 *
 * @remarks
 * Used to interact with Notifi services
 *
 * @param config - Options to configure the Notifi client
 * <br>
 * <br>
 * See [Alert Creation Guide]{@link https://docs.notifi.network} for more information on creating Alerts
 */
const useNotifiClient = (config) => {
    const { env, dappAddress, walletPublicKey, walletBlockchain } = config;
    const [isInitialized, setIsInitialized] = (0, react_1.useState)(false);
    const notifiConfig = (0, useNotifiConfig_1.default)(env);
    const { getAuthorization, getRoles, setAuthorization, setRoles } = (0, react_1.useMemo)(() => {
        return (0, storage_1.default)({
            dappAddress,
            walletPublicKey,
            jwtPrefix: notifiConfig.storagePrefix,
        });
    }, [dappAddress, walletPublicKey, notifiConfig.storagePrefix]);
    const service = (0, useNotifiService_1.default)(env);
    const [internalData, setInternalData] = (0, react_1.useState)(null);
    const [error, setError] = (0, react_1.useState)(null);
    const [loading, setLoading] = (0, react_1.useState)(false);
    const [isAuthenticated, setIsAuthenticated] = (0, react_1.useState)(false);
    const [expiry, setExpiry] = (0, react_1.useState)(null);
    const [isTokenExpired, setisTokenExpired] = (0, react_1.useState)(false);
    const clientRandomUuid = (0, react_1.useRef)(null);
    const fetchDataRef = (0, react_1.useRef)({});
    /**
     * User's stored preferences for email, sms, etc.
     * @typedef {object} ClientData
     * @property {string | null} email - Email address for Alert notifications
     * @property {string | null} phoneNumber - Phone number for Alert notifications
     * @property {string | null} telegramId - Telegram username for Alert notifications
     *
     */
    /**
     * Fetch user's stored values from Notifi
     *
     * @remarks
     * Obtains the stored values for a user's Alert, Targets, Sources, etc.
     *
     * @returns {ClientData} User's stored values
     * <br>
     * <br>
     * See [Alert Creation Guide]{@link https://docs.notifi.network} for more information on creating Alerts
     */
    const fetchData = (0, react_1.useCallback)(async (forceFetch) => {
        try {
            if (forceFetch === true) {
                fetchDataRef.current = {};
            }
            setLoading(true);
            const newData = await (0, fetchDataImpl_1.default)(service, Date, fetchDataRef.current);
            setInternalData(newData);
            const clientData = projectData(newData);
            if (clientData === null) {
                throw new Error('Unknown error');
            }
            return clientData;
        }
        catch (e) {
            if (e instanceof Error) {
                setError(e);
            }
            else {
                setError(new NotifiClientError(e));
            }
            throw e;
        }
        finally {
            setLoading(false);
        }
    }, [service]);
    (0, react_1.useEffect)(() => {
        // Initial load
        const doInitialLoad = async () => {
            const authorization = await getAuthorization();
            if (authorization === null) {
                setIsAuthenticated(false);
                setIsInitialized(true);
                setExpiry(null);
                setisTokenExpired(false);
                return;
            }
            const { token, expiry } = authorization;
            service.setJwt(token);
            const expiryDate = new Date(expiry);
            const now = new Date();
            if (expiryDate <= now) {
                setIsAuthenticated(false);
                setIsInitialized(true);
                setExpiry(expiry);
                setisTokenExpired(true);
                return;
            }
            // Refresh if less than a week remaining
            const refreshTime = new Date();
            refreshTime.setDate(refreshTime.getDate() + 7);
            if (expiryDate < refreshTime) {
                try {
                    const { token: newToken, expiry: newExpiry } = await service.refreshAuthorization();
                    if (newToken !== null && newExpiry !== null) {
                        service.setJwt(newToken);
                        setAuthorization({ token: newToken, expiry: newExpiry });
                        setIsAuthenticated(true);
                        setExpiry(newExpiry);
                        setisTokenExpired(false);
                    }
                }
                catch (_e) {
                    // Explicity ignore refresh errors
                    setExpiry(expiry);
                    setIsAuthenticated(true);
                }
            }
            else {
                setExpiry(expiry);
                setIsAuthenticated(true);
            }
            const newData = await (0, fetchDataImpl_1.default)(service, Date, fetchDataRef.current);
            setInternalData(newData);
            setLoading(false);
        };
        setIsInitialized(false);
        doInitialLoad()
            .catch((_e) => {
            // Intentionally ignore
        })
            .then(() => {
            setIsInitialized(true);
        });
    }, [getAuthorization, service, setAuthorization]);
    /**
     * Authorization object containing token and metadata
     * @typedef {object} Authorization
     * @property {string | null} token - Authorization token
     * @property {string | null} expiry - Token expiry in ISO 8601-1:2019 format
     *
     */
    /**
     * User's object describing the user account
     * @typedef {object} User
     * @property {string | null} email - Email address associated with account. For dapp logins, the email is auto assigned, but can be changed later
     * @property {boolean} emailConfirmed - Is the account in confirmed? Only confirmed accounts can interact with Notifi
     *
     */
    const handleLogInResult = (0, react_1.useCallback)(async (result) => {
        if (result.authorization !== null) {
            const { token, expiry } = result.authorization;
            if (token !== null && expiry !== null) {
                service.setJwt(token);
                setAuthorization({ token, expiry });
            }
        }
        if (result.roles !== null) {
            setRoles(result.roles);
        }
        else {
            setRoles(null);
        }
        const newData = await (0, fetchDataImpl_1.default)(service, Date, fetchDataRef.current);
        setInternalData(newData);
        setIsAuthenticated(true);
    }, [
        service,
        fetchDataRef,
        setAuthorization,
        setRoles,
        setInternalData,
        setIsAuthenticated,
    ]);
    /**
     * Log in to Notifi
     *
     * @remarks
     * Log in to Notif and obtain security context for future calls to set/retrieve account data
     *
     * @returns {ClientData} User's stored values
     * <br>
     * <br>
     * See [Alert Creation Guide]{@link https://docs.notifi.network} for more information on creating Alerts
     */
    const logIn = (0, react_1.useCallback)(async (signer) => {
        if (signer == null) {
            throw new Error('Signer cannot be null');
        }
        const timestamp = Math.round(Date.now() / 1000);
        setLoading(true);
        try {
            const signature = await signMessage({
                params: config,
                dappAddress,
                timestamp,
                signer,
            });
            const result = await service.logInFromDapp({
                accountId: walletBlockchain === 'APTOS' ||
                    walletBlockchain === 'ACALA' ||
                    walletBlockchain === 'NEAR' ||
                    walletBlockchain === 'SUI' ||
                    walletBlockchain === 'INJECTIVE' ||
                    walletBlockchain === 'OSMOSIS' ||
                    walletBlockchain === 'NIBIRU'
                    ? config.accountAddress
                    : undefined,
                walletPublicKey,
                dappAddress,
                timestamp,
                signature,
                walletBlockchain,
            });
            await handleLogInResult(result);
            return result;
        }
        catch (e) {
            setIsAuthenticated(false);
            if (e instanceof Error) {
                setError(e);
            }
            else {
                setError(new NotifiClientError(e));
            }
            throw e;
        }
        finally {
            setLoading(false);
        }
    }, [
        config,
        dappAddress,
        service,
        walletBlockchain,
        walletPublicKey,
        handleLogInResult,
    ]);
    /**
     * Begin login process leveraging inserting a token in the logs of a transaction
     *
     * @Remarks Call this before starting your transaction to obtain the log string to insert
     *
     * @returns {BeginLoginViaTransactionResult} Contains log string to include in transaction
     */
    const beginLoginViaTransaction = (0, react_1.useCallback)(async () => {
        setLoading(true);
        try {
            const result = await service.beginLogInByTransaction({
                walletAddress: walletPublicKey,
                walletBlockchain: 'SOLANA',
                dappAddress,
            });
            if (result.nonce !== null) {
                const ruuid = window.crypto.randomUUID();
                const encoder = new TextEncoder();
                const data = encoder.encode(result.nonce + ruuid);
                const hashBuffer = await window.crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const logValue = 'Notifi Auth: 0x' +
                    hashArray.map((b) => b.toString(16).padStart(2, '0')).join('');
                clientRandomUuid.current = ruuid;
                const retVal = {
                    logValue: logValue,
                };
                return retVal;
            }
            throw new Error('Failed to begin login process');
        }
        catch (e) {
            setIsAuthenticated(false);
            if (e instanceof Error) {
                setError(e);
            }
            else {
                setError(new NotifiClientError(e));
            }
            throw e;
        }
        finally {
            setLoading(false);
        }
    }, [
        setLoading,
        setIsAuthenticated,
        setError,
        service,
        walletPublicKey,
        dappAddress,
    ]);
    /**
     * Complete login process leveraging inserting a token in the logs of a transaction
     *
     * @Remarks Call this right after your transaction with the transaction signature
     *
     * @param {CompleteLoginViaTransactionInput} input - Input params completing the transaction login
     * @returns {CompleteLoginViaTransactionResult} Contains the User auth object
     */
    const completeLoginViaTransaction = (0, react_1.useCallback)(async (input) => {
        const { transactionSignature } = input;
        setLoading(true);
        try {
            if (!clientRandomUuid.current) {
                throw new Error('BeginLoginViaTransaction is required to be called first');
            }
            const result = await service.completeLogInByTransaction({
                walletAddress: walletPublicKey,
                walletBlockchain: 'SOLANA',
                dappAddress,
                randomUuid: clientRandomUuid.current,
                transactionSignature,
            });
            await handleLogInResult(result);
            return result;
        }
        catch (e) {
            setIsAuthenticated(false);
            if (e instanceof Error) {
                setError(e);
            }
            else {
                setError(new NotifiClientError(e));
            }
            throw e;
        }
        finally {
            clientRandomUuid.current = null;
            setLoading(false);
        }
    }, [
        setLoading,
        handleLogInResult,
        setIsAuthenticated,
        setError,
        service,
        dappAddress,
        clientRandomUuid,
        walletPublicKey,
    ]);
    // when calling ensureDiscordTarget, a discord id should be returned
    const createDiscordTarget = (0, react_1.useCallback)(async (input) => {
        setLoading(true);
        const newData = await (0, fetchDataImpl_1.default)(service, Date, fetchDataRef.current);
        const existingDiscordTargets = newData.discordTargets;
        try {
            return await (0, ensureTarget_1.ensureDiscord)(service, existingDiscordTargets, input);
        }
        catch (e) {
            if (e instanceof Error) {
                setError(e);
            }
            else {
                setError(new NotifiClientError(e));
            }
            throw e;
        }
        finally {
            setLoading(false);
        }
    }, []);
    /**
     * Creates or updates a TargetGroup by name
     *
     * @remarks
     * In most cases the TargetGroups are updated when creating or updating Alerts @see createAlert and @see updateAlert
     * @self should be used only when it's necessary to update the targets without creating Alerts
     *
     * @param {ClientEnsureTargetGroupInput} input - Input params for the TargetGroup
     * @returns {TargetGroup}
     */
    const ensureTargetGroup = (0, react_1.useCallback)(async (input) => {
        setLoading(true);
        try {
            const newData = await (0, fetchDataImpl_1.default)(service, Date, fetchDataRef.current);
            const { emailTargetIds, smsTargetIds, telegramTargetIds, webhookTargetIds, discordTargetIds, } = await (0, ensureTargetIds_1.default)(service, newData, input);
            const targetGroup = await (0, ensureTargetGroup_1.default)(service, newData.targetGroups, {
                name: input.name,
                emailTargetIds: emailTargetIds.filter((id) => !!id),
                smsTargetIds: smsTargetIds.filter((id) => !!id),
                telegramTargetIds: telegramTargetIds.filter((id) => !!id),
                webhookTargetIds: webhookTargetIds.filter((id) => !!id),
                discordTargetIds: discordTargetIds.filter((id) => !!id),
            });
            setInternalData(newData);
            return targetGroup;
        }
        catch (e) {
            if (e instanceof Error) {
                setError(e);
            }
            else {
                setError(new NotifiClientError(e));
            }
            throw e;
        }
        finally {
            setLoading(false);
        }
    }, [service]);
    const ensureSourceGroup = (0, react_1.useCallback)(async (input) => {
        setLoading(true);
        try {
            const newData = await (0, fetchDataImpl_1.default)(service, Date, fetchDataRef.current);
            let sourceIdsPromise = Promise.resolve([]);
            input.sources.forEach((sourceInput) => {
                sourceIdsPromise = sourceIdsPromise.then(async (results) => {
                    const newSource = await (0, ensureSource_1.default)(service, newData.sources, sourceInput);
                    if (newSource.id === null) {
                        throw new Error('Failed to create source');
                    }
                    return [...results, newSource.id];
                });
            });
            const sourceIds = await sourceIdsPromise;
            const sourceGroup = await (0, ensureSourceGroup_1.default)(service, newData.sourceGroups, {
                name: input.name,
                sourceIds,
            });
            setInternalData(newData);
            return sourceGroup;
        }
        catch (e) {
            if (e instanceof Error) {
                setError(e);
            }
            else {
                setError(new NotifiClientError(e));
            }
            throw e;
        }
        finally {
            setLoading(false);
        }
    }, [service]);
    /**
     * Update an Alert
     *
     * @remarks
     * Use this to allow the user to update Alerts
     *
     * @param {ClientUpdateAlertInput} input - Input params for updating an Alert
     * @returns {UserAlert} An Alert object owned by the user
     * <br>
     * <br>
     * See [Alert Creation Guide]{@link https://docs.notifi.network} for more information on creating Alerts
     */
    const updateAlert = (0, react_1.useCallback)(async (input) => {
        var _a;
        const { alertId } = input;
        setLoading(true);
        try {
            const newData = await (0, fetchDataImpl_1.default)(service, Date, fetchDataRef.current);
            const { emailTargetIds, smsTargetIds, telegramTargetIds, webhookTargetIds, discordTargetIds, } = await (0, ensureTargetIds_1.default)(service, newData, input);
            const existingAlert = newData.alerts.find((a) => a.id === alertId);
            if (existingAlert === undefined) {
                throw new Error(`Unable to find alert ${alertId}`);
            }
            const name = existingAlert.name;
            if (!name) {
                throw new Error(`Invalid Alert ${alertId}`);
            }
            const targetGroup = await (0, ensureTargetGroup_1.default)(service, newData.targetGroups, {
                name: (_a = existingAlert.targetGroup.name) !== null && _a !== void 0 ? _a : 'Default',
                emailTargetIds: emailTargetIds.filter((id) => !!id),
                smsTargetIds: smsTargetIds.filter((id) => !!id),
                telegramTargetIds: telegramTargetIds.filter((id) => !!id),
                webhookTargetIds: webhookTargetIds.filter((id) => !!id),
                discordTargetIds: discordTargetIds.filter((id) => !!id),
            });
            const alertIndex = newData.alerts.indexOf(existingAlert);
            const newAlert = Object.assign(Object.assign({}, existingAlert), { targetGroup });
            newData.alerts[alertIndex] = newAlert;
            setInternalData(Object.assign({}, newData));
            return newAlert;
        }
        catch (e) {
            if (e instanceof Error) {
                setError(e);
            }
            else {
                setError(new NotifiClientError(e));
            }
            throw e;
        }
        finally {
            setLoading(false);
        }
    }, [service]);
    /**
     * Connect a Wallet
     *
     * @remarks
     * Use this to associate another wallet to this Notifi account
     *
     * @param {ConnectWalletInput} input - Input params for connecting a wallet
     * @returns {ConnectedWallet} The resulting final data.
     */
    const connectWallet = (0, react_1.useCallback)(async ({ walletParams, connectWalletConflictResolutionTechnique, }) => {
        const timestamp = Math.round(Date.now() / 1000);
        const { walletBlockchain, walletPublicKey } = walletParams;
        setLoading(true);
        try {
            const signature = await signMessage({
                params: walletParams,
                dappAddress,
                timestamp,
                signer: walletParams,
            });
            const result = await service.connectWallet({
                walletBlockchain,
                walletPublicKey,
                accountId: walletBlockchain === 'APTOS' ||
                    walletBlockchain === 'ACALA' ||
                    walletBlockchain === 'NEAR' ||
                    walletBlockchain === 'SUI'
                    ? walletParams.accountAddress
                    : undefined,
                signature,
                timestamp,
                connectWalletConflictResolutionTechnique,
            });
            if (internalData !== null) {
                const newList = [...internalData.connectedWallets];
                newList.push(result);
                setInternalData(Object.assign(Object.assign({}, internalData), { connectedWallets: newList }));
            }
            return result;
        }
        catch (e) {
            if (e instanceof Error) {
                setError(e);
            }
            else {
                setError(new NotifiClientError(e));
            }
            throw e;
        }
        finally {
            setLoading(false);
        }
    }, [service, internalData]);
    /**
     * Create an Alert
     *
     * @remarks
     * Use this to allow the user to create Alerts
     *
     * @param {ClientCreateAlertInput} input - Input params for creating an Alert
     * @returns {UserAlert} An Alert object owned by the user
     * <br>
     * <br>
     * See [Alert Creation Guide]{@link https://docs.notifi.network} for more information on creating Alerts
     */
    const createAlert = (0, react_1.useCallback)(async (input) => {
        var _a;
        const { name, filterId, filterOptions, sourceId, groupName = 'default', targetGroupName, sourceIds: sourceIdsInput, sourceGroupName, } = input;
        setLoading(true);
        try {
            const newData = await (0, fetchDataImpl_1.default)(service, Date, fetchDataRef.current);
            const { emailTargetIds, smsTargetIds, telegramTargetIds, webhookTargetIds, discordTargetIds, } = await (0, ensureTargetIds_1.default)(service, newData, input);
            const existingAlert = newData.alerts.find((a) => a.name === name);
            if (existingAlert !== undefined) {
                throw new Error(`Name must be unique! Found alert ${existingAlert.id} with name ${name}`);
            }
            let sourceIds = [];
            let sourceToUse;
            if (sourceId === '' && sourceIdsInput !== undefined) {
                sourceToUse = newData.sources.find((s) => s.id === sourceIdsInput[0]);
                sourceIds = sourceIdsInput;
            }
            else {
                sourceToUse = newData.sources.find((s) => s.id === sourceId);
                sourceIds = [sourceId];
            }
            if (sourceToUse === undefined) {
                throw new Error(`Invalid source id ${sourceId}`);
            }
            const existingFilter = (_a = sourceToUse.applicableFilters) === null || _a === void 0 ? void 0 : _a.find((f) => (f === null || f === void 0 ? void 0 : f.id) === filterId);
            if (existingFilter === undefined) {
                throw new Error(`Invalid filter id ${filterId}`);
            }
            const sourceGroup = await (0, ensureSourceGroup_1.default)(service, newData.sourceGroups, {
                name: sourceGroupName !== null && sourceGroupName !== void 0 ? sourceGroupName : name,
                sourceIds,
            });
            const targetGroup = await (0, ensureTargetGroup_1.default)(service, newData.targetGroups, {
                name: targetGroupName !== null && targetGroupName !== void 0 ? targetGroupName : 'Default',
                emailTargetIds: emailTargetIds.filter((id) => !!id),
                smsTargetIds: smsTargetIds.filter((id) => !!id),
                telegramTargetIds: telegramTargetIds.filter((id) => !!id),
                webhookTargetIds: webhookTargetIds.filter((id) => !!id),
                discordTargetIds: discordTargetIds.filter((id) => !!id),
            });
            const sourceGroupId = sourceGroup.id;
            if (sourceGroupId === null) {
                throw new Error(`Unknown error creating source group`);
            }
            const targetGroupId = targetGroup.id;
            if (targetGroupId === null) {
                throw new Error(`Unknown error creating target group`);
            }
            const alert = await service.createAlert({
                name,
                sourceGroupId,
                filterId,
                filterOptions: (0, packFilterOptions_1.default)(filterOptions),
                targetGroupId,
                groupName,
            });
            // The returned target group doesn't have individual targets
            // Work around by spreading the known target group
            const newAlert = Object.assign(Object.assign({}, alert), { sourceGroup,
                targetGroup });
            newData.alerts.push(newAlert);
            setInternalData(Object.assign({}, newData));
            return newAlert;
        }
        catch (e) {
            if (e instanceof Error) {
                setError(e);
            }
            else {
                setError(new NotifiClientError(e));
            }
            throw e;
        }
        finally {
            setLoading(false);
        }
    }, [service]);
    /**
     * Delete an Alert
     *
     * @remarks
     * Use this to allow the user to delete Alerts
     *
     * @param {@link ClientDeleteAlertInput} input - Input params for deleting an Alert
     * @returns {string} The processed ID
     * <br>
     * <br>
     * See [Alert Creation Guide]{@link https://docs.notifi.network} for more information on creating Alerts
     */
    const deleteAlert = (0, react_1.useCallback)(async (input) => {
        const { alertId, keepSourceGroup = false, keepTargetGroup = false, } = input;
        try {
            const newData = await (0, fetchDataImpl_1.default)(service, Date, fetchDataRef.current);
            const alertToDelete = newData.alerts.find((a) => {
                return a.id === alertId;
            });
            if (alertToDelete === undefined) {
                throw new Error(`Unknown alert id ${alertId}`);
            }
            const targetGroupId = alertToDelete.targetGroup.id;
            const sourceGroupId = alertToDelete.sourceGroup.id;
            await service.deleteAlert({ id: alertId });
            newData.alerts = newData.alerts.filter((a) => a !== alertToDelete);
            if (targetGroupId !== null && !keepTargetGroup) {
                await service
                    .deleteTargetGroup({
                    id: targetGroupId,
                })
                    .then(() => {
                    newData.targetGroups = newData.targetGroups.filter((t) => t.id !== targetGroupId);
                });
            }
            if (sourceGroupId !== null && !keepSourceGroup) {
                await service
                    .deleteSourceGroup({
                    id: sourceGroupId,
                })
                    .then(() => {
                    newData.sourceGroups = newData.sourceGroups.filter((s) => s.id !== sourceGroupId);
                });
            }
            setInternalData(Object.assign({}, newData));
            return alertId;
        }
        catch (e) {
            if (e instanceof Error) {
                setError(e);
            }
            else {
                setError(new NotifiClientError(e));
            }
            throw e;
        }
        finally {
            setLoading(false);
        }
    }, [service]);
    /**
     * Create a new Source
     *
     * @remarks
     * Use this to allow the user to create a Source object that emits events
     *
     * @param {CreateSourceInput} input - Input params for creating a Source
     * @returns {Source} A Source object that can be used to create an Alert
     * <br>
     * <br>
     * See [Alert Creation Guide]{@link https://docs.notifi.network} for more information on creating Alerts
     */
    const createSource = (0, react_1.useCallback)(async (input) => {
        var _a;
        setLoading(true);
        try {
            const newData = await (0, fetchDataImpl_1.default)(service, Date, fetchDataRef.current);
            const source = await (0, ensureSource_1.default)(service, newData.sources, input);
            (_a = source.applicableFilters) === null || _a === void 0 ? void 0 : _a.forEach((applicableFilter) => {
                const existing = newData.filters.find((existingFilter) => (applicableFilter === null || applicableFilter === void 0 ? void 0 : applicableFilter.id) === (existingFilter === null || existingFilter === void 0 ? void 0 : existingFilter.id));
                if (applicableFilter && existing !== undefined) {
                    newData.filters.push(applicableFilter);
                }
            });
            setInternalData(newData);
            return source;
        }
        catch (e) {
            if (e instanceof Error) {
                setError(e);
            }
            else {
                setError(new NotifiClientError(e));
            }
            throw e;
        }
        finally {
            setLoading(false);
        }
    }, [service]);
    /**
     * Create a Bonfida Auction Source
     *
     * @remarks
     * Use this to allow the user to create a Source object that emits events from Bonfida auctions
     *
     * @param {ClientCreateBonfidaAuctionSourceInput} input - Input params for creating a Bonfida Auction Source
     * @returns {Source} A Source object that can be used to create an Alert
     * <br>
     * <br>
     * See [Alert Creation Guide]{@link https://docs.notifi.network} for more information on creating Alerts
     */
    const createBonfidaAuctionSource = (0, react_1.useCallback)(async (input) => {
        setLoading(true);
        try {
            const newData = await (0, fetchDataImpl_1.default)(service, Date, fetchDataRef.current);
            const source = await (0, ensureSource_1.ensureBonfidaAuctionSource)(service, newData.sources, input);
            setInternalData(newData);
            return source;
        }
        catch (e) {
            if (e instanceof Error) {
                setError(e);
            }
            else {
                setError(new NotifiClientError(e));
            }
            throw e;
        }
        finally {
            setLoading(false);
        }
    }, [service]);
    /**
     * Create a Metaplex Auction Source
     *
     * @remarks
     * Use this to allow the user to create a Source object that emits evevents from Metaplex auctions
     *
     * @param {ClientCreateMetaplexAuctionSourceInput} input - Input params for creating a Metaplex Auction Source
     * @returns {Source} A Source object that can be used to create an Alert
     * <br>
     * <br>
     * See [Alert Creation Guide]{@link https://docs.notifi.network} for more information on creating Alerts
     */
    const createMetaplexAuctionSource = (0, react_1.useCallback)(async (input) => {
        setLoading(true);
        try {
            const newData = await (0, fetchDataImpl_1.default)(service, Date, fetchDataRef.current);
            const source = await (0, ensureSource_1.ensureMetaplexAuctionSource)(service, newData.sources, input);
            setInternalData(newData);
            return source;
        }
        catch (e) {
            if (e instanceof Error) {
                setError(e);
            }
            else {
                setError(new NotifiClientError(e));
            }
            throw e;
        }
        finally {
            setLoading(false);
        }
    }, [service]);
    /**
     * Get the configurations associated with the configured dapp
     *
     * @remarks
     * Use this to determine which Target inputs are supported before a user has authenticated.
     * This also returns the list of country codes that are supported for SMS
     *
     */
    const getConfiguration = (0, react_1.useCallback)(async () => {
        setLoading(true);
        try {
            return await service.getConfigurationForDapp({
                dappAddress: config.dappAddress,
            });
        }
        catch (e) {
            if (e instanceof Error) {
                setError(e);
            }
            else {
                setError(new NotifiClientError(e));
            }
            throw e;
        }
        finally {
            setLoading(false);
        }
    }, [config.dappAddress, service]);
    const logOut = (0, react_1.useCallback)(async () => {
        service.setJwt(null);
        await setAuthorization(null);
        await setRoles(null);
        setIsAuthenticated(false);
        setInternalData(null);
    }, [
        setAuthorization,
        setIsAuthenticated,
        setInternalData,
        setRoles,
        service,
    ]);
    const getTopics = (0, react_1.useCallback)(async () => {
        var _a;
        setLoading(true);
        try {
            const roles = await getRoles();
            const isUserMessenger = (_a = roles === null || roles === void 0 ? void 0 : roles.some((role) => role === 'UserMessenger')) !== null && _a !== void 0 ? _a : false;
            if (!isUserMessenger) {
                throw new NotifiClientError('This user is not authorized for getTopics!');
            }
            return await service.getTopics();
        }
        catch (e) {
            if (e instanceof Error) {
                setError(e);
            }
            else {
                setError(new NotifiClientError(e));
            }
            throw e;
        }
        finally {
            setLoading(false);
        }
    }, [setLoading, getRoles, service, setError]);
    const data = (0, react_1.useMemo)(() => {
        return projectData(internalData);
    }, [internalData]);
    const broadcastMessage = (0, react_1.useCallback)(async ({ topic, subject, message, isHolderOnly, variables: extraVariables, }, signer) => {
        var _a;
        setLoading(true);
        try {
            if (topic.topicName === null) {
                throw new NotifiClientError('Invalid UserTopic');
            }
            let targetTemplates;
            if (topic.targetTemplate !== null) {
                const value = topic.targetTemplate;
                targetTemplates = [
                    {
                        key: 'EMAIL',
                        value,
                    },
                    {
                        key: 'SMS',
                        value,
                    },
                    {
                        key: 'TELEGRAM',
                        value,
                    },
                ];
            }
            const timestamp = Math.round(Date.now() / 1000);
            const variables = [
                {
                    key: 'message',
                    value: message,
                },
                {
                    key: 'subject',
                    value: subject,
                },
            ];
            if (isHolderOnly && topic.targetCollections !== null) {
                variables.push({
                    key: 'TargetCollection',
                    value: JSON.stringify(topic.targetCollections),
                });
            }
            if (extraVariables !== undefined) {
                Object.keys(extraVariables).forEach((key) => {
                    if (key === 'message' ||
                        key === 'subject' ||
                        key === 'TargetCollection') {
                        return; // forEach
                    }
                    variables.push({
                        key,
                        value: extraVariables[key],
                    });
                });
            }
            const signature = await signMessage({
                params: config,
                dappAddress,
                timestamp,
                signer,
            });
            const result = await service.broadcastMessage({
                topicName: topic.topicName,
                targetTemplates,
                timestamp,
                variables,
                walletBlockchain: 'OFF_CHAIN',
                signature,
            });
            return (_a = result.id) !== null && _a !== void 0 ? _a : null;
        }
        catch (e) {
            if (e instanceof Error) {
                setError(e);
            }
            else {
                setError(new NotifiClientError(e));
            }
            throw e;
        }
        finally {
            setLoading(false);
        }
    }, [config, dappAddress, service]);
    const sendEmailTargetVerification = (0, react_1.useCallback)(async ({ targetId }) => {
        setLoading(true);
        try {
            const emailTarget = await service.sendEmailTargetVerificationRequest({
                targetId,
            });
            const id = emailTarget.id;
            if (id === null) {
                throw new Error(`Unknown error requesting verification`);
            }
            return id;
        }
        catch (e) {
            if (e instanceof Error) {
                setError(e);
            }
            else {
                setError(new NotifiClientError(e));
            }
            throw e;
        }
        finally {
            setLoading(false);
        }
    }, [setError, setLoading, service]);
    const fetchSubscriptionCard = (0, react_1.useCallback)(async (input) => {
        setLoading(true);
        try {
            const tenantConfig = await service.findTenantConfig(Object.assign({ tenant: dappAddress }, input));
            return tenantConfig;
        }
        catch (e) {
            if (e instanceof Error) {
                setError(e);
            }
            else {
                setError(new NotifiClientError(e));
            }
            throw e;
        }
        finally {
            setLoading(false);
        }
    }, [setError, setLoading, service, dappAddress]);
    const getFusionNotificationHistory = (0, react_1.useCallback)(async (input) => {
        try {
            const result = await service.getFusionNotificationHistory(input);
            return result;
        }
        catch (e) {
            if (e instanceof Error) {
                setError(e);
            }
            else {
                setError(new NotifiClientError(e));
            }
            throw e;
        }
        finally {
            setLoading(false);
        }
    }, [setLoading, setError, service]);
    const getNotificationHistory = (0, react_1.useCallback)(async (input) => {
        try {
            const result = await service.getNotificationHistory(input);
            return result;
        }
        catch (e) {
            if (e instanceof Error) {
                setError(e);
            }
            else {
                setError(new NotifiClientError(e));
            }
            throw e;
        }
        finally {
            setLoading(false);
        }
    }, [setLoading, setError, service]);
    const getUnreadNotificationHistoryCount = (0, react_1.useCallback)(async () => {
        try {
            const result = await service.getUnreadNotificationHistoryCount();
            return result;
        }
        catch (e) {
            if (e instanceof Error) {
                setError(e);
            }
            else {
                setError(new NotifiClientError(e));
            }
            throw e;
        }
        finally {
            setLoading(false);
        }
    }, [setLoading, setError, service]);
    const getConversationMessages = (0, react_1.useCallback)(async (input) => {
        try {
            const result = await service.getConversationMessages(input);
            return result;
        }
        catch (e) {
            if (e instanceof Error) {
                setError(e);
            }
            else {
                setError(new NotifiClientError(e));
            }
            throw e;
        }
        finally {
            setLoading(false);
        }
    }, [setLoading, setError, service]);
    const sendConversationMessages = (0, react_1.useCallback)(async (input) => {
        try {
            const result = await service.sendConversationMessages(input);
            return result;
        }
        catch (e) {
            if (e instanceof Error) {
                setError(e);
            }
            else {
                setError(new NotifiClientError(e));
            }
            throw e;
        }
        finally {
            setLoading(false);
        }
    }, [setLoading, setError, service]);
    const createSupportConversation = (0, react_1.useCallback)(async () => {
        try {
            const result = await service.createSupportConversation();
            return result;
        }
        catch (e) {
            if (e instanceof Error) {
                setError(e);
            }
            else {
                setError(new NotifiClientError(e));
            }
            throw e;
        }
        finally {
            setLoading(false);
        }
    }, [setLoading, setError, service]);
    const copyAuthorization = (0, react_1.useCallback)(async (publicKey) => {
        const [auth, roles] = await Promise.all([getAuthorization(), getRoles()]);
        const otherStorage = (0, storage_1.default)({
            walletPublicKey: publicKey,
            jwtPrefix: notifiConfig.storagePrefix,
            dappAddress,
        });
        await Promise.all([
            otherStorage.setAuthorization(auth),
            otherStorage.setRoles(roles),
        ]);
    }, [storage_1.default, notifiConfig, dappAddress]);
    const markFusionNotificationHistoryAsRead = (0, react_1.useCallback)(async (input) => {
        try {
            const result = await service.markFusionNotificationHistoryAsRead(input);
            return result;
        }
        catch (e) {
            if (e instanceof Error) {
                setError(e);
            }
            else {
                setError(new NotifiClientError(e));
            }
            throw e;
        }
        finally {
            setLoading(false);
        }
    }, [setLoading, setError, service]);
    const client = {
        beginLoginViaTransaction,
        broadcastMessage,
        completeLoginViaTransaction,
        connectWallet,
        logIn,
        logOut,
        createAlert,
        createBonfidaAuctionSource,
        createMetaplexAuctionSource,
        createSource,
        ensureSourceGroup,
        deleteAlert,
        fetchData,
        fetchSubscriptionCard,
        getConfiguration,
        getConversationMessages,
        getFusionNotificationHistory,
        getNotificationHistory,
        getTopics,
        updateAlert,
        ensureTargetGroup,
        sendConversationMessages,
        sendEmailTargetVerification,
        createSupportConversation,
        createDiscordTarget,
        getUnreadNotificationHistoryCount,
        markFusionNotificationHistoryAsRead,
    };
    return Object.assign({ data,
        error,
        expiry,
        isTokenExpired,
        isAuthenticated,
        isInitialized,
        loading,
        copyAuthorization }, client);
};
exports.default = useNotifiClient;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXNlTm90aWZpQ2xpZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vbGliL2hvb2tzL3VzZU5vdGlmaUNsaWVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9DQSxpQ0FBMEU7QUFFMUUsc0VBRytCO0FBQy9CLG1GQUErRDtBQUMvRCx3REFBc0Q7QUFDdEQsbUZBQStEO0FBQy9ELCtFQUF1RDtBQUN2RCwyRUFHZ0M7QUFDaEMsbUZBQTJEO0FBQzNELCtEQUF1QztBQUN2Qyx3RUFBMkU7QUFDM0UsMEVBQWtEO0FBcUJsRCxNQUFhLGlCQUFrQixTQUFRLEtBQUs7SUFDMUMsWUFBbUIsVUFBbUI7UUFDcEMsS0FBSyxDQUFDLG1DQUFtQyxDQUFDLENBQUM7UUFEMUIsZUFBVSxHQUFWLFVBQVUsQ0FBUztJQUV0QyxDQUFDO0NBQ0Y7QUFKRCw4Q0FJQztBQUVELE1BQU0sV0FBVyxHQUFHLENBQUMsWUFBaUMsRUFBcUIsRUFBRTtJQUMzRSxJQUFJLFlBQVksSUFBSSxJQUFJLEVBQUU7UUFDeEIsT0FBTyxJQUFJLENBQUM7S0FDYjtJQUVELE1BQU0sRUFDSixNQUFNLEVBQ04sZ0JBQWdCLEVBQ2hCLFlBQVksRUFDWixPQUFPLEVBQ1AsVUFBVSxFQUNWLE9BQU8sRUFDUCxZQUFZLEVBQ1osWUFBWSxFQUNaLGVBQWUsRUFDZixjQUFjLEdBQ2YsR0FBRyxZQUFZLENBQUM7SUFFakIsT0FBTztRQUNMLE1BQU07UUFDTixnQkFBZ0I7UUFDaEIsWUFBWTtRQUNaLE9BQU87UUFDUCxVQUFVO1FBQ1YsWUFBWTtRQUNaLE9BQU87UUFDUCxZQUFZO1FBQ1osZUFBZTtRQUNmLGNBQWM7S0FDZixDQUFDO0FBQ0osQ0FBQyxDQUFDO0FBRUYsOEZBQThGO0FBQzlGLCtGQUErRjtBQUNsRixRQUFBLGVBQWUsR0FBRywrVUFBK1UsQ0FBQztBQUUvVyxNQUFNLFdBQVcsR0FBRyxLQUFLLEVBQUUsRUFDekIs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