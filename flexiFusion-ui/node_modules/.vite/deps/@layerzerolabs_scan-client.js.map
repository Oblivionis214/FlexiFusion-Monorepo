{
  "version": 3,
  "sources": ["../../@layerzerolabs/scan-client/src/client.ts"],
  "sourcesContent": ["import axios from 'axios';\n\nexport type Environment = 'testnet' | 'mainnet' | 'sandbox';\n\nexport type ClientOptions = {};\n\nexport enum MessageStatus {\n  INFLIGHT = 'INFLIGHT',\n  DELIVERED = 'DELIVERED',\n  FAILED = 'FAILED',\n}\n\nexport type Message = {\n  srcUaAddress: string;\n  dstUaAddress: string;\n  srcChainId: number;\n  dstChainId: number;\n  dstTxHash?: string;\n  dstTxError?: string;\n  srcTxHash?: string;\n  srcBlockHash?: string;\n  srcBlockNumber?: string;\n  srcUaNonce: number;\n  status: MessageStatus;\n};\n\nconst URLS: Record<Environment, string> = {\n  testnet: 'https://api-testnet.layerzero-scan.com',\n  mainnet: 'https://api-mainnet.layerzero-scan.com',\n  sandbox: 'https://api-sandbox.layerzero-scan.com',\n};\n\ntype GetMessagesBySrcTxHashResponse = {\n  messages: Message[];\n};\n\nexport const createClient = (env: Environment, options?: ClientOptions) => {\n  const url = URLS[env];\n  if (!url) throw new Error(`No endpoint for env ${env}`);\n\n  const client = axios.create({\n    baseURL: url,\n  });\n\n  return {\n    async getMessagesBySrcTxHash(srcTxHash: string) {\n      if (!srcTxHash) throw new Error('srcTxHash must be provided');\n      const {data} = await client.get<GetMessagesBySrcTxHashResponse>(`/tx/${srcTxHash}`);\n      return data;\n    },\n  };\n};\n\nexport function getMessagesBySrcTxHash(srcChainId: number, srcTxHash: string) {\n  const env = srcChainId < 10000 ? 'mainnet' : srcChainId < 20000 ? 'testnet' : 'sandbox';\n  return createClient(env).getMessagesBySrcTxHash(srcTxHash);\n}\n\ntype DeliveredMessage = Message & {dstTxHash: string};\n\nexport async function waitForMessageReceived(\n  srcChainId: number,\n  srcTxHash: string,\n  pollInterval = 3000,\n): Promise<DeliveredMessage> {\n  const env = srcChainId < 10000 ? 'mainnet' : srcChainId < 20000 ? 'testnet' : 'sandbox';\n  const client = createClient(env);\n  while (true) {\n    try {\n      const {messages} = await client.getMessagesBySrcTxHash(srcTxHash);\n      const message = messages[0];\n      if (messages.length > 1) {\n        return Promise.reject(new Error(`More than one message`));\n      } else if (message?.status === MessageStatus.FAILED) {\n        return Promise.reject(new Error(`Message failed ${message.dstTxError}`));\n      } else if (message?.status === MessageStatus.DELIVERED) {\n        return message as DeliveredMessage;\n      }\n    } catch {\n      // http error\n    }\n    await sleep(pollInterval);\n  }\n}\n\nconst sleep = (ms = 1000) => new Promise((resolve) => setTimeout(resolve, ms));\n"],
  "mappings": ";;;;;;;;;AAOE,IAAAA,iBAAW,CAAA,mBAAA;AACXA,iBAAA,UAAA,IAAA;AACAA,iBAAA,WAAA,IAAS;AAHC,iBAAAA,QAAAA,IAAAA;AAAA,SAAA;AAoBZ,GAAA,iBAA0C,CAAA,CAAA;AAAA,IACxC,OAAS;EACT,SAAS;EACT,SAAS;EACX,SAAA;AAMO;AACL,IAAA,eAAiB,CAAA,KAAG,YAAA;AACpB,QAAK,MAAA,KAAA,GAAA;AAAK,MAAA,CAAA;AAEV,UAAM,IAAA,MAAS,uBAAa,GAAA,EAAA;AAAA,QAC1B,SAAS,cAAA,OAAA;IACV,SAAA;EAED,CAAA;AAAO,SACL;IACE,MAAI,uBAAC,WAAA;AAAW,UAAA,CAAA;AAChB,cAAO,IAAA,MAAQ,4BAAwD;AACvE,YAAA,EAAO,KAAA,IAAA,MAAA,OAAA,IAAA,OAAA,SAAA,EAAA;AACT,aAAA;IACF;EACF;AAEO;AACL,SAAM,uBAAmB,YAAQ,WAAY;AAC7C,QAAA,MAAO,aAAkB,MAAA,YAAA,aAAuB,MAAS,YAAA;AAC3D,SAAA,aAAA,GAAA,EAAA,uBAAA,SAAA;AAIA;AAKE,eAAY,uBAAqB,YAAY,WAAa,eAAoB,KAAA;AAC9E,QAAM,MAAA,aAAS,MAAgB,YAAA,aAAA,MAAA,YAAA;AAC/B,QAAA,SAAa,aAAA,GAAA;AACX,SAAI,MAAA;AACF,QAAA;AACA,YAAM,EAAA,SAAU,IAAA,MAAU,OAAA,uBAAA,SAAA;AAC1B,YAAI,UAAS,SAAY,CAAA;AACvB,UAAA,SAAO,SAAQ,GAAO;AACxB,eAAA,QAAW,OAAA,IAAA,MAAA,uBAAS,CAAA;MAClB,YAAO,WAAQ,OAAW,SAAM,QAAA,YAAkB,UAAqB;AACzE,eAAA,QAAW,OAAA,IAAA,MAAA,kBAAS,QAAW,UAAA,EAAA,CAAA;MAC7B,YAAO,WAAA,OAAA,SAAA,QAAA,YAAA,aAAA;AACT,eAAA;MACF;IAEA,SAAA,GAAA;IACA;AACF,UAAA,MAAA,YAAA;EACF;AAEA;;",
  "names": ["MessageStatus"]
}
