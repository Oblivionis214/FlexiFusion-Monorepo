import {
  require_browser_ponyfill
} from "./chunk-BUPNLOT2.js";
import {
  parse,
  print
} from "./chunk-Y2ZB3BXP.js";
import {
  __commonJS,
  __require,
  __toESM,
  global,
  import_buffer,
  init_shim
} from "./chunk-KEE3FHXB.js";

// node_modules/localforage/dist/localforage.js
var require_localforage = __commonJS({
  "node_modules/localforage/dist/localforage.js"(exports, module) {
    init_shim();
    (function(f2) {
      if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = f2();
      } else if (typeof define === "function" && define.amd) {
        define([], f2);
      } else {
        var g;
        if (typeof window !== "undefined") {
          g = window;
        } else if (typeof global !== "undefined") {
          g = global;
        } else if (typeof self !== "undefined") {
          g = self;
        } else {
          g = this;
        }
        g.localforage = f2();
      }
    })(function() {
      var define2, module2, exports2;
      return function e(t, n, r) {
        function s(o2, u) {
          if (!n[o2]) {
            if (!t[o2]) {
              var a = typeof __require == "function" && __require;
              if (!u && a)
                return a(o2, true);
              if (i)
                return i(o2, true);
              var f2 = new Error("Cannot find module '" + o2 + "'");
              throw f2.code = "MODULE_NOT_FOUND", f2;
            }
            var l = n[o2] = { exports: {} };
            t[o2][0].call(l.exports, function(e2) {
              var n2 = t[o2][1][e2];
              return s(n2 ? n2 : e2);
            }, l, l.exports, e, t, n, r);
          }
          return n[o2].exports;
        }
        var i = typeof __require == "function" && __require;
        for (var o = 0; o < r.length; o++)
          s(r[o]);
        return s;
      }({ 1: [function(_dereq_, module3, exports3) {
        (function(global) {
          "use strict";
          var Mutation = global.MutationObserver || global.WebKitMutationObserver;
          var scheduleDrain;
          {
            if (Mutation) {
              var called = 0;
              var observer = new Mutation(nextTick);
              var element = global.document.createTextNode("");
              observer.observe(element, {
                characterData: true
              });
              scheduleDrain = function() {
                element.data = called = ++called % 2;
              };
            } else if (!global.setImmediate && typeof global.MessageChannel !== "undefined") {
              var channel = new global.MessageChannel();
              channel.port1.onmessage = nextTick;
              scheduleDrain = function() {
                channel.port2.postMessage(0);
              };
            } else if ("document" in global && "onreadystatechange" in global.document.createElement("script")) {
              scheduleDrain = function() {
                var scriptEl = global.document.createElement("script");
                scriptEl.onreadystatechange = function() {
                  nextTick();
                  scriptEl.onreadystatechange = null;
                  scriptEl.parentNode.removeChild(scriptEl);
                  scriptEl = null;
                };
                global.document.documentElement.appendChild(scriptEl);
              };
            } else {
              scheduleDrain = function() {
                setTimeout(nextTick, 0);
              };
            }
          }
          var draining;
          var queue = [];
          function nextTick() {
            draining = true;
            var i, oldQueue;
            var len = queue.length;
            while (len) {
              oldQueue = queue;
              queue = [];
              i = -1;
              while (++i < len) {
                oldQueue[i]();
              }
              len = queue.length;
            }
            draining = false;
          }
          module3.exports = immediate;
          function immediate(task) {
            if (queue.push(task) === 1 && !draining) {
              scheduleDrain();
            }
          }
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 2: [function(_dereq_, module3, exports3) {
        "use strict";
        var immediate = _dereq_(1);
        function INTERNAL() {
        }
        var handlers = {};
        var REJECTED = ["REJECTED"];
        var FULFILLED = ["FULFILLED"];
        var PENDING = ["PENDING"];
        module3.exports = Promise2;
        function Promise2(resolver) {
          if (typeof resolver !== "function") {
            throw new TypeError("resolver must be a function");
          }
          this.state = PENDING;
          this.queue = [];
          this.outcome = void 0;
          if (resolver !== INTERNAL) {
            safelyResolveThenable(this, resolver);
          }
        }
        Promise2.prototype["catch"] = function(onRejected) {
          return this.then(null, onRejected);
        };
        Promise2.prototype.then = function(onFulfilled, onRejected) {
          if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
            return this;
          }
          var promise = new this.constructor(INTERNAL);
          if (this.state !== PENDING) {
            var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
            unwrap(promise, resolver, this.outcome);
          } else {
            this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
          }
          return promise;
        };
        function QueueItem(promise, onFulfilled, onRejected) {
          this.promise = promise;
          if (typeof onFulfilled === "function") {
            this.onFulfilled = onFulfilled;
            this.callFulfilled = this.otherCallFulfilled;
          }
          if (typeof onRejected === "function") {
            this.onRejected = onRejected;
            this.callRejected = this.otherCallRejected;
          }
        }
        QueueItem.prototype.callFulfilled = function(value) {
          handlers.resolve(this.promise, value);
        };
        QueueItem.prototype.otherCallFulfilled = function(value) {
          unwrap(this.promise, this.onFulfilled, value);
        };
        QueueItem.prototype.callRejected = function(value) {
          handlers.reject(this.promise, value);
        };
        QueueItem.prototype.otherCallRejected = function(value) {
          unwrap(this.promise, this.onRejected, value);
        };
        function unwrap(promise, func, value) {
          immediate(function() {
            var returnValue;
            try {
              returnValue = func(value);
            } catch (e) {
              return handlers.reject(promise, e);
            }
            if (returnValue === promise) {
              handlers.reject(promise, new TypeError("Cannot resolve promise with itself"));
            } else {
              handlers.resolve(promise, returnValue);
            }
          });
        }
        handlers.resolve = function(self2, value) {
          var result = tryCatch(getThen, value);
          if (result.status === "error") {
            return handlers.reject(self2, result.value);
          }
          var thenable = result.value;
          if (thenable) {
            safelyResolveThenable(self2, thenable);
          } else {
            self2.state = FULFILLED;
            self2.outcome = value;
            var i = -1;
            var len = self2.queue.length;
            while (++i < len) {
              self2.queue[i].callFulfilled(value);
            }
          }
          return self2;
        };
        handlers.reject = function(self2, error) {
          self2.state = REJECTED;
          self2.outcome = error;
          var i = -1;
          var len = self2.queue.length;
          while (++i < len) {
            self2.queue[i].callRejected(error);
          }
          return self2;
        };
        function getThen(obj) {
          var then = obj && obj.then;
          if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
            return function appyThen() {
              then.apply(obj, arguments);
            };
          }
        }
        function safelyResolveThenable(self2, thenable) {
          var called = false;
          function onError(value) {
            if (called) {
              return;
            }
            called = true;
            handlers.reject(self2, value);
          }
          function onSuccess(value) {
            if (called) {
              return;
            }
            called = true;
            handlers.resolve(self2, value);
          }
          function tryToUnwrap() {
            thenable(onSuccess, onError);
          }
          var result = tryCatch(tryToUnwrap);
          if (result.status === "error") {
            onError(result.value);
          }
        }
        function tryCatch(func, value) {
          var out = {};
          try {
            out.value = func(value);
            out.status = "success";
          } catch (e) {
            out.status = "error";
            out.value = e;
          }
          return out;
        }
        Promise2.resolve = resolve;
        function resolve(value) {
          if (value instanceof this) {
            return value;
          }
          return handlers.resolve(new this(INTERNAL), value);
        }
        Promise2.reject = reject;
        function reject(reason) {
          var promise = new this(INTERNAL);
          return handlers.reject(promise, reason);
        }
        Promise2.all = all;
        function all(iterable) {
          var self2 = this;
          if (Object.prototype.toString.call(iterable) !== "[object Array]") {
            return this.reject(new TypeError("must be an array"));
          }
          var len = iterable.length;
          var called = false;
          if (!len) {
            return this.resolve([]);
          }
          var values = new Array(len);
          var resolved = 0;
          var i = -1;
          var promise = new this(INTERNAL);
          while (++i < len) {
            allResolver(iterable[i], i);
          }
          return promise;
          function allResolver(value, i2) {
            self2.resolve(value).then(resolveFromAll, function(error) {
              if (!called) {
                called = true;
                handlers.reject(promise, error);
              }
            });
            function resolveFromAll(outValue) {
              values[i2] = outValue;
              if (++resolved === len && !called) {
                called = true;
                handlers.resolve(promise, values);
              }
            }
          }
        }
        Promise2.race = race;
        function race(iterable) {
          var self2 = this;
          if (Object.prototype.toString.call(iterable) !== "[object Array]") {
            return this.reject(new TypeError("must be an array"));
          }
          var len = iterable.length;
          var called = false;
          if (!len) {
            return this.resolve([]);
          }
          var i = -1;
          var promise = new this(INTERNAL);
          while (++i < len) {
            resolver(iterable[i]);
          }
          return promise;
          function resolver(value) {
            self2.resolve(value).then(function(response) {
              if (!called) {
                called = true;
                handlers.resolve(promise, response);
              }
            }, function(error) {
              if (!called) {
                called = true;
                handlers.reject(promise, error);
              }
            });
          }
        }
      }, { "1": 1 }], 3: [function(_dereq_, module3, exports3) {
        (function(global) {
          "use strict";
          if (typeof global.Promise !== "function") {
            global.Promise = _dereq_(2);
          }
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "2": 2 }], 4: [function(_dereq_, module3, exports3) {
        "use strict";
        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
          return typeof obj;
        } : function(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function getIDB() {
          try {
            if (typeof indexedDB !== "undefined") {
              return indexedDB;
            }
            if (typeof webkitIndexedDB !== "undefined") {
              return webkitIndexedDB;
            }
            if (typeof mozIndexedDB !== "undefined") {
              return mozIndexedDB;
            }
            if (typeof OIndexedDB !== "undefined") {
              return OIndexedDB;
            }
            if (typeof msIndexedDB !== "undefined") {
              return msIndexedDB;
            }
          } catch (e) {
            return;
          }
        }
        var idb = getIDB();
        function isIndexedDBValid() {
          try {
            if (!idb || !idb.open) {
              return false;
            }
            var isSafari = typeof openDatabase !== "undefined" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);
            var hasFetch = typeof fetch === "function" && fetch.toString().indexOf("[native code") !== -1;
            return (!isSafari || hasFetch) && typeof indexedDB !== "undefined" && // some outdated implementations of IDB that appear on Samsung
            // and HTC Android devices <4.4 are missing IDBKeyRange
            // See: https://github.com/mozilla/localForage/issues/128
            // See: https://github.com/mozilla/localForage/issues/272
            typeof IDBKeyRange !== "undefined";
          } catch (e) {
            return false;
          }
        }
        function createBlob(parts, properties) {
          parts = parts || [];
          properties = properties || {};
          try {
            return new Blob(parts, properties);
          } catch (e) {
            if (e.name !== "TypeError") {
              throw e;
            }
            var Builder = typeof BlobBuilder !== "undefined" ? BlobBuilder : typeof MSBlobBuilder !== "undefined" ? MSBlobBuilder : typeof MozBlobBuilder !== "undefined" ? MozBlobBuilder : WebKitBlobBuilder;
            var builder = new Builder();
            for (var i = 0; i < parts.length; i += 1) {
              builder.append(parts[i]);
            }
            return builder.getBlob(properties.type);
          }
        }
        if (typeof Promise === "undefined") {
          _dereq_(3);
        }
        var Promise$1 = Promise;
        function executeCallback(promise, callback) {
          if (callback) {
            promise.then(function(result) {
              callback(null, result);
            }, function(error) {
              callback(error);
            });
          }
        }
        function executeTwoCallbacks(promise, callback, errorCallback) {
          if (typeof callback === "function") {
            promise.then(callback);
          }
          if (typeof errorCallback === "function") {
            promise["catch"](errorCallback);
          }
        }
        function normalizeKey(key2) {
          if (typeof key2 !== "string") {
            console.warn(key2 + " used as a key, but it is not a string.");
            key2 = String(key2);
          }
          return key2;
        }
        function getCallback() {
          if (arguments.length && typeof arguments[arguments.length - 1] === "function") {
            return arguments[arguments.length - 1];
          }
        }
        var DETECT_BLOB_SUPPORT_STORE = "local-forage-detect-blob-support";
        var supportsBlobs = void 0;
        var dbContexts = {};
        var toString = Object.prototype.toString;
        var READ_ONLY = "readonly";
        var READ_WRITE = "readwrite";
        function _binStringToArrayBuffer(bin) {
          var length2 = bin.length;
          var buf = new ArrayBuffer(length2);
          var arr = new Uint8Array(buf);
          for (var i = 0; i < length2; i++) {
            arr[i] = bin.charCodeAt(i);
          }
          return buf;
        }
        function _checkBlobSupportWithoutCaching(idb2) {
          return new Promise$1(function(resolve) {
            var txn = idb2.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
            var blob = createBlob([""]);
            txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, "key");
            txn.onabort = function(e) {
              e.preventDefault();
              e.stopPropagation();
              resolve(false);
            };
            txn.oncomplete = function() {
              var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
              var matchedEdge = navigator.userAgent.match(/Edge\//);
              resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
            };
          })["catch"](function() {
            return false;
          });
        }
        function _checkBlobSupport(idb2) {
          if (typeof supportsBlobs === "boolean") {
            return Promise$1.resolve(supportsBlobs);
          }
          return _checkBlobSupportWithoutCaching(idb2).then(function(value) {
            supportsBlobs = value;
            return supportsBlobs;
          });
        }
        function _deferReadiness(dbInfo) {
          var dbContext = dbContexts[dbInfo.name];
          var deferredOperation = {};
          deferredOperation.promise = new Promise$1(function(resolve, reject) {
            deferredOperation.resolve = resolve;
            deferredOperation.reject = reject;
          });
          dbContext.deferredOperations.push(deferredOperation);
          if (!dbContext.dbReady) {
            dbContext.dbReady = deferredOperation.promise;
          } else {
            dbContext.dbReady = dbContext.dbReady.then(function() {
              return deferredOperation.promise;
            });
          }
        }
        function _advanceReadiness(dbInfo) {
          var dbContext = dbContexts[dbInfo.name];
          var deferredOperation = dbContext.deferredOperations.pop();
          if (deferredOperation) {
            deferredOperation.resolve();
            return deferredOperation.promise;
          }
        }
        function _rejectReadiness(dbInfo, err) {
          var dbContext = dbContexts[dbInfo.name];
          var deferredOperation = dbContext.deferredOperations.pop();
          if (deferredOperation) {
            deferredOperation.reject(err);
            return deferredOperation.promise;
          }
        }
        function _getConnection(dbInfo, upgradeNeeded) {
          return new Promise$1(function(resolve, reject) {
            dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();
            if (dbInfo.db) {
              if (upgradeNeeded) {
                _deferReadiness(dbInfo);
                dbInfo.db.close();
              } else {
                return resolve(dbInfo.db);
              }
            }
            var dbArgs = [dbInfo.name];
            if (upgradeNeeded) {
              dbArgs.push(dbInfo.version);
            }
            var openreq = idb.open.apply(idb, dbArgs);
            if (upgradeNeeded) {
              openreq.onupgradeneeded = function(e) {
                var db = openreq.result;
                try {
                  db.createObjectStore(dbInfo.storeName);
                  if (e.oldVersion <= 1) {
                    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                  }
                } catch (ex) {
                  if (ex.name === "ConstraintError") {
                    console.warn('The database "' + dbInfo.name + '" has been upgraded from version ' + e.oldVersion + " to version " + e.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                  } else {
                    throw ex;
                  }
                }
              };
            }
            openreq.onerror = function(e) {
              e.preventDefault();
              reject(openreq.error);
            };
            openreq.onsuccess = function() {
              var db = openreq.result;
              db.onversionchange = function(e) {
                e.target.close();
              };
              resolve(db);
              _advanceReadiness(dbInfo);
            };
          });
        }
        function _getOriginalConnection(dbInfo) {
          return _getConnection(dbInfo, false);
        }
        function _getUpgradedConnection(dbInfo) {
          return _getConnection(dbInfo, true);
        }
        function _isUpgradeNeeded(dbInfo, defaultVersion) {
          if (!dbInfo.db) {
            return true;
          }
          var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
          var isDowngrade = dbInfo.version < dbInfo.db.version;
          var isUpgrade = dbInfo.version > dbInfo.db.version;
          if (isDowngrade) {
            if (dbInfo.version !== defaultVersion) {
              console.warn('The database "' + dbInfo.name + `" can't be downgraded from version ` + dbInfo.db.version + " to version " + dbInfo.version + ".");
            }
            dbInfo.version = dbInfo.db.version;
          }
          if (isUpgrade || isNewStore) {
            if (isNewStore) {
              var incVersion = dbInfo.db.version + 1;
              if (incVersion > dbInfo.version) {
                dbInfo.version = incVersion;
              }
            }
            return true;
          }
          return false;
        }
        function _encodeBlob(blob) {
          return new Promise$1(function(resolve, reject) {
            var reader = new FileReader();
            reader.onerror = reject;
            reader.onloadend = function(e) {
              var base64 = btoa(e.target.result || "");
              resolve({
                __local_forage_encoded_blob: true,
                data: base64,
                type: blob.type
              });
            };
            reader.readAsBinaryString(blob);
          });
        }
        function _decodeBlob(encodedBlob) {
          var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
          return createBlob([arrayBuff], { type: encodedBlob.type });
        }
        function _isEncodedBlob(value) {
          return value && value.__local_forage_encoded_blob;
        }
        function _fullyReady(callback) {
          var self2 = this;
          var promise = self2._initReady().then(function() {
            var dbContext = dbContexts[self2._dbInfo.name];
            if (dbContext && dbContext.dbReady) {
              return dbContext.dbReady;
            }
          });
          executeTwoCallbacks(promise, callback, callback);
          return promise;
        }
        function _tryReconnect(dbInfo) {
          _deferReadiness(dbInfo);
          var dbContext = dbContexts[dbInfo.name];
          var forages = dbContext.forages;
          for (var i = 0; i < forages.length; i++) {
            var forage = forages[i];
            if (forage._dbInfo.db) {
              forage._dbInfo.db.close();
              forage._dbInfo.db = null;
            }
          }
          dbInfo.db = null;
          return _getOriginalConnection(dbInfo).then(function(db) {
            dbInfo.db = db;
            if (_isUpgradeNeeded(dbInfo)) {
              return _getUpgradedConnection(dbInfo);
            }
            return db;
          }).then(function(db) {
            dbInfo.db = dbContext.db = db;
            for (var i2 = 0; i2 < forages.length; i2++) {
              forages[i2]._dbInfo.db = db;
            }
          })["catch"](function(err) {
            _rejectReadiness(dbInfo, err);
            throw err;
          });
        }
        function createTransaction(dbInfo, mode, callback, retries) {
          if (retries === void 0) {
            retries = 1;
          }
          try {
            var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
            callback(null, tx);
          } catch (err) {
            if (retries > 0 && (!dbInfo.db || err.name === "InvalidStateError" || err.name === "NotFoundError")) {
              return Promise$1.resolve().then(function() {
                if (!dbInfo.db || err.name === "NotFoundError" && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
                  if (dbInfo.db) {
                    dbInfo.version = dbInfo.db.version + 1;
                  }
                  return _getUpgradedConnection(dbInfo);
                }
              }).then(function() {
                return _tryReconnect(dbInfo).then(function() {
                  createTransaction(dbInfo, mode, callback, retries - 1);
                });
              })["catch"](callback);
            }
            callback(err);
          }
        }
        function createDbContext() {
          return {
            // Running localForages sharing a database.
            forages: [],
            // Shared database.
            db: null,
            // Database readiness (promise).
            dbReady: null,
            // Deferred operations on the database.
            deferredOperations: []
          };
        }
        function _initStorage(options) {
          var self2 = this;
          var dbInfo = {
            db: null
          };
          if (options) {
            for (var i in options) {
              dbInfo[i] = options[i];
            }
          }
          var dbContext = dbContexts[dbInfo.name];
          if (!dbContext) {
            dbContext = createDbContext();
            dbContexts[dbInfo.name] = dbContext;
          }
          dbContext.forages.push(self2);
          if (!self2._initReady) {
            self2._initReady = self2.ready;
            self2.ready = _fullyReady;
          }
          var initPromises = [];
          function ignoreErrors() {
            return Promise$1.resolve();
          }
          for (var j = 0; j < dbContext.forages.length; j++) {
            var forage = dbContext.forages[j];
            if (forage !== self2) {
              initPromises.push(forage._initReady()["catch"](ignoreErrors));
            }
          }
          var forages = dbContext.forages.slice(0);
          return Promise$1.all(initPromises).then(function() {
            dbInfo.db = dbContext.db;
            return _getOriginalConnection(dbInfo);
          }).then(function(db) {
            dbInfo.db = db;
            if (_isUpgradeNeeded(dbInfo, self2._defaultConfig.version)) {
              return _getUpgradedConnection(dbInfo);
            }
            return db;
          }).then(function(db) {
            dbInfo.db = dbContext.db = db;
            self2._dbInfo = dbInfo;
            for (var k = 0; k < forages.length; k++) {
              var forage2 = forages[k];
              if (forage2 !== self2) {
                forage2._dbInfo.db = dbInfo.db;
                forage2._dbInfo.version = dbInfo.version;
              }
            }
          });
        }
        function getItem(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.get(key2);
                  req.onsuccess = function() {
                    var value = req.result;
                    if (value === void 0) {
                      value = null;
                    }
                    if (_isEncodedBlob(value)) {
                      value = _decodeBlob(value);
                    }
                    resolve(value);
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function iterate(iterator, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.openCursor();
                  var iterationNumber = 1;
                  req.onsuccess = function() {
                    var cursor = req.result;
                    if (cursor) {
                      var value = cursor.value;
                      if (_isEncodedBlob(value)) {
                        value = _decodeBlob(value);
                      }
                      var result = iterator(value, cursor.key, iterationNumber++);
                      if (result !== void 0) {
                        resolve(result);
                      } else {
                        cursor["continue"]();
                      }
                    } else {
                      resolve();
                    }
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function setItem(key2, value, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            var dbInfo;
            self2.ready().then(function() {
              dbInfo = self2._dbInfo;
              if (toString.call(value) === "[object Blob]") {
                return _checkBlobSupport(dbInfo.db).then(function(blobSupport) {
                  if (blobSupport) {
                    return value;
                  }
                  return _encodeBlob(value);
                });
              }
              return value;
            }).then(function(value2) {
              createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  if (value2 === null) {
                    value2 = void 0;
                  }
                  var req = store.put(value2, key2);
                  transaction.oncomplete = function() {
                    if (value2 === void 0) {
                      value2 = null;
                    }
                    resolve(value2);
                  };
                  transaction.onabort = transaction.onerror = function() {
                    var err2 = req.error ? req.error : req.transaction.error;
                    reject(err2);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function removeItem(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store["delete"](key2);
                  transaction.oncomplete = function() {
                    resolve();
                  };
                  transaction.onerror = function() {
                    reject(req.error);
                  };
                  transaction.onabort = function() {
                    var err2 = req.error ? req.error : req.transaction.error;
                    reject(err2);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function clear(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.clear();
                  transaction.oncomplete = function() {
                    resolve();
                  };
                  transaction.onabort = transaction.onerror = function() {
                    var err2 = req.error ? req.error : req.transaction.error;
                    reject(err2);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function length(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.count();
                  req.onsuccess = function() {
                    resolve(req.result);
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function key(n, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            if (n < 0) {
              resolve(null);
              return;
            }
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var advanced = false;
                  var req = store.openKeyCursor();
                  req.onsuccess = function() {
                    var cursor = req.result;
                    if (!cursor) {
                      resolve(null);
                      return;
                    }
                    if (n === 0) {
                      resolve(cursor.key);
                    } else {
                      if (!advanced) {
                        advanced = true;
                        cursor.advance(n);
                      } else {
                        resolve(cursor.key);
                      }
                    }
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function keys(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.openKeyCursor();
                  var keys2 = [];
                  req.onsuccess = function() {
                    var cursor = req.result;
                    if (!cursor) {
                      resolve(keys2);
                      return;
                    }
                    keys2.push(cursor.key);
                    cursor["continue"]();
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function dropInstance(options, callback) {
          callback = getCallback.apply(this, arguments);
          var currentConfig = this.config();
          options = typeof options !== "function" && options || {};
          if (!options.name) {
            options.name = options.name || currentConfig.name;
            options.storeName = options.storeName || currentConfig.storeName;
          }
          var self2 = this;
          var promise;
          if (!options.name) {
            promise = Promise$1.reject("Invalid arguments");
          } else {
            var isCurrentDb = options.name === currentConfig.name && self2._dbInfo.db;
            var dbPromise = isCurrentDb ? Promise$1.resolve(self2._dbInfo.db) : _getOriginalConnection(options).then(function(db) {
              var dbContext = dbContexts[options.name];
              var forages = dbContext.forages;
              dbContext.db = db;
              for (var i = 0; i < forages.length; i++) {
                forages[i]._dbInfo.db = db;
              }
              return db;
            });
            if (!options.storeName) {
              promise = dbPromise.then(function(db) {
                _deferReadiness(options);
                var dbContext = dbContexts[options.name];
                var forages = dbContext.forages;
                db.close();
                for (var i = 0; i < forages.length; i++) {
                  var forage = forages[i];
                  forage._dbInfo.db = null;
                }
                var dropDBPromise = new Promise$1(function(resolve, reject) {
                  var req = idb.deleteDatabase(options.name);
                  req.onerror = function() {
                    var db2 = req.result;
                    if (db2) {
                      db2.close();
                    }
                    reject(req.error);
                  };
                  req.onblocked = function() {
                    console.warn('dropInstance blocked for database "' + options.name + '" until all open connections are closed');
                  };
                  req.onsuccess = function() {
                    var db2 = req.result;
                    if (db2) {
                      db2.close();
                    }
                    resolve(db2);
                  };
                });
                return dropDBPromise.then(function(db2) {
                  dbContext.db = db2;
                  for (var i2 = 0; i2 < forages.length; i2++) {
                    var _forage = forages[i2];
                    _advanceReadiness(_forage._dbInfo);
                  }
                })["catch"](function(err) {
                  (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function() {
                  });
                  throw err;
                });
              });
            } else {
              promise = dbPromise.then(function(db) {
                if (!db.objectStoreNames.contains(options.storeName)) {
                  return;
                }
                var newVersion = db.version + 1;
                _deferReadiness(options);
                var dbContext = dbContexts[options.name];
                var forages = dbContext.forages;
                db.close();
                for (var i = 0; i < forages.length; i++) {
                  var forage = forages[i];
                  forage._dbInfo.db = null;
                  forage._dbInfo.version = newVersion;
                }
                var dropObjectPromise = new Promise$1(function(resolve, reject) {
                  var req = idb.open(options.name, newVersion);
                  req.onerror = function(err) {
                    var db2 = req.result;
                    db2.close();
                    reject(err);
                  };
                  req.onupgradeneeded = function() {
                    var db2 = req.result;
                    db2.deleteObjectStore(options.storeName);
                  };
                  req.onsuccess = function() {
                    var db2 = req.result;
                    db2.close();
                    resolve(db2);
                  };
                });
                return dropObjectPromise.then(function(db2) {
                  dbContext.db = db2;
                  for (var j = 0; j < forages.length; j++) {
                    var _forage2 = forages[j];
                    _forage2._dbInfo.db = db2;
                    _advanceReadiness(_forage2._dbInfo);
                  }
                })["catch"](function(err) {
                  (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function() {
                  });
                  throw err;
                });
              });
            }
          }
          executeCallback(promise, callback);
          return promise;
        }
        var asyncStorage = {
          _driver: "asyncStorage",
          _initStorage,
          _support: isIndexedDBValid(),
          iterate,
          getItem,
          setItem,
          removeItem,
          clear,
          length,
          key,
          keys,
          dropInstance
        };
        function isWebSQLValid() {
          return typeof openDatabase === "function";
        }
        var BASE_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var BLOB_TYPE_PREFIX = "~~local_forage_type~";
        var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;
        var SERIALIZED_MARKER = "__lfsc__:";
        var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;
        var TYPE_ARRAYBUFFER = "arbf";
        var TYPE_BLOB = "blob";
        var TYPE_INT8ARRAY = "si08";
        var TYPE_UINT8ARRAY = "ui08";
        var TYPE_UINT8CLAMPEDARRAY = "uic8";
        var TYPE_INT16ARRAY = "si16";
        var TYPE_INT32ARRAY = "si32";
        var TYPE_UINT16ARRAY = "ur16";
        var TYPE_UINT32ARRAY = "ui32";
        var TYPE_FLOAT32ARRAY = "fl32";
        var TYPE_FLOAT64ARRAY = "fl64";
        var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;
        var toString$1 = Object.prototype.toString;
        function stringToBuffer(serializedString) {
          var bufferLength = serializedString.length * 0.75;
          var len = serializedString.length;
          var i;
          var p = 0;
          var encoded1, encoded2, encoded3, encoded4;
          if (serializedString[serializedString.length - 1] === "=") {
            bufferLength--;
            if (serializedString[serializedString.length - 2] === "=") {
              bufferLength--;
            }
          }
          var buffer = new ArrayBuffer(bufferLength);
          var bytes = new Uint8Array(buffer);
          for (i = 0; i < len; i += 4) {
            encoded1 = BASE_CHARS.indexOf(serializedString[i]);
            encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);
            encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);
            encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);
            bytes[p++] = encoded1 << 2 | encoded2 >> 4;
            bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
            bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
          }
          return buffer;
        }
        function bufferToString(buffer) {
          var bytes = new Uint8Array(buffer);
          var base64String = "";
          var i;
          for (i = 0; i < bytes.length; i += 3) {
            base64String += BASE_CHARS[bytes[i] >> 2];
            base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
            base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
            base64String += BASE_CHARS[bytes[i + 2] & 63];
          }
          if (bytes.length % 3 === 2) {
            base64String = base64String.substring(0, base64String.length - 1) + "=";
          } else if (bytes.length % 3 === 1) {
            base64String = base64String.substring(0, base64String.length - 2) + "==";
          }
          return base64String;
        }
        function serialize(value, callback) {
          var valueType = "";
          if (value) {
            valueType = toString$1.call(value);
          }
          if (value && (valueType === "[object ArrayBuffer]" || value.buffer && toString$1.call(value.buffer) === "[object ArrayBuffer]")) {
            var buffer;
            var marker = SERIALIZED_MARKER;
            if (value instanceof ArrayBuffer) {
              buffer = value;
              marker += TYPE_ARRAYBUFFER;
            } else {
              buffer = value.buffer;
              if (valueType === "[object Int8Array]") {
                marker += TYPE_INT8ARRAY;
              } else if (valueType === "[object Uint8Array]") {
                marker += TYPE_UINT8ARRAY;
              } else if (valueType === "[object Uint8ClampedArray]") {
                marker += TYPE_UINT8CLAMPEDARRAY;
              } else if (valueType === "[object Int16Array]") {
                marker += TYPE_INT16ARRAY;
              } else if (valueType === "[object Uint16Array]") {
                marker += TYPE_UINT16ARRAY;
              } else if (valueType === "[object Int32Array]") {
                marker += TYPE_INT32ARRAY;
              } else if (valueType === "[object Uint32Array]") {
                marker += TYPE_UINT32ARRAY;
              } else if (valueType === "[object Float32Array]") {
                marker += TYPE_FLOAT32ARRAY;
              } else if (valueType === "[object Float64Array]") {
                marker += TYPE_FLOAT64ARRAY;
              } else {
                callback(new Error("Failed to get type for BinaryArray"));
              }
            }
            callback(marker + bufferToString(buffer));
          } else if (valueType === "[object Blob]") {
            var fileReader = new FileReader();
            fileReader.onload = function() {
              var str = BLOB_TYPE_PREFIX + value.type + "~" + bufferToString(this.result);
              callback(SERIALIZED_MARKER + TYPE_BLOB + str);
            };
            fileReader.readAsArrayBuffer(value);
          } else {
            try {
              callback(JSON.stringify(value));
            } catch (e) {
              console.error("Couldn't convert value into a JSON string: ", value);
              callback(null, e);
            }
          }
        }
        function deserialize(value) {
          if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
            return JSON.parse(value);
          }
          var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
          var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);
          var blobType;
          if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
            var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
            blobType = matcher[1];
            serializedString = serializedString.substring(matcher[0].length);
          }
          var buffer = stringToBuffer(serializedString);
          switch (type) {
            case TYPE_ARRAYBUFFER:
              return buffer;
            case TYPE_BLOB:
              return createBlob([buffer], { type: blobType });
            case TYPE_INT8ARRAY:
              return new Int8Array(buffer);
            case TYPE_UINT8ARRAY:
              return new Uint8Array(buffer);
            case TYPE_UINT8CLAMPEDARRAY:
              return new Uint8ClampedArray(buffer);
            case TYPE_INT16ARRAY:
              return new Int16Array(buffer);
            case TYPE_UINT16ARRAY:
              return new Uint16Array(buffer);
            case TYPE_INT32ARRAY:
              return new Int32Array(buffer);
            case TYPE_UINT32ARRAY:
              return new Uint32Array(buffer);
            case TYPE_FLOAT32ARRAY:
              return new Float32Array(buffer);
            case TYPE_FLOAT64ARRAY:
              return new Float64Array(buffer);
            default:
              throw new Error("Unkown type: " + type);
          }
        }
        var localforageSerializer = {
          serialize,
          deserialize,
          stringToBuffer,
          bufferToString
        };
        function createDbTable(t, dbInfo, callback, errorCallback) {
          t.executeSql("CREATE TABLE IF NOT EXISTS " + dbInfo.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], callback, errorCallback);
        }
        function _initStorage$1(options) {
          var self2 = this;
          var dbInfo = {
            db: null
          };
          if (options) {
            for (var i in options) {
              dbInfo[i] = typeof options[i] !== "string" ? options[i].toString() : options[i];
            }
          }
          var dbInfoPromise = new Promise$1(function(resolve, reject) {
            try {
              dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
            } catch (e) {
              return reject(e);
            }
            dbInfo.db.transaction(function(t) {
              createDbTable(t, dbInfo, function() {
                self2._dbInfo = dbInfo;
                resolve();
              }, function(t2, error) {
                reject(error);
              });
            }, reject);
          });
          dbInfo.serializer = localforageSerializer;
          return dbInfoPromise;
        }
        function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {
          t.executeSql(sqlStatement, args, callback, function(t2, error) {
            if (error.code === error.SYNTAX_ERR) {
              t2.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [dbInfo.storeName], function(t3, results) {
                if (!results.rows.length) {
                  createDbTable(t3, dbInfo, function() {
                    t3.executeSql(sqlStatement, args, callback, errorCallback);
                  }, errorCallback);
                } else {
                  errorCallback(t3, error);
                }
              }, errorCallback);
            } else {
              errorCallback(t2, error);
            }
          }, errorCallback);
        }
        function getItem$1(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "SELECT * FROM " + dbInfo.storeName + " WHERE key = ? LIMIT 1", [key2], function(t2, results) {
                  var result = results.rows.length ? results.rows.item(0).value : null;
                  if (result) {
                    result = dbInfo.serializer.deserialize(result);
                  }
                  resolve(result);
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function iterate$1(iterator, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "SELECT * FROM " + dbInfo.storeName, [], function(t2, results) {
                  var rows = results.rows;
                  var length2 = rows.length;
                  for (var i = 0; i < length2; i++) {
                    var item = rows.item(i);
                    var result = item.value;
                    if (result) {
                      result = dbInfo.serializer.deserialize(result);
                    }
                    result = iterator(result, item.key, i + 1);
                    if (result !== void 0) {
                      resolve(result);
                      return;
                    }
                  }
                  resolve();
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function _setItem(key2, value, callback, retriesLeft) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              if (value === void 0) {
                value = null;
              }
              var originalValue = value;
              var dbInfo = self2._dbInfo;
              dbInfo.serializer.serialize(value, function(value2, error) {
                if (error) {
                  reject(error);
                } else {
                  dbInfo.db.transaction(function(t) {
                    tryExecuteSql(t, dbInfo, "INSERT OR REPLACE INTO " + dbInfo.storeName + " (key, value) VALUES (?, ?)", [key2, value2], function() {
                      resolve(originalValue);
                    }, function(t2, error2) {
                      reject(error2);
                    });
                  }, function(sqlError) {
                    if (sqlError.code === sqlError.QUOTA_ERR) {
                      if (retriesLeft > 0) {
                        resolve(_setItem.apply(self2, [key2, originalValue, callback, retriesLeft - 1]));
                        return;
                      }
                      reject(sqlError);
                    }
                  });
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function setItem$1(key2, value, callback) {
          return _setItem.apply(this, [key2, value, callback, 1]);
        }
        function removeItem$1(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "DELETE FROM " + dbInfo.storeName + " WHERE key = ?", [key2], function() {
                  resolve();
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function clear$1(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "DELETE FROM " + dbInfo.storeName, [], function() {
                  resolve();
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function length$1(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "SELECT COUNT(key) as c FROM " + dbInfo.storeName, [], function(t2, results) {
                  var result = results.rows.item(0).c;
                  resolve(result);
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function key$1(n, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "SELECT key FROM " + dbInfo.storeName + " WHERE id = ? LIMIT 1", [n + 1], function(t2, results) {
                  var result = results.rows.length ? results.rows.item(0).key : null;
                  resolve(result);
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function keys$1(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "SELECT key FROM " + dbInfo.storeName, [], function(t2, results) {
                  var keys2 = [];
                  for (var i = 0; i < results.rows.length; i++) {
                    keys2.push(results.rows.item(i).key);
                  }
                  resolve(keys2);
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function getAllStoreNames(db) {
          return new Promise$1(function(resolve, reject) {
            db.transaction(function(t) {
              t.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(t2, results) {
                var storeNames = [];
                for (var i = 0; i < results.rows.length; i++) {
                  storeNames.push(results.rows.item(i).name);
                }
                resolve({
                  db,
                  storeNames
                });
              }, function(t2, error) {
                reject(error);
              });
            }, function(sqlError) {
              reject(sqlError);
            });
          });
        }
        function dropInstance$1(options, callback) {
          callback = getCallback.apply(this, arguments);
          var currentConfig = this.config();
          options = typeof options !== "function" && options || {};
          if (!options.name) {
            options.name = options.name || currentConfig.name;
            options.storeName = options.storeName || currentConfig.storeName;
          }
          var self2 = this;
          var promise;
          if (!options.name) {
            promise = Promise$1.reject("Invalid arguments");
          } else {
            promise = new Promise$1(function(resolve) {
              var db;
              if (options.name === currentConfig.name) {
                db = self2._dbInfo.db;
              } else {
                db = openDatabase(options.name, "", "", 0);
              }
              if (!options.storeName) {
                resolve(getAllStoreNames(db));
              } else {
                resolve({
                  db,
                  storeNames: [options.storeName]
                });
              }
            }).then(function(operationInfo) {
              return new Promise$1(function(resolve, reject) {
                operationInfo.db.transaction(function(t) {
                  function dropTable(storeName) {
                    return new Promise$1(function(resolve2, reject2) {
                      t.executeSql("DROP TABLE IF EXISTS " + storeName, [], function() {
                        resolve2();
                      }, function(t2, error) {
                        reject2(error);
                      });
                    });
                  }
                  var operations = [];
                  for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {
                    operations.push(dropTable(operationInfo.storeNames[i]));
                  }
                  Promise$1.all(operations).then(function() {
                    resolve();
                  })["catch"](function(e) {
                    reject(e);
                  });
                }, function(sqlError) {
                  reject(sqlError);
                });
              });
            });
          }
          executeCallback(promise, callback);
          return promise;
        }
        var webSQLStorage = {
          _driver: "webSQLStorage",
          _initStorage: _initStorage$1,
          _support: isWebSQLValid(),
          iterate: iterate$1,
          getItem: getItem$1,
          setItem: setItem$1,
          removeItem: removeItem$1,
          clear: clear$1,
          length: length$1,
          key: key$1,
          keys: keys$1,
          dropInstance: dropInstance$1
        };
        function isLocalStorageValid() {
          try {
            return typeof localStorage !== "undefined" && "setItem" in localStorage && // in IE8 typeof localStorage.setItem === 'object'
            !!localStorage.setItem;
          } catch (e) {
            return false;
          }
        }
        function _getKeyPrefix(options, defaultConfig) {
          var keyPrefix = options.name + "/";
          if (options.storeName !== defaultConfig.storeName) {
            keyPrefix += options.storeName + "/";
          }
          return keyPrefix;
        }
        function checkIfLocalStorageThrows() {
          var localStorageTestKey = "_localforage_support_test";
          try {
            localStorage.setItem(localStorageTestKey, true);
            localStorage.removeItem(localStorageTestKey);
            return false;
          } catch (e) {
            return true;
          }
        }
        function _isLocalStorageUsable() {
          return !checkIfLocalStorageThrows() || localStorage.length > 0;
        }
        function _initStorage$2(options) {
          var self2 = this;
          var dbInfo = {};
          if (options) {
            for (var i in options) {
              dbInfo[i] = options[i];
            }
          }
          dbInfo.keyPrefix = _getKeyPrefix(options, self2._defaultConfig);
          if (!_isLocalStorageUsable()) {
            return Promise$1.reject();
          }
          self2._dbInfo = dbInfo;
          dbInfo.serializer = localforageSerializer;
          return Promise$1.resolve();
        }
        function clear$2(callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var keyPrefix = self2._dbInfo.keyPrefix;
            for (var i = localStorage.length - 1; i >= 0; i--) {
              var key2 = localStorage.key(i);
              if (key2.indexOf(keyPrefix) === 0) {
                localStorage.removeItem(key2);
              }
            }
          });
          executeCallback(promise, callback);
          return promise;
        }
        function getItem$2(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var result = localStorage.getItem(dbInfo.keyPrefix + key2);
            if (result) {
              result = dbInfo.serializer.deserialize(result);
            }
            return result;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function iterate$2(iterator, callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var keyPrefix = dbInfo.keyPrefix;
            var keyPrefixLength = keyPrefix.length;
            var length2 = localStorage.length;
            var iterationNumber = 1;
            for (var i = 0; i < length2; i++) {
              var key2 = localStorage.key(i);
              if (key2.indexOf(keyPrefix) !== 0) {
                continue;
              }
              var value = localStorage.getItem(key2);
              if (value) {
                value = dbInfo.serializer.deserialize(value);
              }
              value = iterator(value, key2.substring(keyPrefixLength), iterationNumber++);
              if (value !== void 0) {
                return value;
              }
            }
          });
          executeCallback(promise, callback);
          return promise;
        }
        function key$2(n, callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var result;
            try {
              result = localStorage.key(n);
            } catch (error) {
              result = null;
            }
            if (result) {
              result = result.substring(dbInfo.keyPrefix.length);
            }
            return result;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function keys$2(callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var length2 = localStorage.length;
            var keys2 = [];
            for (var i = 0; i < length2; i++) {
              var itemKey = localStorage.key(i);
              if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
                keys2.push(itemKey.substring(dbInfo.keyPrefix.length));
              }
            }
            return keys2;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function length$2(callback) {
          var self2 = this;
          var promise = self2.keys().then(function(keys2) {
            return keys2.length;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function removeItem$2(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            localStorage.removeItem(dbInfo.keyPrefix + key2);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function setItem$2(key2, value, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = self2.ready().then(function() {
            if (value === void 0) {
              value = null;
            }
            var originalValue = value;
            return new Promise$1(function(resolve, reject) {
              var dbInfo = self2._dbInfo;
              dbInfo.serializer.serialize(value, function(value2, error) {
                if (error) {
                  reject(error);
                } else {
                  try {
                    localStorage.setItem(dbInfo.keyPrefix + key2, value2);
                    resolve(originalValue);
                  } catch (e) {
                    if (e.name === "QuotaExceededError" || e.name === "NS_ERROR_DOM_QUOTA_REACHED") {
                      reject(e);
                    }
                    reject(e);
                  }
                }
              });
            });
          });
          executeCallback(promise, callback);
          return promise;
        }
        function dropInstance$2(options, callback) {
          callback = getCallback.apply(this, arguments);
          options = typeof options !== "function" && options || {};
          if (!options.name) {
            var currentConfig = this.config();
            options.name = options.name || currentConfig.name;
            options.storeName = options.storeName || currentConfig.storeName;
          }
          var self2 = this;
          var promise;
          if (!options.name) {
            promise = Promise$1.reject("Invalid arguments");
          } else {
            promise = new Promise$1(function(resolve) {
              if (!options.storeName) {
                resolve(options.name + "/");
              } else {
                resolve(_getKeyPrefix(options, self2._defaultConfig));
              }
            }).then(function(keyPrefix) {
              for (var i = localStorage.length - 1; i >= 0; i--) {
                var key2 = localStorage.key(i);
                if (key2.indexOf(keyPrefix) === 0) {
                  localStorage.removeItem(key2);
                }
              }
            });
          }
          executeCallback(promise, callback);
          return promise;
        }
        var localStorageWrapper = {
          _driver: "localStorageWrapper",
          _initStorage: _initStorage$2,
          _support: isLocalStorageValid(),
          iterate: iterate$2,
          getItem: getItem$2,
          setItem: setItem$2,
          removeItem: removeItem$2,
          clear: clear$2,
          length: length$2,
          key: key$2,
          keys: keys$2,
          dropInstance: dropInstance$2
        };
        var sameValue = function sameValue2(x, y) {
          return x === y || typeof x === "number" && typeof y === "number" && isNaN(x) && isNaN(y);
        };
        var includes = function includes2(array, searchElement) {
          var len = array.length;
          var i = 0;
          while (i < len) {
            if (sameValue(array[i], searchElement)) {
              return true;
            }
            i++;
          }
          return false;
        };
        var isArray = Array.isArray || function(arg) {
          return Object.prototype.toString.call(arg) === "[object Array]";
        };
        var DefinedDrivers = {};
        var DriverSupport = {};
        var DefaultDrivers = {
          INDEXEDDB: asyncStorage,
          WEBSQL: webSQLStorage,
          LOCALSTORAGE: localStorageWrapper
        };
        var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];
        var OptionalDriverMethods = ["dropInstance"];
        var LibraryMethods = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(OptionalDriverMethods);
        var DefaultConfig = {
          description: "",
          driver: DefaultDriverOrder.slice(),
          name: "localforage",
          // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
          // we can use without a prompt.
          size: 4980736,
          storeName: "keyvaluepairs",
          version: 1
        };
        function callWhenReady(localForageInstance, libraryMethod) {
          localForageInstance[libraryMethod] = function() {
            var _args = arguments;
            return localForageInstance.ready().then(function() {
              return localForageInstance[libraryMethod].apply(localForageInstance, _args);
            });
          };
        }
        function extend() {
          for (var i = 1; i < arguments.length; i++) {
            var arg = arguments[i];
            if (arg) {
              for (var _key in arg) {
                if (arg.hasOwnProperty(_key)) {
                  if (isArray(arg[_key])) {
                    arguments[0][_key] = arg[_key].slice();
                  } else {
                    arguments[0][_key] = arg[_key];
                  }
                }
              }
            }
          }
          return arguments[0];
        }
        var LocalForage = function() {
          function LocalForage2(options) {
            _classCallCheck(this, LocalForage2);
            for (var driverTypeKey in DefaultDrivers) {
              if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
                var driver = DefaultDrivers[driverTypeKey];
                var driverName = driver._driver;
                this[driverTypeKey] = driverName;
                if (!DefinedDrivers[driverName]) {
                  this.defineDriver(driver);
                }
              }
            }
            this._defaultConfig = extend({}, DefaultConfig);
            this._config = extend({}, this._defaultConfig, options);
            this._driverSet = null;
            this._initDriver = null;
            this._ready = false;
            this._dbInfo = null;
            this._wrapLibraryMethodsWithReady();
            this.setDriver(this._config.driver)["catch"](function() {
            });
          }
          LocalForage2.prototype.config = function config(options) {
            if ((typeof options === "undefined" ? "undefined" : _typeof(options)) === "object") {
              if (this._ready) {
                return new Error("Can't call config() after localforage has been used.");
              }
              for (var i in options) {
                if (i === "storeName") {
                  options[i] = options[i].replace(/\W/g, "_");
                }
                if (i === "version" && typeof options[i] !== "number") {
                  return new Error("Database version must be a number.");
                }
                this._config[i] = options[i];
              }
              if ("driver" in options && options.driver) {
                return this.setDriver(this._config.driver);
              }
              return true;
            } else if (typeof options === "string") {
              return this._config[options];
            } else {
              return this._config;
            }
          };
          LocalForage2.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
            var promise = new Promise$1(function(resolve, reject) {
              try {
                var driverName = driverObject._driver;
                var complianceError = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
                if (!driverObject._driver) {
                  reject(complianceError);
                  return;
                }
                var driverMethods = LibraryMethods.concat("_initStorage");
                for (var i = 0, len = driverMethods.length; i < len; i++) {
                  var driverMethodName = driverMethods[i];
                  var isRequired = !includes(OptionalDriverMethods, driverMethodName);
                  if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== "function") {
                    reject(complianceError);
                    return;
                  }
                }
                var configureMissingMethods = function configureMissingMethods2() {
                  var methodNotImplementedFactory = function methodNotImplementedFactory2(methodName) {
                    return function() {
                      var error = new Error("Method " + methodName + " is not implemented by the current driver");
                      var promise2 = Promise$1.reject(error);
                      executeCallback(promise2, arguments[arguments.length - 1]);
                      return promise2;
                    };
                  };
                  for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                    var optionalDriverMethod = OptionalDriverMethods[_i];
                    if (!driverObject[optionalDriverMethod]) {
                      driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
                    }
                  }
                };
                configureMissingMethods();
                var setDriverSupport = function setDriverSupport2(support) {
                  if (DefinedDrivers[driverName]) {
                    console.info("Redefining LocalForage driver: " + driverName);
                  }
                  DefinedDrivers[driverName] = driverObject;
                  DriverSupport[driverName] = support;
                  resolve();
                };
                if ("_support" in driverObject) {
                  if (driverObject._support && typeof driverObject._support === "function") {
                    driverObject._support().then(setDriverSupport, reject);
                  } else {
                    setDriverSupport(!!driverObject._support);
                  }
                } else {
                  setDriverSupport(true);
                }
              } catch (e) {
                reject(e);
              }
            });
            executeTwoCallbacks(promise, callback, errorCallback);
            return promise;
          };
          LocalForage2.prototype.driver = function driver() {
            return this._driver || null;
          };
          LocalForage2.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
            var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error("Driver not found."));
            executeTwoCallbacks(getDriverPromise, callback, errorCallback);
            return getDriverPromise;
          };
          LocalForage2.prototype.getSerializer = function getSerializer(callback) {
            var serializerPromise = Promise$1.resolve(localforageSerializer);
            executeTwoCallbacks(serializerPromise, callback);
            return serializerPromise;
          };
          LocalForage2.prototype.ready = function ready(callback) {
            var self2 = this;
            var promise = self2._driverSet.then(function() {
              if (self2._ready === null) {
                self2._ready = self2._initDriver();
              }
              return self2._ready;
            });
            executeTwoCallbacks(promise, callback, callback);
            return promise;
          };
          LocalForage2.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
            var self2 = this;
            if (!isArray(drivers)) {
              drivers = [drivers];
            }
            var supportedDrivers = this._getSupportedDrivers(drivers);
            function setDriverToConfig() {
              self2._config.driver = self2.driver();
            }
            function extendSelfWithDriver(driver) {
              self2._extend(driver);
              setDriverToConfig();
              self2._ready = self2._initStorage(self2._config);
              return self2._ready;
            }
            function initDriver(supportedDrivers2) {
              return function() {
                var currentDriverIndex = 0;
                function driverPromiseLoop() {
                  while (currentDriverIndex < supportedDrivers2.length) {
                    var driverName = supportedDrivers2[currentDriverIndex];
                    currentDriverIndex++;
                    self2._dbInfo = null;
                    self2._ready = null;
                    return self2.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
                  }
                  setDriverToConfig();
                  var error = new Error("No available storage method found.");
                  self2._driverSet = Promise$1.reject(error);
                  return self2._driverSet;
                }
                return driverPromiseLoop();
              };
            }
            var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function() {
              return Promise$1.resolve();
            }) : Promise$1.resolve();
            this._driverSet = oldDriverSetDone.then(function() {
              var driverName = supportedDrivers[0];
              self2._dbInfo = null;
              self2._ready = null;
              return self2.getDriver(driverName).then(function(driver) {
                self2._driver = driver._driver;
                setDriverToConfig();
                self2._wrapLibraryMethodsWithReady();
                self2._initDriver = initDriver(supportedDrivers);
              });
            })["catch"](function() {
              setDriverToConfig();
              var error = new Error("No available storage method found.");
              self2._driverSet = Promise$1.reject(error);
              return self2._driverSet;
            });
            executeTwoCallbacks(this._driverSet, callback, errorCallback);
            return this._driverSet;
          };
          LocalForage2.prototype.supports = function supports(driverName) {
            return !!DriverSupport[driverName];
          };
          LocalForage2.prototype._extend = function _extend(libraryMethodsAndProperties) {
            extend(this, libraryMethodsAndProperties);
          };
          LocalForage2.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
            var supportedDrivers = [];
            for (var i = 0, len = drivers.length; i < len; i++) {
              var driverName = drivers[i];
              if (this.supports(driverName)) {
                supportedDrivers.push(driverName);
              }
            }
            return supportedDrivers;
          };
          LocalForage2.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
            for (var i = 0, len = LibraryMethods.length; i < len; i++) {
              callWhenReady(this, LibraryMethods[i]);
            }
          };
          LocalForage2.prototype.createInstance = function createInstance(options) {
            return new LocalForage2(options);
          };
          return LocalForage2;
        }();
        var localforage_js = new LocalForage();
        module3.exports = localforage_js;
      }, { "3": 3 }] }, {}, [4])(4);
    });
  }
});

// node_modules/@notifi-network/notifi-frontend-client/dist/index.mjs
init_shim();
var import_localforage = __toESM(require_localforage(), 1);

// node_modules/@notifi-network/notifi-graphql/dist/index.mjs
init_shim();

// node_modules/uuid/dist/esm-browser/index.js
init_shim();

// node_modules/uuid/dist/esm-browser/v1.js
init_shim();

// node_modules/uuid/dist/esm-browser/rng.js
init_shim();
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/stringify.js
init_shim();

// node_modules/uuid/dist/esm-browser/validate.js
init_shim();

// node_modules/uuid/dist/esm-browser/regex.js
init_shim();
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).substr(1));
}
var i;
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var stringify_default = stringify;

// node_modules/uuid/dist/esm-browser/v3.js
init_shim();

// node_modules/uuid/dist/esm-browser/v35.js
init_shim();

// node_modules/uuid/dist/esm-browser/parse.js
init_shim();
function parse2(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v;
  var arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default = parse2;

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes = [];
  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35_default(name, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version2;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return stringify_default(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

// node_modules/uuid/dist/esm-browser/md5.js
init_shim();
function md5(bytes) {
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (var i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i = 0; i < length32; i += 8) {
    var x = input[i >> 5] >>> i % 32 & 255;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;
  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c, d];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));
  for (var i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output;
}
function safeAdd(x, y) {
  var lsw = (x & 65535) + (y & 65535);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default = md5;

// node_modules/uuid/dist/esm-browser/v3.js
var v3 = v35_default("v3", 48, md5_default);

// node_modules/uuid/dist/esm-browser/v4.js
init_shim();
function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default = v4;

// node_modules/uuid/dist/esm-browser/v5.js
init_shim();

// node_modules/uuid/dist/esm-browser/sha1.js
init_shim();
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  var K = [1518500249, 1859775393, 2400959708, 3395469782];
  var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);
  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);
    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }
    M[_i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);
    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }
    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }
    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];
    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default = sha1;

// node_modules/uuid/dist/esm-browser/v5.js
var v5 = v35_default("v5", 80, sha1_default);

// node_modules/uuid/dist/esm-browser/nil.js
init_shim();

// node_modules/uuid/dist/esm-browser/version.js
init_shim();

// node_modules/@notifi-network/notifi-graphql/dist/index.mjs
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var version = "0.90.8";
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var docCache = /* @__PURE__ */ new Map();
var fragmentSourceMap = /* @__PURE__ */ new Map();
var printFragmentWarnings = true;
var experimentalFragmentVariables = false;
function normalize(string) {
  return string.replace(/[\s,]+/g, " ").trim();
}
function cacheKeyFromLoc(loc) {
  return normalize(loc.source.body.substring(loc.start, loc.end));
}
function processFragments(ast) {
  var seenKeys = /* @__PURE__ */ new Set();
  var definitions = [];
  ast.definitions.forEach(function(fragmentDefinition) {
    if (fragmentDefinition.kind === "FragmentDefinition") {
      var fragmentName = fragmentDefinition.name.value;
      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);
      var sourceKeySet = fragmentSourceMap.get(fragmentName);
      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {
        if (printFragmentWarnings) {
          console.warn("Warning: fragment with name " + fragmentName + " already exists.\ngraphql-tag enforces all fragment names across your application to be unique; read more about\nthis in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
        }
      } else if (!sourceKeySet) {
        fragmentSourceMap.set(fragmentName, sourceKeySet = /* @__PURE__ */ new Set());
      }
      sourceKeySet.add(sourceKey);
      if (!seenKeys.has(sourceKey)) {
        seenKeys.add(sourceKey);
        definitions.push(fragmentDefinition);
      }
    } else {
      definitions.push(fragmentDefinition);
    }
  });
  return __assign(__assign({}, ast), { definitions });
}
function stripLoc(doc) {
  var workSet = new Set(doc.definitions);
  workSet.forEach(function(node) {
    if (node.loc)
      delete node.loc;
    Object.keys(node).forEach(function(key) {
      var value = node[key];
      if (value && typeof value === "object") {
        workSet.add(value);
      }
    });
  });
  var loc = doc.loc;
  if (loc) {
    delete loc.startToken;
    delete loc.endToken;
  }
  return doc;
}
function parseDocument(source) {
  var cacheKey = normalize(source);
  if (!docCache.has(cacheKey)) {
    var parsed = parse(source, {
      experimentalFragmentVariables,
      allowLegacyFragmentVariables: experimentalFragmentVariables
    });
    if (!parsed || parsed.kind !== "Document") {
      throw new Error("Not a valid GraphQL document.");
    }
    docCache.set(cacheKey, stripLoc(processFragments(parsed)));
  }
  return docCache.get(cacheKey);
}
function gql(literals) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  if (typeof literals === "string") {
    literals = [literals];
  }
  var result = literals[0];
  args.forEach(function(arg, i) {
    if (arg && arg.kind === "Document") {
      result += arg.loc.source.body;
    } else {
      result += arg;
    }
    result += literals[i + 1];
  });
  return parseDocument(result);
}
function resetCaches() {
  docCache.clear();
  fragmentSourceMap.clear();
}
function disableFragmentWarnings() {
  printFragmentWarnings = false;
}
function enableExperimentalFragmentVariables() {
  experimentalFragmentVariables = true;
}
function disableExperimentalFragmentVariables() {
  experimentalFragmentVariables = false;
}
var extras = {
  gql,
  resetCaches,
  disableFragmentWarnings,
  enableExperimentalFragmentVariables,
  disableExperimentalFragmentVariables
};
(function(gql_1) {
  gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;
})(gql || (gql = {}));
gql["default"] = gql;
var lib_default = gql;
var FilterFragmentFragmentDoc = lib_default`
    fragment FilterFragment on Filter {
  id
  name
  filterType
}
    `;
var SourceFragmentFragmentDoc = lib_default`
    fragment SourceFragment on Source {
  id
  name
  type
  blockchainAddress
  fusionEventTypeId
  applicableFilters {
    ...FilterFragment
  }
}
    ${FilterFragmentFragmentDoc}`;
var SourceGroupFragmentFragmentDoc = lib_default`
    fragment SourceGroupFragment on SourceGroup {
  id
  name
  sources {
    ...SourceFragment
  }
}
    ${SourceFragmentFragmentDoc}`;
var EmailTargetFragmentFragmentDoc = lib_default`
    fragment EmailTargetFragment on EmailTarget {
  emailAddress
  id
  isConfirmed
  name
}
    `;
var SmsTargetFragmentFragmentDoc = lib_default`
    fragment SmsTargetFragment on SmsTarget {
  id
  isConfirmed
  name
  phoneNumber
}
    `;
var TelegramTargetFragmentFragmentDoc = lib_default`
    fragment TelegramTargetFragment on TelegramTarget {
  id
  isConfirmed
  name
  telegramId
  confirmationUrl
}
    `;
var WebhookTargetFragmentFragmentDoc = lib_default`
    fragment WebhookTargetFragment on WebhookTarget {
  id
  url
  status
  format
  headers {
    key
    value
  }
  name
}
    `;
var DiscordTargetFragmentFragmentDoc = lib_default`
    fragment DiscordTargetFragment on DiscordTarget {
  id
  discordAccountId
  discriminator
  isConfirmed
  username
  name
  userStatus
  verificationLink
  discordServerInviteLink
}
    `;
var TargetGroupFragmentFragmentDoc = lib_default`
    fragment TargetGroupFragment on TargetGroup {
  id
  name
  emailTargets {
    ...EmailTargetFragment
  }
  smsTargets {
    ...SmsTargetFragment
  }
  telegramTargets {
    ...TelegramTargetFragment
  }
  webhookTargets {
    ...WebhookTargetFragment
  }
  discordTargets {
    ...DiscordTargetFragment
  }
}
    ${EmailTargetFragmentFragmentDoc}
${SmsTargetFragmentFragmentDoc}
${TelegramTargetFragmentFragmentDoc}
${WebhookTargetFragmentFragmentDoc}
${DiscordTargetFragmentFragmentDoc}`;
var AlertFragmentFragmentDoc = lib_default`
    fragment AlertFragment on Alert {
  id
  groupName
  name
  filterOptions
  filter {
    ...FilterFragment
  }
  sourceGroup {
    ...SourceGroupFragment
  }
  targetGroup {
    ...TargetGroupFragment
  }
}
    ${FilterFragmentFragmentDoc}
${SourceGroupFragmentFragmentDoc}
${TargetGroupFragmentFragmentDoc}`;
var ConnectedWalletFragmentFragmentDoc = lib_default`
    fragment ConnectedWalletFragment on ConnectedWallet {
  address
  walletBlockchain
}
    `;
var ConvMessagePageInfoFragmentDoc = lib_default`
    fragment ConvMessagePageInfo on PageInfo {
  hasNextPage
  endCursor
}
    `;
var ParticipantFragmentDoc = lib_default`
    fragment Participant on ConversationParticipant {
  conversationId
  conversationParticipantType
  profile {
    avatarData
    avatarDataType
    id
    preferredAddress
    preferredBlockchain
    preferredName
  }
  resolvedName
  userId
  walletAddress
  walletBlockchain
}
    `;
var ConversationMessageFragmentDoc = lib_default`
    fragment ConversationMessage on ConversationMessage {
  id
  userId
  conversationId
  createdDate
  updatedDate
  message
  conversationParticipant {
    ...Participant
  }
}
    ${ParticipantFragmentDoc}`;
var FusionNotificationHistoryEntryFragmentFragmentDoc = lib_default`
    fragment FusionNotificationHistoryEntryFragment on FusionNotificationHistoryEntry {
  __typename
  id
  createdDate
  read
  fusionEventVariables
  detail {
    __typename
    ... on AccountBalanceChangedEventDetails {
      walletBlockchain
      direction
      newValue
      previousValue
      tokenSymbol
      isWhaleWatch
    }
    ... on BroadcastMessageEventDetails {
      messageType: type
      subject
      message
      messageHtml
    }
    ... on DirectTenantMessageEventDetails {
      tenantName
      targetTemplatesJson
      templateVariablesJson
    }
    ... on NftCollectionsReportEventDetails {
      type
      providerName
      sourceLink
      collections {
        collectionId
        name
        imgUrl
        volume1Day
        volume1DayChange
      }
    }
    ... on ChatMessageReceivedEventDetails {
      senderName
      conversationId
      messageId
      senderId
      senderBlockchain
      senderName
      messageBody
    }
    ... on DAOProposalChangedEventDetails {
      tenantName
      proposalTitle: title
      description
      state
      daoUrl
      proposalUrl
    }
    ... on NftAuctionChangedEventDetails {
      auctionTitle: title
      auctionUrl
      walletBlockchain
      highBidAmount
      highBidSymbol
      imageUrl
    }
    ... on WalletsActivityReportEventDetails {
      providerName
      sourceLink
      walletActivityType: type
      wallets {
        address
        volume1Day
        maxPurchase1Day
        maxPurchaseName
        maxPurchaseImgUrl
        maxPurchaseTokenAddress
      }
    }
    ... on HealthValueOverThresholdEventDetails {
      name
      value
      threshold
      url
    }
    ... on GenericEventDetails {
      sourceName
      notificationTypeName
      genericMessage: message
      genericMessageHtml: messageHtml
      eventDetailsJson
      action {
        name
        url
      }
      icon
    }
  }
}
    `;
var NotificationHistoryEntryFragmentFragmentDoc = lib_default`
    fragment NotificationHistoryEntryFragment on NotificationHistoryEntry {
  __typename
  id
  createdDate
  eventId
  read
  sourceAddress
  category
  transactionSignature
  targets {
    type
    name
  }
  detail {
    __typename
    ... on AccountBalanceChangedEventDetails {
      walletBlockchain
      direction
      newValue
      previousValue
      tokenSymbol
      isWhaleWatch
    }
    ... on BroadcastMessageEventDetails {
      messageType: type
      subject
      message
      messageHtml
    }
    ... on DirectTenantMessageEventDetails {
      tenantName
      targetTemplatesJson
      templateVariablesJson
    }
    ... on NftCollectionsReportEventDetails {
      type
      providerName
      sourceLink
      collections {
        collectionId
        name
        imgUrl
        volume1Day
        volume1DayChange
      }
    }
    ... on ChatMessageReceivedEventDetails {
      senderName
      conversationId
      messageId
      senderId
      senderBlockchain
      senderName
      messageBody
    }
    ... on DAOProposalChangedEventDetails {
      tenantName
      proposalTitle: title
      description
      state
      daoUrl
      proposalUrl
    }
    ... on NftAuctionChangedEventDetails {
      auctionTitle: title
      auctionUrl
      walletBlockchain
      highBidAmount
      highBidSymbol
      imageUrl
    }
    ... on WalletsActivityReportEventDetails {
      providerName
      sourceLink
      walletActivityType: type
      wallets {
        address
        volume1Day
        maxPurchase1Day
        maxPurchaseName
        maxPurchaseImgUrl
        maxPurchaseTokenAddress
      }
    }
    ... on HealthValueOverThresholdEventDetails {
      name
      value
      threshold
      url
    }
    ... on GenericEventDetails {
      sourceName
      notificationTypeName
      genericMessage: message
      genericMessageHtml: messageHtml
      eventDetailsJson
      action {
        name
        url
      }
      icon
    }
  }
}
    `;
var PageInfoFragmentFragmentDoc = lib_default`
    fragment PageInfoFragment on PageInfo {
  hasNextPage
  endCursor
}
    `;
var TenantConfigFragmentFragmentDoc = lib_default`
    fragment TenantConfigFragment on TenantConfig {
  id
  type
  dataJson
}
    `;
var TenantUserAlertFragmentFragmentDoc = lib_default`
    fragment TenantUserAlertFragment on TenantUserAlert {
  id
  name
  groupName
  filterOptions
  filter {
    ...FilterFragment
  }
  sourceGroup {
    ...SourceGroupFragment
  }
  targetGroup {
    hasVerifiedFcm
    hasVerifiedSms
    hasVerifiedWeb3
    hasVerifiedEmails
    hasVerifiedWebhook
    hasVerifiedDiscord
    hasVerifiedTelegram
  }
}
    ${FilterFragmentFragmentDoc}
${SourceGroupFragmentFragmentDoc}`;
var TenantConnectedWalletFragmentFragmentDoc = lib_default`
    fragment TenantConnectedWalletFragment on TenantConnectedWallet {
  address
  walletBlockchain
}
    `;
var TenantUserFragmentFragmentDoc = lib_default`
    fragment TenantUserFragment on TenantUser {
  id
  alerts {
    ...TenantUserAlertFragment
  }
  connectedWallets {
    ...TenantConnectedWalletFragment
  }
}
    ${TenantUserAlertFragmentFragmentDoc}
${TenantConnectedWalletFragmentFragmentDoc}`;
var AuthorizationFragmentFragmentDoc = lib_default`
    fragment AuthorizationFragment on Authorization {
  token
  expiry
}
    `;
var UserFragmentFragmentDoc = lib_default`
    fragment UserFragment on User {
  email
  emailConfirmed
  authorization {
    ...AuthorizationFragment
  }
  roles
}
    ${AuthorizationFragmentFragmentDoc}`;
var UserTopicFragmentFragmentDoc = lib_default`
    fragment UserTopicFragment on UserTopic {
  name
  topicName
  targetCollections
  targetTemplate
}
    `;
var AddSourceToSourceGroupDocument = lib_default`
    mutation addSourceToSourceGroup($input: AddSourceToSourceGroupInput!) {
  addSourceToSourceGroup(addSourceToSourceGroupInput: $input) {
    ...SourceGroupFragment
  }
}
    ${SourceGroupFragmentFragmentDoc}`;
var BeginLogInByTransactionDocument = lib_default`
    mutation beginLogInByTransaction($walletAddress: String!, $walletBlockchain: WalletBlockchain!, $dappAddress: String!) {
  beginLogInByTransaction(
    beginLogInByTransactionInput: {walletAddress: $walletAddress, walletBlockchain: $walletBlockchain, dappAddress: $dappAddress}
  ) {
    nonce
  }
}
    `;
var BroadcastMessageDocument = lib_default`
    mutation broadcastMessage($idempotencyKey: String, $topicName: String!, $targetTemplates: [KeyValuePairOfTargetTypeAndStringInput!], $variables: [KeyValuePairOfStringAndStringInput!], $timestamp: Long!, $walletBlockchain: WalletBlockchain!, $signature: String!) {
  broadcastMessage(
    broadcastMessageInput: {idempotencyKey: $idempotencyKey, sourceAddress: $topicName, targetTemplates: $targetTemplates, variables: $variables, timestamp: $timestamp, walletBlockchain: $walletBlockchain}
    signature: $signature
  ) {
    id
  }
}
    `;
var CompleteLogInByTransactionDocument = lib_default`
    mutation completeLogInByTransaction($walletAddress: String!, $walletBlockchain: WalletBlockchain!, $dappAddress: String!, $randomUuid: String!, $transactionSignature: String!) {
  completeLogInByTransaction(
    completeLogInByTransactionInput: {walletAddress: $walletAddress, walletBlockchain: $walletBlockchain, dappAddress: $dappAddress, randomUuid: $randomUuid, transactionSignature: $transactionSignature}
  ) {
    ...UserFragment
  }
}
    ${UserFragmentFragmentDoc}`;
var ConnectWalletDocument = lib_default`
    mutation connectWallet($walletPublicKey: String!, $timestamp: Long!, $signature: String!, $walletBlockchain: WalletBlockchain!, $accountId: String, $connectWalletConflictResolutionTechnique: ConnectWalletConflictResolutionTechnique) {
  connectWallet(
    connectWalletInput: {walletPublicKey: $walletPublicKey, timestamp: $timestamp, walletBlockchain: $walletBlockchain, accountId: $accountId, connectWalletConflictResolutionTechnique: $connectWalletConflictResolutionTechnique}
    signature: $signature
  ) {
    ...ConnectedWalletFragment
  }
}
    ${ConnectedWalletFragmentFragmentDoc}`;
var CreateAlertDocument = lib_default`
    mutation createAlert($name: String!, $sourceGroupId: String!, $filterId: String!, $targetGroupId: String!, $filterOptions: String!, $groupName: String!) {
  createAlert(
    alertInput: {name: $name, sourceGroupId: $sourceGroupId, filterId: $filterId, targetGroupId: $targetGroupId, filterOptions: $filterOptions, groupName: $groupName}
  ) {
    ...AlertFragment
  }
}
    ${AlertFragmentFragmentDoc}`;
var CreateDirectPushAlertDocument = lib_default`
    mutation createDirectPushAlert($input: CreateDirectPushAlertInput!) {
  createDirectPushAlert(createDirectPushAlertInput: $input) {
    ...AlertFragment
  }
}
    ${AlertFragmentFragmentDoc}`;
var CreateDiscordTargetDocument = lib_default`
    mutation createDiscordTarget($name: String!, $value: String!) {
  createDiscordTarget(createTargetInput: {name: $name, value: $value}) {
    ...DiscordTargetFragment
  }
}
    ${DiscordTargetFragmentFragmentDoc}`;
var CreateEmailTargetDocument = lib_default`
    mutation createEmailTarget($name: String!, $value: String!) {
  createEmailTarget(createTargetInput: {name: $name, value: $value}) {
    ...EmailTargetFragment
  }
}
    ${EmailTargetFragmentFragmentDoc}`;
var CreateSmsTargetDocument = lib_default`
    mutation createSmsTarget($name: String!, $value: String!) {
  createSmsTarget(createTargetInput: {name: $name, value: $value}) {
    ...SmsTargetFragment
  }
}
    ${SmsTargetFragmentFragmentDoc}`;
var CreateSourceDocument = lib_default`
    mutation createSource($name: String, $blockchainAddress: String!, $type: SourceType!, $fusionEventTypeId: String) {
  createSource(
    createSourceInput: {name: $name, blockchainAddress: $blockchainAddress, type: $type, fusionEventTypeId: $fusionEventTypeId}
  ) {
    ...SourceFragment
  }
}
    ${SourceFragmentFragmentDoc}`;
var CreateSourceGroupDocument = lib_default`
    mutation createSourceGroup($name: String!, $sourceIds: [String!]!) {
  createSourceGroup(sourceGroupInput: {name: $name, sourceIds: $sourceIds}) {
    ...SourceGroupFragment
  }
}
    ${SourceGroupFragmentFragmentDoc}`;
var CreateSupportConversationDocument = lib_default`
    mutation createSupportConversation {
  createSupportConversation {
    id
    conversationType
    conversationGates {
      id
    }
    name
    createdDate
    participants {
      conversationParticipantType
      profile {
        id
        preferredAddress
        preferredName
        avatarData
        avatarDataType
      }
      resolvedName
    }
    backgroundImageUrl
  }
}
    `;
var CreateTargetGroupDocument = lib_default`
    mutation createTargetGroup($name: String!, $emailTargetIds: [String!]!, $smsTargetIds: [String!]!, $telegramTargetIds: [String!]!, $webhookTargetIds: [String!]!, $discordTargetIds: [String!]!) {
  createTargetGroup(
    targetGroupInput: {name: $name, emailTargetIds: $emailTargetIds, smsTargetIds: $smsTargetIds, telegramTargetIds: $telegramTargetIds, webhookTargetIds: $webhookTargetIds, discordTargetIds: $discordTargetIds}
  ) {
    ...TargetGroupFragment
  }
}
    ${TargetGroupFragmentFragmentDoc}`;
var CreateTelegramTargetDocument = lib_default`
    mutation createTelegramTarget($name: String!, $value: String!) {
  createTelegramTarget(createTargetInput: {name: $name, value: $value}) {
    ...TelegramTargetFragment
  }
}
    ${TelegramTargetFragmentFragmentDoc}`;
var CreateTenantUserDocument = lib_default`
    mutation createTenantUser($input: CreateTenantUserInput!) {
  createTenantUser(createTenantUserInput: $input) {
    ...TenantUserFragment
  }
}
    ${TenantUserFragmentFragmentDoc}`;
var CreateWebhookTargetDocument = lib_default`
    mutation createWebhookTarget($name: String!, $url: String!, $format: WebhookPayloadFormat!, $headers: [KeyValuePairOfStringAndStringInput!]!) {
  createWebhookTarget(
    createTargetInput: {name: $name, url: $url, format: $format, headers: $headers}
  ) {
    ...WebhookTargetFragment
  }
}
    ${WebhookTargetFragmentFragmentDoc}`;
var DeleteAlertDocument = lib_default`
    mutation deleteAlert($id: String!) {
  deleteAlert(alertId: $id) {
    id
  }
}
    `;
var DeleteDirectPushAlertDocument = lib_default`
    mutation deleteDirectPushAlert($input: DeleteDirectPushAlertInput!) {
  deleteDirectPushAlert(deleteDirectPushAlertInput: $input) {
    id
  }
}
    `;
var DeleteSourceGroupDocument = lib_default`
    mutation deleteSourceGroup($id: String!) {
  deleteSourceGroup(sourceGroupInput: {id: $id}) {
    id
  }
}
    `;
var DeleteTargetGroupDocument = lib_default`
    mutation deleteTargetGroup($id: String!) {
  deleteTargetGroup(targetGroupInput: {id: $id}) {
    id
  }
}
    `;
var DeleteUserAlertDocument = lib_default`
    mutation deleteUserAlert($alertId: String!) {
  deleteUserAlert(alertId: $alertId) {
    id
  }
}
    `;
var DeleteWebhookTargetDocument = lib_default`
    mutation deleteWebhookTarget($id: String!) {
  deleteWebhookTarget(deleteTargetInput: {id: $id}) {
    id
  }
}
    `;
var LogInFromDappDocument = lib_default`
    mutation logInFromDapp($walletBlockchain: WalletBlockchain!, $walletPublicKey: String!, $dappAddress: String!, $timestamp: Long!, $signature: String!, $accountId: String) {
  logInFromDapp(
    dappLogInInput: {walletBlockchain: $walletBlockchain, walletPublicKey: $walletPublicKey, dappAddress: $dappAddress, timestamp: $timestamp, accountId: $accountId}
    signature: $signature
  ) {
    ...UserFragment
  }
}
    ${UserFragmentFragmentDoc}`;
var LogInFromServiceDocument = lib_default`
    mutation logInFromService($input: ServiceLogInInput!) {
  logInFromService(serviceLogInInput: $input) {
    ...AuthorizationFragment
  }
}
    ${AuthorizationFragmentFragmentDoc}`;
var MarkFusionNotificationHistoryAsReadDocument = lib_default`
    mutation markFusionNotificationHistoryAsRead($ids: [String!]!, $beforeId: String, $readState: NotificationHistoryReadState) {
  markFusionNotificationHistoryAsRead(
    input: {ids: $ids, beforeId: $beforeId, readState: $readState}
  )
}
    `;
var PublishFusionMessageDocument = lib_default`
    mutation publishFusionMessage($eventTypeId: String!, $variablesJson: String!, $specificWallets: [KeyValuePairOfStringAndWalletBlockchainInput!]) {
  publishFusionMessage(
    publishFusionMessageInput: {eventTypeId: $eventTypeId, variablesJson: $variablesJson, specificWallets: $specificWallets}
  ) {
    eventUuid
  }
}
    `;
var RefreshAuthorizationDocument = lib_default`
    mutation refreshAuthorization {
  refreshAuthorization {
    ...AuthorizationFragment
  }
}
    ${AuthorizationFragmentFragmentDoc}`;
var RemoveSourceFromSourceGroupDocument = lib_default`
    mutation removeSourceFromSourceGroup($input: RemoveSourceFromSourceGroupInput!) {
  removeSourceFromSourceGroup(removeSourceFromSourceGroupInput: $input) {
    ...SourceGroupFragment
  }
}
    ${SourceGroupFragmentFragmentDoc}`;
var SendConversationMessageDocument = lib_default`
    mutation sendConversationMessage($sendConversationMessageInput: SendConversationMessageInput!) {
  sendConversationMessage(
    sendConversationMessageInput: $sendConversationMessageInput
  ) {
    ...ConversationMessage
  }
}
    ${ConversationMessageFragmentDoc}`;
var SendEmailTargetVerificationRequestDocument = lib_default`
    mutation sendEmailTargetVerificationRequest($targetId: String!) {
  sendEmailTargetVerificationRequest(
    sendTargetConfirmationRequestInput: {targetId: $targetId}
  ) {
    ...EmailTargetFragment
  }
}
    ${EmailTargetFragmentFragmentDoc}`;
var SendMessageDocument = lib_default`
    mutation sendMessage($input: SendMessageInput!) {
  sendMessage(sendMessageInput: $input)
}
    `;
var UpdateSourceGroupDocument = lib_default`
    mutation updateSourceGroup($id: String!, $name: String!, $sourceIds: [String!]!) {
  updateSourceGroup: createSourceGroup(
    sourceGroupInput: {id: $id, name: $name, sourceIds: $sourceIds}
  ) {
    ...SourceGroupFragment
  }
}
    ${SourceGroupFragmentFragmentDoc}`;
var UpdateTargetGroupDocument = lib_default`
    mutation updateTargetGroup($id: String!, $name: String!, $emailTargetIds: [String!]!, $smsTargetIds: [String!]!, $telegramTargetIds: [String!]!, $webhookTargetIds: [String!]!, $discordTargetIds: [String!]!) {
  updateTargetGroup: createTargetGroup(
    targetGroupInput: {id: $id, name: $name, emailTargetIds: $emailTargetIds, smsTargetIds: $smsTargetIds, telegramTargetIds: $telegramTargetIds, webhookTargetIds: $webhookTargetIds, discordTargetIds: $discordTargetIds}
  ) {
    ...TargetGroupFragment
  }
}
    ${TargetGroupFragmentFragmentDoc}`;
var UpdateUserSettingsDocument = lib_default`
    mutation updateUserSettings($input: UserSettingsInput!) {
  updateUserSettings(userSettings: $input) {
    detailedAlertHistoryEnabled
    userHasChatEnabled
    ftuStage
  }
}
    `;
var FetchDataDocument = lib_default`
    query fetchData {
  alert {
    ...AlertFragment
  }
  sourceGroup {
    ...SourceGroupFragment
  }
  connectedWallet {
    ...ConnectedWalletFragment
  }
  source {
    ...SourceFragment
  }
  targetGroup {
    ...TargetGroupFragment
  }
  emailTarget {
    ...EmailTargetFragment
  }
  smsTarget {
    ...SmsTargetFragment
  }
  telegramTarget {
    ...TelegramTargetFragment
  }
  discordTarget {
    ...DiscordTargetFragment
  }
  filter {
    ...FilterFragment
  }
}
    ${AlertFragmentFragmentDoc}
${SourceGroupFragmentFragmentDoc}
${ConnectedWalletFragmentFragmentDoc}
${SourceFragmentFragmentDoc}
${TargetGroupFragmentFragmentDoc}
${EmailTargetFragmentFragmentDoc}
${SmsTargetFragmentFragmentDoc}
${TelegramTargetFragmentFragmentDoc}
${DiscordTargetFragmentFragmentDoc}
${FilterFragmentFragmentDoc}`;
var FindTenantConfigDocument = lib_default`
    query findTenantConfig($input: FindTenantConfigInput!) {
  findTenantConfig(findTenantConfigInput: $input) {
    ...TenantConfigFragment
  }
}
    ${TenantConfigFragmentFragmentDoc}`;
var GetAlertsDocument = lib_default`
    query getAlerts {
  alert {
    ...AlertFragment
  }
}
    ${AlertFragmentFragmentDoc}`;
var GetConfigurationForDappDocument = lib_default`
    query getConfigurationForDapp($dappAddress: String!) {
  configurationForDapp(getConfigurationForDappInput: {dappAddress: $dappAddress}) {
    supportedSmsCountryCodes
    supportedTargetTypes
  }
}
    `;
var GetConnectedWalletsDocument = lib_default`
    query getConnectedWallets {
  connectedWallet {
    ...ConnectedWalletFragment
  }
}
    ${ConnectedWalletFragmentFragmentDoc}`;
var GetConversationMessagesDocument = lib_default`
    query getConversationMessages($getConversationMessagesInput: GetConversationMessagesInput!, $after: String, $first: Int) {
  conversationMessages(
    first: $first
    after: $after
    getConversationMessagesInput: $getConversationMessagesInput
  ) {
    nodes {
      ...ConversationMessage
    }
    pageInfo {
      ...ConvMessagePageInfo
    }
  }
}
    ${ConversationMessageFragmentDoc}
${ConvMessagePageInfoFragmentDoc}`;
var GetDiscordTargetsDocument = lib_default`
    query getDiscordTargets {
  discordTarget {
    ...DiscordTargetFragment
  }
}
    ${DiscordTargetFragmentFragmentDoc}`;
var GetEmailTargetsDocument = lib_default`
    query getEmailTargets {
  emailTarget {
    ...EmailTargetFragment
  }
}
    ${EmailTargetFragmentFragmentDoc}`;
var GetFiltersDocument = lib_default`
    query getFilters {
  filter {
    ...FilterFragment
  }
}
    ${FilterFragmentFragmentDoc}`;
var GetFusionNotificationHistoryDocument = lib_default`
    query getFusionNotificationHistory($after: String, $first: Int, $includeHidden: Boolean) {
  fusionNotificationHistory(
    after: $after
    first: $first
    includeHidden: $includeHidden
  ) {
    nodes {
      ...FusionNotificationHistoryEntryFragment
    }
    pageInfo {
      ...PageInfoFragment
    }
  }
}
    ${FusionNotificationHistoryEntryFragmentFragmentDoc}
${PageInfoFragmentFragmentDoc}`;
var GetNotificationHistoryDocument = lib_default`
    query getNotificationHistory($after: String, $first: Int) {
  notificationHistory(after: $after, first: $first) {
    nodes {
      ...NotificationHistoryEntryFragment
    }
    pageInfo {
      ...PageInfoFragment
    }
  }
}
    ${NotificationHistoryEntryFragmentFragmentDoc}
${PageInfoFragmentFragmentDoc}`;
var GetSmsTargetsDocument = lib_default`
    query getSmsTargets {
  smsTarget {
    ...SmsTargetFragment
  }
}
    ${SmsTargetFragmentFragmentDoc}`;
var GetSourceConnectionDocument = lib_default`
    query getSourceConnection($input: GetSourcesInput, $first: Int, $after: String) {
  sources(getSourcesInput: $input, first: $first, after: $after) {
    pageInfo {
      ...PageInfoFragment
    }
    nodes {
      ...SourceFragment
    }
  }
}
    ${PageInfoFragmentFragmentDoc}
${SourceFragmentFragmentDoc}`;
var GetSourceGroupsDocument = lib_default`
    query getSourceGroups {
  sourceGroup {
    ...SourceGroupFragment
  }
}
    ${SourceGroupFragmentFragmentDoc}`;
var GetSourcesDocument = lib_default`
    query getSources {
  source {
    ...SourceFragment
  }
}
    ${SourceFragmentFragmentDoc}`;
var GetTargetGroupsDocument = lib_default`
    query getTargetGroups {
  targetGroup {
    ...TargetGroupFragment
  }
}
    ${TargetGroupFragmentFragmentDoc}`;
var GetTelegramTargetsDocument = lib_default`
    query getTelegramTargets {
  telegramTarget {
    ...TelegramTargetFragment
  }
}
    ${TelegramTargetFragmentFragmentDoc}`;
var GetTenantConnectedWalletDocument = lib_default`
    query getTenantConnectedWallet($input: GetTenantConnectedWalletInput, $first: Int, $after: String) {
  tenantConnectedWallet(
    getTenantConnectedWalletInput: $input
    first: $first
    after: $after
  ) {
    pageInfo {
      ...PageInfoFragment
    }
    nodes {
      ...TenantConnectedWalletFragment
      user {
        ...TenantUserFragment
      }
    }
  }
}
    ${PageInfoFragmentFragmentDoc}
${TenantConnectedWalletFragmentFragmentDoc}
${TenantUserFragmentFragmentDoc}`;
var GetTenantUserDocument = lib_default`
    query getTenantUser($first: Int, $after: String) {
  tenantUser(first: $first, after: $after) {
    pageInfo {
      ...PageInfoFragment
    }
    nodes {
      ...TenantUserFragment
    }
  }
}
    ${PageInfoFragmentFragmentDoc}
${TenantUserFragmentFragmentDoc}`;
var GetTopicsDocument = lib_default`
    query getTopics {
  topics {
    nodes {
      ...UserTopicFragment
    }
  }
}
    ${UserTopicFragmentFragmentDoc}`;
var GetUnreadNotificationHistoryCountDocument = lib_default`
    query getUnreadNotificationHistoryCount {
  unreadNotificationHistoryCount {
    count
  }
}
    `;
var GetUserSettingsDocument = lib_default`
    query getUserSettings {
  userSettings {
    detailedAlertHistoryEnabled
    userHasChatEnabled
    ftuStage
  }
}
    `;
var GetWebhookTargetsDocument = lib_default`
    query getWebhookTargets {
  webhookTarget {
    ...WebhookTargetFragment
  }
}
    ${WebhookTargetFragmentFragmentDoc}`;
var defaultWrapper = (action, _operationName, _operationType) => action();
function getSdk(client, withWrapper = defaultWrapper) {
  return {
    addSourceToSourceGroup(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(AddSourceToSourceGroupDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "addSourceToSourceGroup", "mutation");
    },
    beginLogInByTransaction(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(BeginLogInByTransactionDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "beginLogInByTransaction", "mutation");
    },
    broadcastMessage(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(BroadcastMessageDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "broadcastMessage", "mutation");
    },
    completeLogInByTransaction(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(CompleteLogInByTransactionDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "completeLogInByTransaction", "mutation");
    },
    connectWallet(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(ConnectWalletDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "connectWallet", "mutation");
    },
    createAlert(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(CreateAlertDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "createAlert", "mutation");
    },
    createDirectPushAlert(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(CreateDirectPushAlertDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "createDirectPushAlert", "mutation");
    },
    createDiscordTarget(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(CreateDiscordTargetDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "createDiscordTarget", "mutation");
    },
    createEmailTarget(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(CreateEmailTargetDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "createEmailTarget", "mutation");
    },
    createSmsTarget(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(CreateSmsTargetDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "createSmsTarget", "mutation");
    },
    createSource(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(CreateSourceDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "createSource", "mutation");
    },
    createSourceGroup(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(CreateSourceGroupDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "createSourceGroup", "mutation");
    },
    createSupportConversation(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(CreateSupportConversationDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "createSupportConversation", "mutation");
    },
    createTargetGroup(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(CreateTargetGroupDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "createTargetGroup", "mutation");
    },
    createTelegramTarget(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(CreateTelegramTargetDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "createTelegramTarget", "mutation");
    },
    createTenantUser(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(CreateTenantUserDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "createTenantUser", "mutation");
    },
    createWebhookTarget(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(CreateWebhookTargetDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "createWebhookTarget", "mutation");
    },
    deleteAlert(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(DeleteAlertDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "deleteAlert", "mutation");
    },
    deleteDirectPushAlert(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(DeleteDirectPushAlertDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "deleteDirectPushAlert", "mutation");
    },
    deleteSourceGroup(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(DeleteSourceGroupDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "deleteSourceGroup", "mutation");
    },
    deleteTargetGroup(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(DeleteTargetGroupDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "deleteTargetGroup", "mutation");
    },
    deleteUserAlert(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(DeleteUserAlertDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "deleteUserAlert", "mutation");
    },
    deleteWebhookTarget(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(DeleteWebhookTargetDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "deleteWebhookTarget", "mutation");
    },
    logInFromDapp(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(LogInFromDappDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "logInFromDapp", "mutation");
    },
    logInFromService(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(LogInFromServiceDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "logInFromService", "mutation");
    },
    markFusionNotificationHistoryAsRead(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(MarkFusionNotificationHistoryAsReadDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "markFusionNotificationHistoryAsRead", "mutation");
    },
    publishFusionMessage(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(PublishFusionMessageDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "publishFusionMessage", "mutation");
    },
    refreshAuthorization(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(RefreshAuthorizationDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "refreshAuthorization", "mutation");
    },
    removeSourceFromSourceGroup(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(RemoveSourceFromSourceGroupDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "removeSourceFromSourceGroup", "mutation");
    },
    sendConversationMessage(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(SendConversationMessageDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "sendConversationMessage", "mutation");
    },
    sendEmailTargetVerificationRequest(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(SendEmailTargetVerificationRequestDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "sendEmailTargetVerificationRequest", "mutation");
    },
    sendMessage(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(SendMessageDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "sendMessage", "mutation");
    },
    updateSourceGroup(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(UpdateSourceGroupDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "updateSourceGroup", "mutation");
    },
    updateTargetGroup(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(UpdateTargetGroupDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "updateTargetGroup", "mutation");
    },
    updateUserSettings(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(UpdateUserSettingsDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "updateUserSettings", "mutation");
    },
    fetchData(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(FetchDataDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "fetchData", "query");
    },
    findTenantConfig(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(FindTenantConfigDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "findTenantConfig", "query");
    },
    getAlerts(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetAlertsDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "getAlerts", "query");
    },
    getConfigurationForDapp(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetConfigurationForDappDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "getConfigurationForDapp", "query");
    },
    getConnectedWallets(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetConnectedWalletsDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "getConnectedWallets", "query");
    },
    getConversationMessages(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetConversationMessagesDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "getConversationMessages", "query");
    },
    getDiscordTargets(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetDiscordTargetsDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "getDiscordTargets", "query");
    },
    getEmailTargets(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetEmailTargetsDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "getEmailTargets", "query");
    },
    getFilters(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetFiltersDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "getFilters", "query");
    },
    getFusionNotificationHistory(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetFusionNotificationHistoryDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "getFusionNotificationHistory", "query");
    },
    getNotificationHistory(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetNotificationHistoryDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "getNotificationHistory", "query");
    },
    getSmsTargets(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetSmsTargetsDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "getSmsTargets", "query");
    },
    getSourceConnection(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetSourceConnectionDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "getSourceConnection", "query");
    },
    getSourceGroups(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetSourceGroupsDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "getSourceGroups", "query");
    },
    getSources(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetSourcesDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "getSources", "query");
    },
    getTargetGroups(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetTargetGroupsDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "getTargetGroups", "query");
    },
    getTelegramTargets(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetTelegramTargetsDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "getTelegramTargets", "query");
    },
    getTenantConnectedWallet(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetTenantConnectedWalletDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "getTenantConnectedWallet", "query");
    },
    getTenantUser(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetTenantUserDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "getTenantUser", "query");
    },
    getTopics(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetTopicsDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "getTopics", "query");
    },
    getUnreadNotificationHistoryCount(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetUnreadNotificationHistoryCountDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "getUnreadNotificationHistoryCount", "query");
    },
    getUserSettings(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetUserSettingsDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "getUserSettings", "query");
    },
    getWebhookTargets(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetWebhookTargetsDocument, variables, __spreadValues(__spreadValues({}, requestHeaders), wrappedRequestHeaders)), "getWebhookTargets", "query");
    }
  };
}
var NotifiService = class {
  constructor(graphQLClient) {
    this._typedClient = getSdk(graphQLClient);
  }
  setJwt(jwt) {
    this._jwt = jwt;
  }
  async logOut() {
    this._jwt = void 0;
  }
  async addSourceToSourceGroup(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.addSourceToSourceGroup(variables, headers);
  }
  async beginLogInByTransaction(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.beginLogInByTransaction(variables, headers);
  }
  async broadcastMessage(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.broadcastMessage(variables, headers);
  }
  async completeLogInByTransaction(variables) {
    var _a, _b;
    const headers = this._requestHeaders();
    const result = await this._typedClient.completeLogInByTransaction(
      variables,
      headers
    );
    const token = (_b = (_a = result.completeLogInByTransaction) == null ? void 0 : _a.authorization) == null ? void 0 : _b.token;
    if (token !== void 0) {
      this._jwt = token;
    }
    return result;
  }
  async connectWallet(variables) {
    const headers = this._requestHeaders();
    return await this._typedClient.connectWallet(variables, headers);
  }
  async createAlert(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.createAlert(variables, headers);
  }
  async createDirectPushAlert(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.createDirectPushAlert(variables, headers);
  }
  async createEmailTarget(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.createEmailTarget(variables, headers);
  }
  async createDiscordTarget(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.createDiscordTarget(variables, headers);
  }
  async createSmsTarget(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.createSmsTarget(variables, headers);
  }
  async createSource(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.createSource(variables, headers);
  }
  async createSourceGroup(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.createSourceGroup(variables, headers);
  }
  async createSupportConversation(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.createSupportConversation(variables, headers);
  }
  async createTargetGroup(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.createTargetGroup(variables, headers);
  }
  async createTenantUser(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.createTenantUser(variables, headers);
  }
  async createWebhookTarget(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.createWebhookTarget(variables, headers);
  }
  async createTelegramTarget(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.createTelegramTarget(variables, headers);
  }
  async deleteAlert(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.deleteAlert(variables, headers);
  }
  async DeleteDirectPushAlert(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.deleteDirectPushAlert(variables, headers);
  }
  async deleteUserAlert(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.deleteUserAlert(variables, headers);
  }
  async deleteSourceGroup(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.deleteSourceGroup(variables, headers);
  }
  async deleteTargetGroup(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.deleteTargetGroup(variables, headers);
  }
  async deleteWebhookTarget(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.deleteWebhookTarget(variables, headers);
  }
  async fetchData(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.fetchData(variables, headers);
  }
  async findTenantConfig(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.findTenantConfig(variables, headers);
  }
  async getAlerts(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.getAlerts(variables, headers);
  }
  async getConfigurationForDapp(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.getConfigurationForDapp(variables, headers);
  }
  async getConnectedWallets(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.getConnectedWallets(variables, headers);
  }
  async getConversationMessages(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.getConversationMessages(variables, headers);
  }
  async getEmailTargets(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.getEmailTargets(variables, headers);
  }
  async getDiscordTargets(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.getDiscordTargets(variables, headers);
  }
  async getFilters(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.getFilters(variables, headers);
  }
  async getFusionNotificationHistory(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.getFusionNotificationHistory(variables, headers);
  }
  /**
   * @deprecated Use getFusionNotificationHistory instead
   */
  async getNotificationHistory(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.getNotificationHistory(variables, headers);
  }
  async getSmsTargets(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.getSmsTargets(variables, headers);
  }
  async getSourceConnection(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.getSourceConnection(variables, headers);
  }
  async getSourceGroups(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.getSourceGroups(variables, headers);
  }
  async getSources(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.getSources(variables, headers);
  }
  async getTargetGroups(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.getTargetGroups(variables, headers);
  }
  async getTelegramTargets(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.getTelegramTargets(variables, headers);
  }
  async getTenantConnectedWallets(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.getTenantConnectedWallet(variables, headers);
  }
  async getTenantUser(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.getTenantUser(variables, headers);
  }
  async getTopics(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.getTopics(variables, headers);
  }
  async getUnreadNotificationHistoryCount(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.getUnreadNotificationHistoryCount(
      variables,
      headers
    );
  }
  async getUserSettings(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.getUserSettings(variables, headers);
  }
  async getWebhookTargets(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.getWebhookTargets(variables, headers);
  }
  async logInFromDapp(variables) {
    var _a, _b;
    const headers = this._requestHeaders();
    const result = await this._typedClient.logInFromDapp(variables, headers);
    const token = (_b = (_a = result.logInFromDapp) == null ? void 0 : _a.authorization) == null ? void 0 : _b.token;
    if (token !== void 0) {
      this._jwt = token;
    }
    return result;
  }
  async logInFromService(variables) {
    var _a;
    const headers = this._requestHeaders();
    const result = await this._typedClient.logInFromService(variables, headers);
    const token = (_a = result.logInFromService) == null ? void 0 : _a.token;
    if (token !== void 0) {
      this._jwt = token;
    }
    return result;
  }
  async markFusionNotificationHistoryAsRead(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.markFusionNotificationHistoryAsRead(
      variables,
      headers
    );
  }
  async updateUserSettings(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.updateUserSettings(variables, headers);
  }
  async refreshAuthorization(variables) {
    var _a;
    const headers = this._requestHeaders();
    const result = await this._typedClient.refreshAuthorization(
      variables,
      headers
    );
    const token = (_a = result.refreshAuthorization) == null ? void 0 : _a.token;
    if (token !== void 0) {
      this._jwt = token;
    }
    return result;
  }
  async removeSourceFromSourceGroup(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.removeSourceFromSourceGroup(variables, headers);
  }
  async sendConversationMessages(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.sendConversationMessage(variables, headers);
  }
  async sendEmailTargetVerificationRequest(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.sendEmailTargetVerificationRequest(
      variables,
      headers
    );
  }
  async sendMessage(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.sendMessage(variables, headers);
  }
  async updateSourceGroup(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.updateSourceGroup(variables, headers);
  }
  async updateTargetGroup(variables) {
    const headers = this._requestHeaders();
    return this._typedClient.updateTargetGroup(variables, headers);
  }
  _requestHeaders() {
    const requestId = v4_default();
    const headers = {
      "X-Request-Id": requestId,
      "X-Notifi-Client-Version": version
    };
    if (this._jwt !== void 0) {
      headers["Authorization"] = `Bearer ${this._jwt}`;
    }
    return headers;
  }
};

// node_modules/graphql-request/build/esm/index.js
init_shim();

// node_modules/graphql-request/build/esm/defaultJsonSerializer.js
init_shim();
var defaultJsonSerializer = JSON;

// node_modules/graphql-request/build/esm/helpers.js
init_shim();
var uppercase = (str) => str.toUpperCase();
var HeadersInstanceToPlainObject = (headers) => {
  const o = {};
  headers.forEach((v, k) => {
    o[k] = v;
  });
  return o;
};

// node_modules/graphql-request/build/esm/parseArgs.js
init_shim();
var parseRequestArgs = (documentOrOptions, variables, requestHeaders) => {
  return documentOrOptions.document ? documentOrOptions : {
    document: documentOrOptions,
    variables,
    requestHeaders,
    signal: void 0
  };
};
var parseRawRequestArgs = (queryOrOptions, variables, requestHeaders) => {
  return queryOrOptions.query ? queryOrOptions : {
    query: queryOrOptions,
    variables,
    requestHeaders,
    signal: void 0
  };
};
var parseBatchRequestArgs = (documentsOrOptions, requestHeaders) => {
  return documentsOrOptions.documents ? documentsOrOptions : {
    documents: documentsOrOptions,
    requestHeaders,
    signal: void 0
  };
};

// node_modules/graphql-request/build/esm/resolveRequestDocument.js
init_shim();
var extractOperationName = (document) => {
  var _a, _b;
  let operationName = void 0;
  const operationDefinitions = document.definitions.filter((definition) => definition.kind === `OperationDefinition`);
  if (operationDefinitions.length === 1) {
    operationName = (_b = (_a = operationDefinitions[0]) == null ? void 0 : _a.name) == null ? void 0 : _b.value;
  }
  return operationName;
};
var resolveRequestDocument = (document) => {
  if (typeof document === `string`) {
    let operationName2 = void 0;
    try {
      const parsedDocument = parse(document);
      operationName2 = extractOperationName(parsedDocument);
    } catch (err) {
    }
    return { query: document, operationName: operationName2 };
  }
  const operationName = extractOperationName(document);
  return { query: print(document), operationName };
};

// node_modules/graphql-request/build/esm/types.js
init_shim();
var ClientError = class _ClientError extends Error {
  constructor(response, request) {
    const message = `${_ClientError.extractMessage(response)}: ${JSON.stringify({
      response,
      request
    })}`;
    super(message);
    Object.setPrototypeOf(this, _ClientError.prototype);
    this.response = response;
    this.request = request;
    if (typeof Error.captureStackTrace === `function`) {
      Error.captureStackTrace(this, _ClientError);
    }
  }
  static extractMessage(response) {
    var _a, _b;
    return ((_b = (_a = response.errors) == null ? void 0 : _a[0]) == null ? void 0 : _b.message) ?? `GraphQL Error (Code: ${response.status})`;
  }
};

// node_modules/graphql-request/build/esm/index.js
var CrossFetch = __toESM(require_browser_ponyfill());

// node_modules/graphql-request/build/esm/graphql-ws.js
init_shim();
var CONNECTION_INIT = `connection_init`;
var CONNECTION_ACK = `connection_ack`;
var PING = `ping`;
var PONG = `pong`;
var SUBSCRIBE = `subscribe`;
var NEXT = `next`;
var ERROR = `error`;
var COMPLETE = `complete`;
var GraphQLWebSocketMessage = class _GraphQLWebSocketMessage {
  get type() {
    return this._type;
  }
  get id() {
    return this._id;
  }
  get payload() {
    return this._payload;
  }
  constructor(type, payload, id) {
    this._type = type;
    this._payload = payload;
    this._id = id;
  }
  get text() {
    const result = { type: this.type };
    if (this.id != null && this.id != void 0)
      result.id = this.id;
    if (this.payload != null && this.payload != void 0)
      result.payload = this.payload;
    return JSON.stringify(result);
  }
  static parse(data, f2) {
    const { type, payload, id } = JSON.parse(data);
    return new _GraphQLWebSocketMessage(type, f2(payload), id);
  }
};
var GraphQLWebSocketClient = class {
  constructor(socket, { onInit, onAcknowledged, onPing, onPong }) {
    this.socketState = { acknowledged: false, lastRequestId: 0, subscriptions: {} };
    this.socket = socket;
    socket.addEventListener(`open`, async (e) => {
      this.socketState.acknowledged = false;
      this.socketState.subscriptions = {};
      socket.send(ConnectionInit(onInit ? await onInit() : null).text);
    });
    socket.addEventListener(`close`, (e) => {
      this.socketState.acknowledged = false;
      this.socketState.subscriptions = {};
    });
    socket.addEventListener(`error`, (e) => {
      console.error(e);
    });
    socket.addEventListener(`message`, (e) => {
      try {
        const message = parseMessage(e.data);
        switch (message.type) {
          case CONNECTION_ACK: {
            if (this.socketState.acknowledged) {
              console.warn(`Duplicate CONNECTION_ACK message ignored`);
            } else {
              this.socketState.acknowledged = true;
              if (onAcknowledged)
                onAcknowledged(message.payload);
            }
            return;
          }
          case PING: {
            if (onPing)
              onPing(message.payload).then((r) => socket.send(Pong(r).text));
            else
              socket.send(Pong(null).text);
            return;
          }
          case PONG: {
            if (onPong)
              onPong(message.payload);
            return;
          }
        }
        if (!this.socketState.acknowledged) {
          return;
        }
        if (message.id === void 0 || message.id === null || !this.socketState.subscriptions[message.id]) {
          return;
        }
        const { query, variables, subscriber } = this.socketState.subscriptions[message.id];
        switch (message.type) {
          case NEXT: {
            if (!message.payload.errors && message.payload.data) {
              subscriber.next && subscriber.next(message.payload.data);
            }
            if (message.payload.errors) {
              subscriber.error && subscriber.error(new ClientError({ ...message.payload, status: 200 }, { query, variables }));
            } else {
            }
            return;
          }
          case ERROR: {
            subscriber.error && subscriber.error(new ClientError({ errors: message.payload, status: 200 }, { query, variables }));
            return;
          }
          case COMPLETE: {
            subscriber.complete && subscriber.complete();
            delete this.socketState.subscriptions[message.id];
            return;
          }
        }
      } catch (e2) {
        console.error(e2);
        socket.close(1006);
      }
      socket.close(4400, `Unknown graphql-ws message.`);
    });
  }
  makeSubscribe(query, operationName, subscriber, variables) {
    const subscriptionId = (this.socketState.lastRequestId++).toString();
    this.socketState.subscriptions[subscriptionId] = { query, variables, subscriber };
    this.socket.send(Subscribe(subscriptionId, { query, operationName, variables }).text);
    return () => {
      this.socket.send(Complete(subscriptionId).text);
      delete this.socketState.subscriptions[subscriptionId];
    };
  }
  rawRequest(query, variables) {
    return new Promise((resolve, reject) => {
      let result;
      this.rawSubscribe(query, {
        next: (data, extensions) => result = { data, extensions },
        error: reject,
        complete: () => resolve(result)
      }, variables);
    });
  }
  request(document, variables) {
    return new Promise((resolve, reject) => {
      let result;
      this.subscribe(document, {
        next: (data) => result = data,
        error: reject,
        complete: () => resolve(result)
      }, variables);
    });
  }
  subscribe(document, subscriber, variables) {
    const { query, operationName } = resolveRequestDocument(document);
    return this.makeSubscribe(query, operationName, subscriber, variables);
  }
  rawSubscribe(query, subscriber, variables) {
    return this.makeSubscribe(query, void 0, subscriber, variables);
  }
  ping(payload) {
    this.socket.send(Ping(payload).text);
  }
  close() {
    this.socket.close(1e3);
  }
};
GraphQLWebSocketClient.PROTOCOL = `graphql-transport-ws`;
function parseMessage(data, f2 = (a) => a) {
  const m = GraphQLWebSocketMessage.parse(data, f2);
  return m;
}
function ConnectionInit(payload) {
  return new GraphQLWebSocketMessage(CONNECTION_INIT, payload);
}
function Ping(payload) {
  return new GraphQLWebSocketMessage(PING, payload, void 0);
}
function Pong(payload) {
  return new GraphQLWebSocketMessage(PONG, payload, void 0);
}
function Subscribe(id, payload) {
  return new GraphQLWebSocketMessage(SUBSCRIBE, payload, id);
}
function Complete(id) {
  return new GraphQLWebSocketMessage(COMPLETE, void 0, id);
}

// node_modules/graphql-request/build/esm/index.js
var resolveHeaders = (headers) => {
  let oHeaders = {};
  if (headers) {
    if (typeof Headers !== `undefined` && headers instanceof Headers || CrossFetch && CrossFetch.Headers && headers instanceof CrossFetch.Headers) {
      oHeaders = HeadersInstanceToPlainObject(headers);
    } else if (Array.isArray(headers)) {
      headers.forEach(([name, value]) => {
        if (name && value !== void 0) {
          oHeaders[name] = value;
        }
      });
    } else {
      oHeaders = headers;
    }
  }
  return oHeaders;
};
var cleanQuery = (str) => str.replace(/([\s,]|#[^\n\r]+)+/g, ` `).trim();
var buildRequestConfig = (params) => {
  if (!Array.isArray(params.query)) {
    const params_2 = params;
    const search = [`query=${encodeURIComponent(cleanQuery(params_2.query))}`];
    if (params.variables) {
      search.push(`variables=${encodeURIComponent(params_2.jsonSerializer.stringify(params_2.variables))}`);
    }
    if (params_2.operationName) {
      search.push(`operationName=${encodeURIComponent(params_2.operationName)}`);
    }
    return search.join(`&`);
  }
  if (typeof params.variables !== `undefined` && !Array.isArray(params.variables)) {
    throw new Error(`Cannot create query with given variable type, array expected`);
  }
  const params_ = params;
  const payload = params.query.reduce((acc, currentQuery, index) => {
    acc.push({
      query: cleanQuery(currentQuery),
      variables: params_.variables ? params_.jsonSerializer.stringify(params_.variables[index]) : void 0
    });
    return acc;
  }, []);
  return `query=${encodeURIComponent(params_.jsonSerializer.stringify(payload))}`;
};
var createHttpMethodFetcher = (method) => async (params) => {
  const { url, query, variables, operationName, fetch: fetch2, fetchOptions, middleware } = params;
  const headers = { ...params.headers };
  let queryParams = ``;
  let body = void 0;
  if (method === `POST`) {
    body = createRequestBody(query, variables, operationName, fetchOptions.jsonSerializer);
    if (typeof body === `string`) {
      headers[`Content-Type`] = `application/json`;
    }
  } else {
    queryParams = buildRequestConfig({
      query,
      variables,
      operationName,
      jsonSerializer: fetchOptions.jsonSerializer ?? defaultJsonSerializer
    });
  }
  const init = {
    method,
    headers,
    body,
    ...fetchOptions
  };
  let urlResolved = url;
  let initResolved = init;
  if (middleware) {
    const result = await Promise.resolve(middleware({ ...init, url, operationName, variables }));
    const { url: urlNew, ...initNew } = result;
    urlResolved = urlNew;
    initResolved = initNew;
  }
  if (queryParams) {
    urlResolved = `${urlResolved}?${queryParams}`;
  }
  return await fetch2(urlResolved, initResolved);
};
var GraphQLClient = class {
  constructor(url, requestConfig = {}) {
    this.url = url;
    this.requestConfig = requestConfig;
    this.rawRequest = async (...args) => {
      const [queryOrOptions, variables, requestHeaders] = args;
      const rawRequestOptions = parseRawRequestArgs(queryOrOptions, variables, requestHeaders);
      const { headers, fetch: fetch2 = CrossFetch.default, method = `POST`, requestMiddleware, responseMiddleware, ...fetchOptions } = this.requestConfig;
      const { url: url2 } = this;
      if (rawRequestOptions.signal !== void 0) {
        fetchOptions.signal = rawRequestOptions.signal;
      }
      const { operationName } = resolveRequestDocument(rawRequestOptions.query);
      return makeRequest({
        url: url2,
        query: rawRequestOptions.query,
        variables: rawRequestOptions.variables,
        headers: {
          ...resolveHeaders(callOrIdentity(headers)),
          ...resolveHeaders(rawRequestOptions.requestHeaders)
        },
        operationName,
        fetch: fetch2,
        method,
        fetchOptions,
        middleware: requestMiddleware
      }).then((response) => {
        if (responseMiddleware) {
          responseMiddleware(response);
        }
        return response;
      }).catch((error) => {
        if (responseMiddleware) {
          responseMiddleware(error);
        }
        throw error;
      });
    };
  }
  async request(documentOrOptions, ...variablesAndRequestHeaders) {
    const [variables, requestHeaders] = variablesAndRequestHeaders;
    const requestOptions = parseRequestArgs(documentOrOptions, variables, requestHeaders);
    const { headers, fetch: fetch2 = CrossFetch.default, method = `POST`, requestMiddleware, responseMiddleware, ...fetchOptions } = this.requestConfig;
    const { url } = this;
    if (requestOptions.signal !== void 0) {
      fetchOptions.signal = requestOptions.signal;
    }
    const { query, operationName } = resolveRequestDocument(requestOptions.document);
    return makeRequest({
      url,
      query,
      variables: requestOptions.variables,
      headers: {
        ...resolveHeaders(callOrIdentity(headers)),
        ...resolveHeaders(requestOptions.requestHeaders)
      },
      operationName,
      fetch: fetch2,
      method,
      fetchOptions,
      middleware: requestMiddleware
    }).then((response) => {
      if (responseMiddleware) {
        responseMiddleware(response);
      }
      return response.data;
    }).catch((error) => {
      if (responseMiddleware) {
        responseMiddleware(error);
      }
      throw error;
    });
  }
  // prettier-ignore
  batchRequests(documentsOrOptions, requestHeaders) {
    const batchRequestOptions = parseBatchRequestArgs(documentsOrOptions, requestHeaders);
    const { headers, ...fetchOptions } = this.requestConfig;
    if (batchRequestOptions.signal !== void 0) {
      fetchOptions.signal = batchRequestOptions.signal;
    }
    const queries = batchRequestOptions.documents.map(({ document }) => resolveRequestDocument(document).query);
    const variables = batchRequestOptions.documents.map(({ variables: variables2 }) => variables2);
    return makeRequest({
      url: this.url,
      query: queries,
      // @ts-expect-error TODO reconcile batch variables into system.
      variables,
      headers: {
        ...resolveHeaders(callOrIdentity(headers)),
        ...resolveHeaders(batchRequestOptions.requestHeaders)
      },
      operationName: void 0,
      fetch: this.requestConfig.fetch ?? CrossFetch.default,
      method: this.requestConfig.method || `POST`,
      fetchOptions,
      middleware: this.requestConfig.requestMiddleware
    }).then((response) => {
      if (this.requestConfig.responseMiddleware) {
        this.requestConfig.responseMiddleware(response);
      }
      return response.data;
    }).catch((error) => {
      if (this.requestConfig.responseMiddleware) {
        this.requestConfig.responseMiddleware(error);
      }
      throw error;
    });
  }
  setHeaders(headers) {
    this.requestConfig.headers = headers;
    return this;
  }
  /**
   * Attach a header to the client. All subsequent requests will have this header.
   */
  setHeader(key, value) {
    const { headers } = this.requestConfig;
    if (headers) {
      headers[key] = value;
    } else {
      this.requestConfig.headers = { [key]: value };
    }
    return this;
  }
  /**
   * Change the client endpoint. All subsequent requests will send to this endpoint.
   */
  setEndpoint(value) {
    this.url = value;
    return this;
  }
};
var makeRequest = async (params) => {
  const { query, variables, fetchOptions } = params;
  const fetcher = createHttpMethodFetcher(uppercase(params.method ?? `post`));
  const isBatchingQuery = Array.isArray(params.query);
  const response = await fetcher(params);
  const result = await getResult(response, fetchOptions.jsonSerializer ?? defaultJsonSerializer);
  const successfullyReceivedData = Array.isArray(result) ? !result.some(({ data }) => !data) : Boolean(result.data);
  const successfullyPassedErrorPolicy = Array.isArray(result) || !result.errors || Array.isArray(result.errors) && !result.errors.length || fetchOptions.errorPolicy === `all` || fetchOptions.errorPolicy === `ignore`;
  if (response.ok && successfullyPassedErrorPolicy && successfullyReceivedData) {
    const { errors: _, ...rest } = Array.isArray(result) ? result : result;
    const data = fetchOptions.errorPolicy === `ignore` ? rest : result;
    const dataEnvelope = isBatchingQuery ? { data } : data;
    return {
      ...dataEnvelope,
      headers: response.headers,
      status: response.status
    };
  } else {
    const errorResult = typeof result === `string` ? {
      error: result
    } : result;
    throw new ClientError(
      // @ts-expect-error TODO
      { ...errorResult, status: response.status, headers: response.headers },
      { query, variables }
    );
  }
};
var createRequestBody = (query, variables, operationName, jsonSerializer) => {
  const jsonSerializer_ = jsonSerializer ?? defaultJsonSerializer;
  if (!Array.isArray(query)) {
    return jsonSerializer_.stringify({ query, variables, operationName });
  }
  if (typeof variables !== `undefined` && !Array.isArray(variables)) {
    throw new Error(`Cannot create request body with given variable type, array expected`);
  }
  const payload = query.reduce((acc, currentQuery, index) => {
    acc.push({ query: currentQuery, variables: variables ? variables[index] : void 0 });
    return acc;
  }, []);
  return jsonSerializer_.stringify(payload);
};
var getResult = async (response, jsonSerializer) => {
  let contentType;
  response.headers.forEach((value, key) => {
    if (key.toLowerCase() === `content-type`) {
      contentType = value;
    }
  });
  if (contentType && (contentType.toLowerCase().startsWith(`application/json`) || contentType.toLowerCase().startsWith(`application/graphql+json`) || contentType.toLowerCase().startsWith(`application/graphql-response+json`))) {
    return jsonSerializer.parse(await response.text());
  } else {
    return response.text();
  }
};
var callOrIdentity = (value) => {
  return typeof value === `function` ? value() : value;
};

// node_modules/@notifi-network/notifi-frontend-client/dist/index.mjs
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp2.call(b, prop))
      __defNormalProp2(a, prop, b[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b)) {
      if (__propIsEnum2.call(b, prop))
        __defNormalProp2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var checkIsConfigWithPublicKeyAndAddress = (config) => {
  return "accountAddress" in config;
};
var configFactoryPublicKey = (args) => {
  return {
    tenantId: args.tenantId,
    env: args.env,
    walletBlockchain: args.walletBlockchain,
    walletPublicKey: args.account.publicKey,
    storageOption: args.storageOption
  };
};
var configFactoryPublicKeyAndAddress = (args) => {
  return {
    tenantId: args.tenantId,
    env: args.env,
    walletBlockchain: args.walletBlockchain,
    authenticationKey: args.account.publicKey,
    accountAddress: args.account.address,
    storageOption: args.storageOption
  };
};
var validateConfigInput = (config) => {
  return "address" in config.account;
};
var newFrontendConfig = (config) => {
  return validateConfigInput(config) ? configFactoryPublicKeyAndAddress(config) : configFactoryPublicKey(config);
};
var envUrl = (env) => {
  switch (env) {
    case "Development":
      return "https://api.dev.notifi.network/gql";
    case "Local":
      return "https://localhost:5001/gql";
    case "Production":
      return "https://api.notifi.network/gql";
    case "Staging":
      return "https://api.stg.notifi.network/gql";
  }
};
var notNullOrEmpty = (item) => {
  return item !== void 0 && item !== null;
};
var packFilterOptions = (clientOptions) => {
  if (clientOptions === null) {
    return "{}";
  }
  return JSON.stringify(clientOptions);
};
var areIdsEqual = (ids, items) => {
  const idSet = new Set(ids);
  return items.length === idSet.size && items.every((it) => it !== void 0 && idSet.has(it.id));
};
var createRefResolver = (validator) => {
  return (name, valueOrRef, inputs) => {
    if (valueOrRef.type === "value") {
      return valueOrRef.value;
    } else {
      if (valueOrRef.ref === null) {
        throw new Error(`Invalid configuration: Ref ${name} is null`);
      }
      const runtimeInput = inputs[valueOrRef.ref];
      if (validator(runtimeInput)) {
        return runtimeInput;
      } else {
        throw new Error(`Invalid value provided for ${name}: ${runtimeInput}`);
      }
    }
  };
};
var resolveStringRef = createRefResolver(
  (item) => {
    return typeof item === "string";
  }
);
var resolveNumberRef = createRefResolver(
  (item) => {
    return typeof item === "number" && !Number.isNaN(item);
  }
);
var resolveStringArrayRef = createRefResolver(
  (item) => {
    return Array.isArray(item) && item.every((element) => typeof element === "string");
  }
);
var resolveCheckRatioArrayRef = createRefResolver(
  (item) => {
    return Array.isArray(item) && item.every(
      (element) => typeof element === "object" && typeof element.type === "string" && typeof element.ratio === "number" && !Number.isNaN(element.ratio)
    );
  }
);
var ensureDirectPushSource = async (service, _eventType, _inputs) => {
  const sourcesQuery = await service.getSources({});
  const sources = sourcesQuery.source;
  const source = sources == null ? void 0 : sources.find(
    (it) => it !== void 0 && it.type === "DIRECT_PUSH"
  );
  if (source === void 0) {
    throw new Error("Failed to identify direct push source");
  }
  return source;
};
var ensureFusionSource = async (service, eventType, inputs) => {
  const address = resolveStringRef(
    eventType.name,
    eventType.sourceAddress,
    inputs
  );
  const eventTypeId = resolveStringRef(
    eventType.name,
    eventType.fusionEventId,
    inputs
  );
  const sourcesQuery = await service.getSources({});
  const sources = sourcesQuery.source;
  const existing = sources == null ? void 0 : sources.find(
    (it) => it !== void 0 && it.type === "FUSION_SOURCE" && it.blockchainAddress === address && it.fusionEventTypeId === eventTypeId
  );
  if (existing !== void 0) {
    return existing;
  }
  const createMutation = await service.createSource({
    type: "FUSION_SOURCE",
    blockchainAddress: address,
    fusionEventTypeId: eventTypeId
  });
  const source = createMutation.createSource;
  if (source === void 0) {
    throw new Error("Failed to create source");
  }
  return source;
};
var ensureBroadcastSource = async (service, eventType, inputs) => {
  const sourcesQuery = await service.getSources({});
  const sources = sourcesQuery.source;
  if (sources === void 0) {
    throw new Error("Failed to fetch sources");
  }
  const address = resolveStringRef(
    eventType.name,
    eventType.broadcastId,
    inputs
  );
  const existing = sources.find(
    (it) => (it == null ? void 0 : it.type) === "BROADCAST" && it.blockchainAddress === address
  );
  if (existing !== void 0) {
    return existing;
  }
  const createMutation = await service.createSource({
    type: "BROADCAST",
    blockchainAddress: address
  });
  const result = createMutation.createSource;
  if (result === void 0) {
    throw new Error("Failed to create source");
  }
  return result;
};
var ensureTradingPairSource = async (service, _eventType, _inputs) => {
  const sourcesQuery = await service.getSources({});
  const sources = sourcesQuery.source;
  const source = sources == null ? void 0 : sources.find((it) => (it == null ? void 0 : it.type) === "DIRECT_PUSH");
  if (source === void 0) {
    throw new Error("Failed to identify trading pair source (=directPush)");
  }
  return source;
};
var ensurePriceChangeSources = async (service, eventType, _inputs) => {
  const sourcesQuery = await service.getSources({});
  const sources = sourcesQuery.source;
  if (sources === void 0) {
    throw new Error("Failed to fetch sources");
  }
  const results = [];
  const sourcesToCreate = new Set(eventType.tokenIds);
  sources.forEach((existing) => {
    if ((existing == null ? void 0 : existing.type) === "COIN_PRICE_CHANGES") {
      sourcesToCreate.delete(existing.blockchainAddress);
      results.push(existing);
    }
  });
  if (sourcesToCreate.size > 0) {
    let createSourcePromise = Promise.resolve();
    sourcesToCreate.forEach((tokenId) => {
      createSourcePromise = createSourcePromise.then(async () => {
        const result = await service.createSource({
          type: "COIN_PRICE_CHANGES",
          blockchainAddress: tokenId
        });
        const source = result.createSource;
        if (source !== void 0) {
          results.push(source);
        }
      });
    });
    await createSourcePromise;
  }
  return results;
};
var ensureWalletBalanceSources = async (service, _eventType, _inputs) => {
  const connectedWalletsQuery = await service.getConnectedWallets({});
  const connectedWallets = connectedWalletsQuery.connectedWallet;
  if (!connectedWallets) {
    throw new Error("Failed to fetch connected wallets");
  }
  const connectedWalletSources = connectedWallets.map((it) => {
    var _a;
    const sourceType = ((wallet) => {
      switch (wallet) {
        case "ACALA":
          return "ACALA_WALLET";
        case "APTOS":
          return "APTOS_WALLET";
        case "ARBITRUM":
          return "ARBITRUM_WALLET";
        case "AVALANCHE":
          return "AVALANCHE_WALLET";
        case "BINANCE":
          return "BINANCE_WALLET";
        case "ETHEREUM":
          return "ETHEREUM_WALLET";
        case "BASE":
          return "ETHEREUM_WALLET";
        case "POLYGON":
          return "POLYGON_WALLET";
        case "SOLANA":
          return "SOLANA_WALLET";
        case "OPTIMISM":
          return "OPTIMISM_WALLET";
        case "SUI":
          return "SUI_WALLET";
        case "ZKSYNC":
          return "ZKSYNC_WALLET";
        default:
          throw new Error("Unsupported walletType");
      }
    })(it == null ? void 0 : it.walletBlockchain);
    const sourceAddress = (_a = it == null ? void 0 : it.address) != null ? _a : "";
    return {
      name: `${sourceType} ${sourceAddress}`,
      blockchainAddress: sourceAddress,
      type: sourceType
    };
  });
  const sourcesQuery = await service.getSources({});
  const sources = sourcesQuery.source;
  if (sources === void 0) {
    throw new Error("Failed to fetch sources");
  }
  const promises = connectedWalletSources.map(async (connectedWalletSource) => {
    const found = sources.find(
      (source) => (source == null ? void 0 : source.name) === connectedWalletSource.name
    );
    if (found) {
      return found;
    }
    const { createSource: newSource } = await service.createSource(
      connectedWalletSource
    );
    if (!newSource) {
      throw new Error(`Failed to create ${connectedWalletSource.type} source`);
    }
    return newSource;
  });
  const ensuredSources = await Promise.all(promises);
  return ensuredSources;
};
var normalizeSourceAddress = (sourceType, blockchainAddress) => {
  switch (sourceType) {
    case "ETHEREUM_WALLET":
    case "POLYGON_WALLET":
    case "ARBITRUM_WALLET":
    case "BINANCE_WALLET":
    case "OPTIMISM_WALLET":
    case "AVALANCHE_WALLET":
    case "ZKSYNC_WALLET":
    case "BENQI":
    case "DELTA_PRIME":
    case "DELTA_PRIME_LENDING_RATES":
    case "APTOS_WALLET":
      return normalizeHexString(blockchainAddress);
    default:
      return blockchainAddress;
  }
};
var normalizeHexString = (input) => {
  let result = input;
  if (input !== "") {
    result = input.toLowerCase();
    if (!result.startsWith("0x")) {
      result = "0x" + result;
    }
  }
  return result;
};
var ensureCustomSources = async (service, eventType, inputs) => {
  const sourcesQuery = await service.getSources({});
  const sources = sourcesQuery.source;
  if (sources === void 0) {
    throw new Error("Failed to fetch sources");
  }
  const address = resolveStringRef(
    eventType.name,
    eventType.sourceAddress,
    inputs
  );
  const sourceAddress = normalizeSourceAddress(eventType.sourceType, address);
  const existing = sources.find(
    (it) => (it == null ? void 0 : it.type) === eventType.sourceType && it.blockchainAddress === sourceAddress
  );
  if (existing !== void 0) {
    return existing;
  }
  const createMutation = await service.createSource({
    type: eventType.sourceType,
    blockchainAddress: sourceAddress
  });
  const result = createMutation.createSource;
  if (result === void 0) {
    throw new Error("Failed to create source");
  }
  return result;
};
var ensureXMTPSources = async (service, eventType, inputs) => {
  const sourcesQuery = await service.getSources({});
  const sources = sourcesQuery.source;
  if (sources === void 0) {
    throw new Error("Failed to fetch sources");
  }
  const XMTPTopics = resolveStringArrayRef(
    eventType.name,
    eventType.XMTPTopics,
    inputs
  );
  const XMTPTopicSources = XMTPTopics.map((topic) => ({
    name: topic,
    blockchainAddress: topic,
    type: "XMTP"
  }));
  const promises = XMTPTopicSources.map(async (source) => {
    const found = sources.find(
      (it) => (it == null ? void 0 : it.type) === "XMTP" && it.name === source.name
    );
    if (found) {
      return found;
    }
    const { createSource: newSource } = await service.createSource(source);
    if (!newSource) {
      throw new Error("Failed to create XMTP source");
    }
    return newSource;
  });
  const ensuredSources = await Promise.all(promises);
  return ensuredSources;
};
var ensureHealthCheckSources = async (service, _eventType, _inputs) => {
  const sourcesQuery = await service.getSources({});
  const sources = sourcesQuery.source;
  const source = sources == null ? void 0 : sources.find((it) => (it == null ? void 0 : it.type) === "DIRECT_PUSH");
  if (source === void 0) {
    throw new Error("Failed to identify Health Check source (=directPush)");
  }
  return source;
};
var ensureCreateSupportConversationSources = async (service, eventType, _inputs) => {
  const sourcesQuery = await service.getSources({});
  const sources = sourcesQuery.source;
  const source = sources == null ? void 0 : sources.find((it) => (it == null ? void 0 : it.type) === "NOTIFI_CHAT");
  if (source) {
    return source;
  }
  const createMutation = await service.createSource({
    type: eventType.sourceType,
    blockchainAddress: "*"
  });
  const newSource = createMutation.createSource;
  if (newSource === void 0) {
    throw new Error("Failed to create source");
  }
  return newSource;
};
var ensureSources = async (service, eventType, inputs) => {
  switch (eventType.type) {
    case "directPush": {
      const source = await ensureDirectPushSource(service, eventType, inputs);
      return [source];
    }
    case "broadcast": {
      const source = await ensureBroadcastSource(service, eventType, inputs);
      return [source];
    }
    case "tradingPair": {
      const source = await ensureTradingPairSource(service, eventType, inputs);
      return [source];
    }
    case "priceChange": {
      const sources = await ensurePriceChangeSources(
        service,
        eventType,
        inputs
      );
      return sources;
    }
    case "walletBalance": {
      const sources = await ensureWalletBalanceSources(
        service,
        eventType,
        inputs
      );
      return sources;
    }
    case "custom": {
      const source = await ensureCustomSources(service, eventType, inputs);
      return [source];
    }
    case "XMTP": {
      const sources = await ensureXMTPSources(service, eventType, inputs);
      return sources;
    }
    case "healthCheck": {
      const source = await ensureHealthCheckSources(service, eventType, inputs);
      return [source];
    }
    case "fusionToggle":
    case "fusion": {
      const source = await ensureFusionSource(service, eventType, inputs);
      return [source];
    }
    case "createSupportConversation": {
      const source = await ensureCreateSupportConversationSources(
        service,
        eventType,
        inputs
      );
      return [source];
    }
    case "label": {
      throw new Error("Unsupported event type");
    }
  }
};
var ensureSourceGroup = async (service, name, sourceIds) => {
  var _a, _b;
  const sourceGroupsQuery = await service.getSourceGroups({});
  const existing = (_a = sourceGroupsQuery.sourceGroup) == null ? void 0 : _a.find(
    (it) => it !== void 0 && it.name === name
  );
  if (existing === void 0) {
    const createMutation = await service.createSourceGroup({
      name,
      sourceIds
    });
    const createResult = createMutation.createSourceGroup;
    if (createResult === void 0) {
      throw new Error("Failed to create source group");
    }
    return createResult;
  }
  if (areIdsEqual(sourceIds, (_b = existing.sources) != null ? _b : [])) {
    return existing;
  }
  const updateMutation = await service.updateSourceGroup({
    id: existing.id,
    name,
    sourceIds
  });
  const updateResult = updateMutation.updateSourceGroup;
  if (updateResult === void 0) {
    throw new Error("Failed to update source group");
  }
  return updateResult;
};
var getDirectPushFilter = (source, eventType, inputs) => {
  var _a;
  const filter = (_a = source.applicableFilters) == null ? void 0 : _a.find(
    (it) => (it == null ? void 0 : it.filterType) === "DIRECT_TENANT_MESSAGES"
  );
  if (filter === void 0) {
    throw new Error("Failed to retrieve filter");
  }
  const type = resolveStringRef(eventType.name, eventType.directPushId, inputs);
  const filterOptions = {
    directMessageType: type
  };
  return {
    filter,
    filterOptions
  };
};
var getBroadcastFilter = (source, _eventType, _inputs) => {
  var _a;
  const filter = (_a = source.applicableFilters) == null ? void 0 : _a.find(
    (it) => (it == null ? void 0 : it.filterType) === "BROADCAST_MESSAGES"
  );
  if (filter === void 0) {
    throw new Error("Failed to retrieve filter");
  }
  return {
    filter,
    filterOptions: {}
  };
};
var tradingPairInputsValidator = (inputs) => {
  if (typeof inputs.direction !== "string" || typeof inputs.price !== "number" || typeof inputs.pair !== "string") {
    return false;
  }
  return true;
};
var getTradingPairFilter = (source, eventType, inputs) => {
  var _a;
  const filter = (_a = source.applicableFilters) == null ? void 0 : _a.find(
    (it) => (it == null ? void 0 : it.filterType) === "DIRECT_TENANT_MESSAGES"
  );
  if (filter === void 0) {
    throw new Error("Failed to retrieve TradingPair filter (=directMessage)");
  }
  const tradingPairs = resolveStringArrayRef(
    eventType.name,
    eventType.tradingPairs,
    inputs
  );
  if (tradingPairs.length === 0)
    throw new Error("No trading pairs found");
  const tradingPair = tradingPairInputsValidator(inputs) ? inputs.pair : tradingPairs[0];
  const value = tradingPairInputsValidator(inputs) ? inputs.price.toFixed(8) : "1.00000000";
  return {
    filter,
    filterOptions: {
      tradingPair,
      values: {
        and: [
          {
            key: "spotPrice",
            op: inputs.direction === "above" ? "gt" : "lt",
            value
          }
        ]
      }
    }
  };
};
var getPriceChangeFilter = (sources, _eventType, _inputs) => {
  const filter = sources.flatMap((it) => {
    var _a;
    return (_a = it.applicableFilters) != null ? _a : [];
  }).find((it) => (it == null ? void 0 : it.filterType) === "COIN_PRICE_CHANGE_EVENTS");
  if (filter === void 0) {
    throw new Error("Failed to retrieve filter");
  }
  return {
    filter,
    filterOptions: {}
  };
};
var getWalletBalanceSourceFilter = (source, _eventType, _inputs) => {
  var _a;
  const filter = (_a = source.applicableFilters) == null ? void 0 : _a.find(
    (it) => (it == null ? void 0 : it.filterType) === "BALANCE"
  );
  if (filter === void 0) {
    throw new Error("Failed to retrieve filter: wallet balance");
  }
  return {
    filter,
    filterOptions: {}
  };
};
var getFusionSourceFilter = (source, eventType, inputs) => {
  var _a, _b;
  const filter = (_a = source.applicableFilters) == null ? void 0 : _a.find(
    (it) => (it == null ? void 0 : it.filterType) === "FUSION_SOURCE"
  );
  if (filter === void 0) {
    throw new Error("Failed to retrieve fusion source filter");
  }
  let filterOptions = {};
  if (eventType.selectedUIType === "TOGGLE" || eventType.selectedUIType === "MULTI_THRESHOLD") {
    if (eventType.alertFrequency !== void 0) {
      filterOptions = {
        alertFrequency: eventType.alertFrequency
      };
    }
  } else if (eventType.selectedUIType === "HEALTH_CHECK") {
    const healthRatioKey = `${eventType.name}__healthRatio`;
    if (!inputs[healthRatioKey]) {
      inputs[`${eventType.name}__healthRatio`] = eventType.checkRatios[1].ratio;
    }
    const healthRatio = resolveNumberRef(
      healthRatioKey,
      { type: "ref", ref: healthRatioKey },
      inputs
    );
    const thresholdDirectionKey = `${eventType.name}__healthThresholdDirection`;
    if (!inputs[thresholdDirectionKey]) {
      inputs[thresholdDirectionKey] = eventType.checkRatios[0].type === "above" ? "above" : "below";
    }
    const thresholdDirection = (_b = resolveStringRef(
      thresholdDirectionKey,
      { type: "ref", ref: thresholdDirectionKey },
      inputs
    )) != null ? _b : eventType.checkRatios[0].ratio;
    if (!healthRatio || !thresholdDirection) {
      throw new Error("Failed to retrieve health ratio or direction");
    }
    filterOptions = {
      alertFrequency: eventType.alertFrequency,
      threshold: eventType.numberType === "percentage" ? healthRatio / 100 : healthRatio,
      thresholdDirection: thresholdDirection === "above" ? "above" : "below"
    };
  }
  return {
    filter,
    filterOptions
  };
};
var getCustomFilterOptions = (eventType, inputs) => {
  var _a, _b;
  switch (eventType.selectedUIType) {
    case "TOGGLE":
      return eventType.filterOptions;
    case "HEALTH_CHECK": {
      const healthRatioKey = `${eventType.name}__healthRatio`;
      const healthRatio = (_a = resolveNumberRef(
        healthRatioKey,
        { type: "ref", ref: healthRatioKey },
        inputs
      )) != null ? _a : eventType.checkRatios[0].ratio;
      const thresholdDirectionKey = `${eventType.name}__healthThresholdDirection`;
      const thresholdDirection = (_b = resolveStringRef(
        thresholdDirectionKey,
        { type: "ref", ref: thresholdDirectionKey },
        inputs
      )) != null ? _b : eventType.checkRatios[0].ratio;
      if (!healthRatio || !thresholdDirection) {
        throw new Error("Failed to retrieve health ratio or direction");
      }
      return {
        alertFrequency: eventType.alertFrequency,
        threshold: eventType.numberType === "percentage" ? healthRatio / 100 : healthRatio,
        thresholdDirection: thresholdDirection === "above" ? "above" : "below"
      };
    }
  }
};
var getCustomFilter = (source, eventType, inputs) => {
  var _a;
  const filter = (_a = source.applicableFilters) == null ? void 0 : _a.find(
    (it) => (it == null ? void 0 : it.filterType) === eventType.filterType
  );
  if (filter === void 0) {
    throw new Error("Failed to retrieve filter");
  }
  return {
    filter,
    filterOptions: getCustomFilterOptions(eventType, inputs)
  };
};
var getXMTPFilter = (source, _eventType, _inputs) => {
  var _a;
  const filter = (_a = source.applicableFilters) == null ? void 0 : _a.find(
    (it) => (it == null ? void 0 : it.filterType) === "WEB3_CHAT_MESSAGES"
  );
  if (filter === void 0) {
    throw new Error("Failed to retrieve filter: XMTP");
  }
  return {
    filter,
    filterOptions: {}
  };
};
var getCreateSupportConversationFilter = (source, eventType, _inputs) => {
  var _a;
  const filter = (_a = source.applicableFilters) == null ? void 0 : _a.find(
    (it) => (it == null ? void 0 : it.filterType) === "NOTIFI_CHAT_MESSAGES"
  );
  if (filter === void 0) {
    throw new Error("Failed to retrieve filter: CreateSupportConversation");
  }
  return {
    filter,
    filterOptions: {
      alertFrequency: eventType.alertFrequency
    }
  };
};
var checkInputsIsWithIndex = (inputs) => {
  if ("index" in inputs) {
    return true;
  }
  return false;
};
var getHealthCheckFilter = (source, eventType, inputs) => {
  var _a;
  const filter = (_a = source.applicableFilters) == null ? void 0 : _a.find(
    (it) => (it == null ? void 0 : it.filterType) === "VALUE_THRESHOLD"
  );
  if (filter === void 0) {
    throw new Error("Failed to retrieve filter: healthCheck");
  }
  const checkRatios = resolveCheckRatioArrayRef(
    eventType.name,
    eventType.checkRatios,
    inputs
  );
  let threshold = checkRatios[0].ratio;
  let thresholdDirection = checkRatios[0].type;
  const checkInputsIsWithCustomPercentage = (inputs2) => {
    if ("customPercentage" in inputs2 && "thresholdDirection" in inputs2) {
      return true;
    }
    return false;
  };
  if (checkInputsIsWithIndex(inputs)) {
    threshold = checkRatios[inputs.index].ratio;
    thresholdDirection = checkRatios[inputs.index].type;
  } else if (checkInputsIsWithCustomPercentage(inputs)) {
    threshold = inputs.customPercentage;
    thresholdDirection = inputs.thresholdDirection;
  }
  return {
    filter,
    filterOptions: {
      alertFrequency: eventType.alertFrequency,
      threshold,
      thresholdDirection
    }
  };
};
var ensureSourceAndFilters = async (service, eventType, inputs) => {
  const sources = await ensureSources(service, eventType, inputs);
  const sourceGroup = await ensureSourceGroup(
    service,
    eventType.name,
    sources.map((it) => it.id)
  );
  switch (eventType.type) {
    case "directPush": {
      const { filter, filterOptions } = getDirectPushFilter(
        sources[0],
        eventType,
        inputs
      );
      return {
        sourceGroup,
        filter,
        filterOptions
      };
    }
    case "broadcast": {
      const { filter, filterOptions } = getBroadcastFilter(
        sources[0],
        eventType,
        inputs
      );
      return {
        sourceGroup,
        filter,
        filterOptions
      };
    }
    case "tradingPair": {
      if (!tradingPairInputsValidator(inputs)) {
        throw new Error("Invalid tradingPair inputs");
      }
      const { filter, filterOptions } = getTradingPairFilter(
        sources[0],
        eventType,
        inputs
      );
      return {
        sourceGroup,
        filter,
        filterOptions
      };
    }
    case "priceChange": {
      const { filter, filterOptions } = getPriceChangeFilter(
        sources,
        eventType,
        inputs
      );
      return {
        sourceGroup,
        filter,
        filterOptions
      };
    }
    case "custom": {
      const { filter, filterOptions } = getCustomFilter(
        sources[0],
        eventType,
        inputs
      );
      return {
        sourceGroup,
        filter,
        filterOptions
      };
    }
    case "XMTP": {
      const { filter, filterOptions } = getXMTPFilter(
        sources[0],
        eventType,
        inputs
      );
      return {
        sourceGroup,
        filter,
        filterOptions
      };
    }
    case "healthCheck": {
      const { filter, filterOptions } = getHealthCheckFilter(
        sources[0],
        eventType,
        inputs
      );
      return {
        sourceGroup,
        filter,
        filterOptions
      };
    }
    case "label": {
      throw new Error("Unsupported event type");
    }
    case "walletBalance": {
      const { filter, filterOptions } = getWalletBalanceSourceFilter(
        sources[0],
        eventType,
        inputs
      );
      return {
        sourceGroup,
        filter,
        filterOptions
      };
    }
    case "fusionToggle":
    case "fusion": {
      const { filter, filterOptions } = getFusionSourceFilter(
        sources[0],
        eventType,
        inputs
      );
      return {
        sourceGroup,
        filter,
        filterOptions
      };
    }
    case "createSupportConversation": {
      const { filter, filterOptions } = getCreateSupportConversationFilter(
        sources[0],
        eventType,
        inputs
      );
      return {
        sourceGroup,
        filter,
        filterOptions
      };
    }
  }
};
var ensureTarget = (create, fetch2, identify, valueTransform) => {
  return async (service, value) => {
    if (value === void 0) {
      return void 0;
    }
    const existing = await fetch2(service);
    const transformedValue = valueTransform !== void 0 ? valueTransform(value) : value;
    const found = existing == null ? void 0 : existing.find((it) => identify(it) === transformedValue);
    if (found !== void 0) {
      return found.id;
    }
    const created = await create(service, transformedValue);
    return created.id;
  };
};
var ensureEmail = ensureTarget(
  async (service, value) => {
    const mutation = await service.createEmailTarget({
      name: value.toLowerCase(),
      value: value.toLowerCase()
    });
    const result = mutation.createEmailTarget;
    if (result === void 0) {
      throw new Error("Failed to create email target");
    }
    return result;
  },
  async (service) => {
    const query = await service.getEmailTargets({});
    return query.emailTarget;
  },
  (arg) => {
    var _a;
    return (_a = arg == null ? void 0 : arg.emailAddress) == null ? void 0 : _a.toLowerCase();
  },
  (value) => value.toLowerCase()
);
var ensureSms = ensureTarget(
  async (service, value) => {
    const mutation = await service.createSmsTarget({
      name: value,
      value
    });
    const result = mutation.createSmsTarget;
    if (result === void 0) {
      throw new Error("Failed to create sms target");
    }
    return result;
  },
  async (service) => {
    const query = await service.getSmsTargets({});
    return query.smsTarget;
  },
  (arg) => arg == null ? void 0 : arg.phoneNumber
);
var ensureTelegram = ensureTarget(
  async (service, value) => {
    const mutation = await service.createTelegramTarget({
      name: value.toLowerCase(),
      value: value.toLowerCase()
    });
    const result = mutation.createTelegramTarget;
    if (result === void 0) {
      throw new Error("Failed to create telegramTarget");
    }
    return result;
  },
  async (service) => {
    const query = await service.getTelegramTargets({});
    return query.telegramTarget;
  },
  (arg) => {
    var _a;
    return (_a = arg == null ? void 0 : arg.telegramId) == null ? void 0 : _a.toLowerCase();
  },
  (value) => value.toLowerCase()
);
var ensureDiscord = ensureTarget(
  async (service, value) => {
    const mutation = await service.createDiscordTarget({
      name: value,
      value
    });
    const result = mutation.createDiscordTarget;
    if (result === void 0) {
      throw new Error("Failed to create discordTarget");
    }
    return result;
  },
  async (service) => {
    const query = await service.getDiscordTargets({});
    return query.discordTarget;
  },
  (arg) => arg == null ? void 0 : arg.name,
  () => "Default"
);
var ensureWebhook = async (service, params) => {
  if (params === void 0) {
    return void 0;
  }
  const query = await service.getWebhookTargets({});
  const existing = query.webhookTarget;
  const found = existing == null ? void 0 : existing.find(
    (it) => (it == null ? void 0 : it.url.toLowerCase()) === params.url.toLowerCase() && (it == null ? void 0 : it.format) === params.format
  );
  if (found !== void 0) {
    return found.id;
  }
  const mutation = await service.createWebhookTarget(__spreadProps(__spreadValues2({}, params), {
    name: params.url.toLowerCase(),
    url: params.url.toLowerCase()
  }));
  const created = mutation.createWebhookTarget;
  if (created === void 0) {
    throw new Error("Failed to create webhook target");
  }
  return created.id;
};
var getEnvPrefix = (env) => {
  switch (env) {
    case "Production":
      return "notifi-jwt";
    case "Development":
      return "notifi-jwt:dev";
    case "Staging":
      return "notifi-jwt:stg";
    case "Local":
      return "notifi-jwt:local";
  }
};
var createInMemoryStorageDriver = (config) => {
  let keyPrefix = `${getEnvPrefix(config.env)}:${config.tenantId}:${config.walletBlockchain}`;
  if (checkIsConfigWithPublicKeyAndAddress(config)) {
    keyPrefix += `:${config.accountAddress}:${config.authenticationKey}`;
  } else {
    keyPrefix += `:${config.walletPublicKey}`;
  }
  const storageBackend = {};
  const storageDriver = {
    get: (key) => {
      const newKey = `${keyPrefix}:${key}`;
      let result = null;
      if (newKey in storageBackend) {
        const json = storageBackend[newKey];
        result = JSON.parse(json);
      }
      return Promise.resolve(result);
    },
    set: (key, newValue) => {
      const newKey = `${keyPrefix}:${key}`;
      if (newValue === null) {
        delete storageBackend[newKey];
      } else {
        storageBackend[newKey] = JSON.stringify(newValue);
      }
      return Promise.resolve();
    },
    has: (key) => {
      const newKey = `${keyPrefix}:${key}`;
      return Promise.resolve(newKey in storageBackend);
    }
  };
  return storageDriver;
};
var KEY_AUTHORIZATION = "authorization";
var KEY_ROLES = "roles";
var NotifiFrontendStorage = class {
  constructor(_driver) {
    this._driver = _driver;
  }
  getAuthorization() {
    return this._driver.get(KEY_AUTHORIZATION);
  }
  setAuthorization(newValue) {
    return this._driver.set(KEY_AUTHORIZATION, newValue);
  }
  hasAuthorization() {
    return this._driver.has(KEY_AUTHORIZATION);
  }
  getRoles() {
    return this._driver.get(KEY_ROLES);
  }
  setRoles(newValue) {
    return this._driver.set(KEY_ROLES, newValue);
  }
  hasRoles() {
    return this._driver.has(KEY_ROLES);
  }
};
import_localforage.default.config({
  name: "notifi"
});
var getEnvPrefix2 = (env) => {
  switch (env) {
    case "Production":
      return "notifi-jwt";
    case "Development":
      return "notifi-jwt:dev";
    case "Staging":
      return "notifi-jwt:stg";
    case "Local":
      return "notifi-jwt:local";
  }
};
var createLocalForageStorageDriver = (config) => {
  let keyPrefix = `${getEnvPrefix2(config.env)}:${config.tenantId}:${config.walletBlockchain}`;
  if (checkIsConfigWithPublicKeyAndAddress(config)) {
    keyPrefix += `:${config.accountAddress}:${config.authenticationKey}`;
  } else {
    keyPrefix += `:${config.walletPublicKey}`;
  }
  const storageDriver = {
    get: async (key) => {
      const item = await import_localforage.default.getItem(`${keyPrefix}:${key}`);
      return item;
    },
    set: async (key, newValue) => {
      await import_localforage.default.setItem(`${keyPrefix}:${key}`, newValue);
    },
    has: async (key) => {
      const keys = await import_localforage.default.keys();
      return keys.indexOf(`${keyPrefix}:${key}`) >= 0;
    }
  };
  return storageDriver;
};
var SIGNING_MESSAGE = `Sign in with Notifi 

    No password needed or gas is needed. 

    Clicking “Approve” only means you have proved this wallet is owned by you! 

    This request will not trigger any transaction or cost any gas fees. 

    Use of our website and service is subject to our terms of service and privacy policy. 
 
 'Nonce:' `;
var NotifiFrontendClient = class {
  constructor(_configuration, _service, _storage) {
    this._configuration = _configuration;
    this._service = _service;
    this._storage = _storage;
    this._clientRandomUuid = null;
    this._userState = null;
  }
  get userState() {
    return this._userState;
  }
  async initialize() {
    const [storedAuthorization, roles] = await Promise.all([
      this._storage.getAuthorization(),
      this._storage.getRoles()
    ]);
    let authorization = storedAuthorization;
    if (authorization === null) {
      this._service.setJwt(void 0);
      const logOutStatus = {
        status: "loggedOut"
      };
      this._userState = logOutStatus;
      return logOutStatus;
    }
    const expiryDate = new Date(authorization.expiry);
    const now = /* @__PURE__ */ new Date();
    if (expiryDate <= now) {
      this._service.setJwt(void 0);
      const expiredStatus = {
        status: "expired",
        authorization
      };
      this._userState = expiredStatus;
      return expiredStatus;
    }
    const refreshTime = /* @__PURE__ */ new Date();
    refreshTime.setDate(now.getDate() + 7);
    if (expiryDate < refreshTime) {
      try {
        const refreshMutation = await this._service.refreshAuthorization({});
        const newAuthorization = refreshMutation.refreshAuthorization;
        if (newAuthorization !== void 0) {
          this._storage.setAuthorization(newAuthorization);
          authorization = newAuthorization;
        }
      } catch (e) {
        console.log("Failed to refresh Notifi token", e);
      }
    }
    this._service.setJwt(authorization.token);
    const userState = {
      status: "authenticated",
      authorization,
      roles: roles != null ? roles : []
    };
    this._userState = userState;
    return userState;
  }
  async logOut() {
    await Promise.all([
      this._storage.setAuthorization(null),
      this._storage.setRoles(null),
      this._service.logOut()
    ]);
    return {
      status: "loggedOut"
    };
  }
  async logIn(signMessageParams) {
    const timestamp = Math.round(Date.now() / 1e3);
    const signature = await this._signMessage({
      signMessageParams,
      timestamp
    });
    const { tenantId, walletBlockchain } = this._configuration;
    let loginResult = void 0;
    switch (walletBlockchain) {
      case "BASE":
      case "ETHEREUM":
      case "POLYGON":
      case "ARBITRUM":
      case "AVALANCHE":
      case "BINANCE":
      case "OPTIMISM":
      case "ZKSYNC":
      case "SOLANA": {
        const result = await this._service.logInFromDapp({
          walletBlockchain,
          walletPublicKey: this._configuration.walletPublicKey,
          dappAddress: tenantId,
          timestamp,
          signature
        });
        loginResult = result.logInFromDapp;
        break;
      }
      case "SUI":
      case "ACALA":
      case "NEAR":
      case "INJECTIVE":
      case "OSMOSIS":
      case "NIBIRU":
      case "APTOS": {
        const result = await this._service.logInFromDapp({
          walletBlockchain,
          walletPublicKey: this._configuration.authenticationKey,
          accountId: this._configuration.accountAddress,
          dappAddress: tenantId,
          timestamp,
          signature
        });
        loginResult = result.logInFromDapp;
        break;
      }
    }
    if (loginResult === void 0) {
      return Promise.reject("Failed to login");
    }
    await this._handleLogInResult(loginResult);
    return loginResult;
  }
  async _signMessage({
    signMessageParams,
    timestamp
  }) {
    if (this._configuration.walletBlockchain !== signMessageParams.walletBlockchain) {
      throw new Error(
        "Sign message params and configuration must have the same blockchain"
      );
    }
    switch (signMessageParams.walletBlockchain) {
      case "ETHEREUM":
      case "POLYGON":
      case "ARBITRUM":
      case "AVALANCHE":
      case "BINANCE":
      case "OPTIMISM": {
        const { walletPublicKey, tenantId } = this._configuration;
        const messageBuffer = new TextEncoder().encode(
          `${SIGNING_MESSAGE}${walletPublicKey}${tenantId}${timestamp.toString()}`
        );
        const signedBuffer = await signMessageParams.signMessage(messageBuffer);
        const signature = normalizeHexString(
          import_buffer.Buffer.from(signedBuffer).toString("hex")
        );
        return signature;
      }
      case "OSMOSIS":
      case "ZKSYNC":
      case "INJECTIVE": {
        const { authenticationKey, tenantId } = this._configuration;
        const messageBuffer = new TextEncoder().encode(
          `${SIGNING_MESSAGE}${authenticationKey}${tenantId}${timestamp.toString()}`
        );
        const signedBuffer = await signMessageParams.signMessage(messageBuffer);
        const signature = import_buffer.Buffer.from(signedBuffer).toString("base64");
        return signature;
      }
      case "SOLANA": {
        const { walletPublicKey, tenantId } = this._configuration;
        const messageBuffer = new TextEncoder().encode(
          `${SIGNING_MESSAGE}${walletPublicKey}${tenantId}${timestamp.toString()}`
        );
        const signedBuffer = await signMessageParams.signMessage(messageBuffer);
        const signature = import_buffer.Buffer.from(signedBuffer).toString("base64");
        return signature;
      }
      case "ACALA": {
        const { accountAddress, tenantId } = this._configuration;
        const message = `${SIGNING_MESSAGE}${accountAddress}${tenantId}${timestamp.toString()}`;
        const signedBuffer = await signMessageParams.signMessage(
          accountAddress,
          message
        );
        return signedBuffer;
      }
      case "APTOS": {
        const signature = await signMessageParams.signMessage(
          SIGNING_MESSAGE,
          timestamp
        );
        return signature;
      }
      case "SUI": {
        const { accountAddress, tenantId } = this._configuration;
        const messageBuffer = new TextEncoder().encode(
          `${SIGNING_MESSAGE}${accountAddress}${tenantId}${timestamp.toString()}`
        );
        const signedBuffer = await signMessageParams.signMessage(messageBuffer);
        const signature = signedBuffer.toString();
        return signature;
      }
      case "NEAR": {
        const { authenticationKey, accountAddress, tenantId } = this._configuration;
        const message = `${`ed25519:` + authenticationKey}${tenantId}${accountAddress}${timestamp.toString()}`;
        const textAsBuffer = new TextEncoder().encode(message);
        const hashBuffer = await window.crypto.subtle.digest(
          "SHA-256",
          textAsBuffer
        );
        const messageBuffer = new Uint8Array(hashBuffer);
        const signedBuffer = await signMessageParams.signMessage(messageBuffer);
        const signature = import_buffer.Buffer.from(signedBuffer).toString("base64");
        return signature;
      }
      default:
        return "Chain not yet supported";
    }
  }
  async _handleLogInResult(user) {
    const authorization = user == null ? void 0 : user.authorization;
    const saveAuthorizationPromise = authorization !== void 0 ? this._storage.setAuthorization(authorization) : Promise.resolve();
    const roles = user == null ? void 0 : user.roles;
    const saveRolesPromise = roles !== void 0 ? this._storage.setRoles(roles.filter(notNullOrEmpty)) : Promise.resolve();
    if (authorization && roles) {
      const userState = {
        status: "authenticated",
        authorization,
        roles: roles.filter((role) => !!role)
      };
      this._userState = userState;
    }
    await Promise.all([saveAuthorizationPromise, saveRolesPromise]);
  }
  async fetchData() {
    return this._service.fetchData({});
  }
  async beginLoginViaTransaction({
    walletBlockchain,
    walletAddress
  }) {
    const { tenantId } = this._configuration;
    const result = await this._service.beginLogInByTransaction({
      walletAddress,
      walletBlockchain,
      dappAddress: tenantId
    });
    const nonce = result.beginLogInByTransaction.nonce;
    if (nonce === null) {
      throw new Error("Failed to begin login process");
    }
    const ruuid = crypto.randomUUID();
    this._clientRandomUuid = ruuid;
    const encoder = new TextEncoder();
    const data = encoder.encode(nonce + ruuid);
    const hashBuffer = await crypto.subtle.digest("SHA-256", data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const logValue = "Notifi Auth: 0x" + hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
    return { nonce: logValue };
  }
  async completeLoginViaTransaction({
    walletBlockchain,
    walletAddress,
    transactionSignature
  }) {
    const { tenantId } = this._configuration;
    const clientRandomUuid = this._clientRandomUuid;
    this._clientRandomUuid = null;
    if (clientRandomUuid === null) {
      throw new Error(
        "BeginLoginViaTransaction is required to be called first"
      );
    }
    const result = await this._service.completeLogInByTransaction({
      walletAddress,
      walletBlockchain,
      dappAddress: tenantId,
      randomUuid: clientRandomUuid,
      transactionSignature
    });
    await this._handleLogInResult(result.completeLogInByTransaction);
    return result;
  }
  async getTargetGroups() {
    var _a, _b;
    const query = await this._service.getTargetGroups({});
    const results = (_b = (_a = query.targetGroup) == null ? void 0 : _a.filter(notNullOrEmpty)) != null ? _b : [];
    return results;
  }
  async ensureTargetGroup({
    name,
    emailAddress,
    phoneNumber,
    telegramId,
    webhook,
    discordId
  }) {
    var _a;
    const [
      targetGroupsQuery,
      emailTargetId,
      smsTargetId,
      telegramTargetId,
      webhookTargetId,
      discordTargetId
    ] = await Promise.all([
      this._service.getTargetGroups({}),
      ensureEmail(this._service, emailAddress),
      ensureSms(this._service, phoneNumber),
      ensureTelegram(this._service, telegramId),
      ensureWebhook(this._service, webhook),
      ensureDiscord(this._service, discordId)
    ]);
    const emailTargetIds = emailTargetId === void 0 ? [] : [emailTargetId];
    const smsTargetIds = smsTargetId === void 0 ? [] : [smsTargetId];
    const telegramTargetIds = telegramTargetId === void 0 ? [] : [telegramTargetId];
    const webhookTargetIds = webhookTargetId === void 0 ? [] : [webhookTargetId];
    const discordTargetIds = discordTargetId === void 0 ? [] : [discordTargetId];
    const existing = (_a = targetGroupsQuery.targetGroup) == null ? void 0 : _a.find(
      (it) => (it == null ? void 0 : it.name) === name
    );
    if (existing !== void 0) {
      return this._updateTargetGroup({
        existing,
        emailTargetIds,
        smsTargetIds,
        telegramTargetIds,
        webhookTargetIds,
        discordTargetIds
      });
    }
    const createMutation = await this._service.createTargetGroup({
      name,
      emailTargetIds,
      smsTargetIds,
      telegramTargetIds,
      webhookTargetIds,
      discordTargetIds
    });
    if (createMutation.createTargetGroup === void 0) {
      throw new Error("Failed to create target group");
    }
    return createMutation.createTargetGroup;
  }
  async _updateTargetGroup({
    existing,
    emailTargetIds,
    smsTargetIds,
    telegramTargetIds,
    webhookTargetIds,
    discordTargetIds
  }) {
    var _a, _b, _c, _d, _e, _f;
    if (areIdsEqual(emailTargetIds, (_a = existing.emailTargets) != null ? _a : []) && areIdsEqual(smsTargetIds, (_b = existing.smsTargets) != null ? _b : []) && areIdsEqual(telegramTargetIds, (_c = existing.telegramTargets) != null ? _c : []) && areIdsEqual(webhookTargetIds, (_d = existing.webhookTargets) != null ? _d : []) && areIdsEqual(discordTargetIds, (_e = existing.discordTargets) != null ? _e : [])) {
      return existing;
    }
    const updateMutation = await this._service.updateTargetGroup({
      id: existing.id,
      name: (_f = existing.name) != null ? _f : existing.id,
      emailTargetIds,
      smsTargetIds,
      telegramTargetIds,
      webhookTargetIds,
      discordTargetIds
    });
    const updated = updateMutation.updateTargetGroup;
    if (updated === void 0) {
      throw new Error("Failed to update target group");
    }
    return updated;
  }
  async getSourceGroups() {
    var _a, _b;
    const query = await this._service.getSourceGroups({});
    const results = (_b = (_a = query.sourceGroup) == null ? void 0 : _a.filter(notNullOrEmpty)) != null ? _b : [];
    return results;
  }
  async getAlerts() {
    var _a, _b;
    const query = await this._service.getAlerts({});
    return (_b = (_a = query.alert) == null ? void 0 : _a.filter(notNullOrEmpty)) != null ? _b : [];
  }
  async ensureAlert({
    eventType,
    inputs,
    targetGroupName = "Default"
  }) {
    var _a, _b;
    const [alertsQuery, targetGroupsQuery, sourceAndFilters] = await Promise.all([
      this._service.getAlerts({}),
      this._service.getTargetGroups({}),
      ensureSourceAndFilters(this._service, eventType, inputs)
    ]);
    const targetGroup = (_a = targetGroupsQuery.targetGroup) == null ? void 0 : _a.find(
      (it) => (it == null ? void 0 : it.name) === targetGroupName
    );
    if (targetGroup === void 0) {
      throw new Error("Target group does not exist");
    }
    const { sourceGroup, filter, filterOptions } = sourceAndFilters;
    const packedOptions = packFilterOptions(filterOptions);
    const existing = (_b = alertsQuery.alert) == null ? void 0 : _b.find(
      (it) => it !== void 0 && it.name === eventType.name
    );
    if (existing !== void 0) {
      if (existing.sourceGroup.id === sourceGroup.id && existing.targetGroup.id === targetGroup.id && existing.filter.id === filter.id && existing.filterOptions === packedOptions) {
        return existing;
      }
      await this.deleteAlert({
        id: existing.id
      });
    }
    const mutation = await this._service.createAlert({
      name: eventType.name,
      sourceGroupId: sourceGroup.id,
      filterId: filter.id,
      targetGroupId: targetGroup.id,
      filterOptions: packedOptions,
      groupName: "managed"
    });
    const created = mutation.createAlert;
    if (created === void 0) {
      throw new Error("Failed to create alert");
    }
    return created;
  }
  async deleteAlert({
    id
  }) {
    var _a;
    const mutation = await this._service.deleteAlert({ id });
    const result = (_a = mutation.deleteAlert) == null ? void 0 : _a.id;
    if (result === void 0) {
      throw new Error("Failed to delete alert");
    }
  }
  async updateWallets() {
    const walletEventTypeItem = {
      name: "User Wallets",
      type: "walletBalance"
    };
    const result = await ensureSourceAndFilters(
      this._service,
      walletEventTypeItem,
      {}
    );
    return result;
  }
  /**
   *@deprecated
   *@description Use getFusionNotificationHistory instead
   */
  async getNotificationHistory(variables) {
    var _a, _b;
    const query = await this._service.getNotificationHistory(variables);
    const nodes = (_a = query.notificationHistory) == null ? void 0 : _a.nodes;
    const pageInfo = (_b = query.notificationHistory) == null ? void 0 : _b.pageInfo;
    if (nodes === void 0 || pageInfo === void 0) {
      throw new Error("Failed to fetch notification history");
    }
    return { pageInfo, nodes };
  }
  async getUnreadNotificationHistoryCount() {
    const query = await this._service.getUnreadNotificationHistoryCount({});
    const result = query.unreadNotificationHistoryCount;
    if (!result) {
      throw new Error("Failed to fetch unread notification history count");
    }
    return result;
  }
  async getUserSettings() {
    const query = await this._service.getUserSettings({});
    const result = query.userSettings;
    if (!result) {
      throw new Error("Failed to fetch user settings");
    }
    return result;
  }
  async getFusionNotificationHistory(variables) {
    var _a, _b;
    const query = await this._service.getFusionNotificationHistory(variables);
    const nodes = (_a = query.fusionNotificationHistory) == null ? void 0 : _a.nodes;
    const pageInfo = (_b = query.fusionNotificationHistory) == null ? void 0 : _b.pageInfo;
    if (nodes === void 0 || pageInfo === void 0) {
      throw new Error("Failed to fetch notification history");
    }
    return { pageInfo, nodes };
  }
  async fetchSubscriptionCard(variables) {
    const query = await this._service.findTenantConfig({
      input: __spreadProps(__spreadValues2({}, variables), {
        tenant: this._configuration.tenantId
      })
    });
    const result = query.findTenantConfig;
    if (result === void 0) {
      throw new Error("Failed to find tenant config");
    }
    const value = result.dataJson;
    if (value === void 0) {
      throw new Error("Invalid config data");
    }
    const obj = JSON.parse(value);
    let card = void 0;
    switch (obj.version) {
      case "v1": {
        card = obj;
        break;
      }
      case "IntercomV1": {
        card = obj;
      }
    }
    if (card === void 0) {
      throw new Error("Unsupported config format");
    }
    return card;
  }
  async copyAuthorization(config) {
    var _a;
    const auth = await this._storage.getAuthorization();
    const roles = await this._storage.getRoles();
    const driver = ((_a = config.storageOption) == null ? void 0 : _a.driverType) === "InMemory" ? createInMemoryStorageDriver(config) : createLocalForageStorageDriver(config);
    const otherStorage = new NotifiFrontendStorage(driver);
    await Promise.all([
      otherStorage.setAuthorization(auth),
      otherStorage.setRoles(roles)
    ]);
  }
  async sendEmailTargetVerification({
    targetId
  }) {
    var _a;
    const emailTarget = await this._service.sendEmailTargetVerificationRequest({
      targetId
    });
    const id = (_a = emailTarget.sendEmailTargetVerificationRequest) == null ? void 0 : _a.id;
    if (id === void 0) {
      throw new Error(`Unknown error requesting verification`);
    }
    return id;
  }
  async subscribeWallet(params) {
    const { walletBlockchain, signMessage, walletPublicKey } = params.walletParams;
    const signMessageParams = {
      walletBlockchain,
      signMessage
    };
    if (this._userState && this._userState.status === "authenticated") {
      await this.logIn(signMessageParams);
    }
    const timestamp = Math.round(Date.now() / 1e3);
    const signature = await this._signMessage({
      signMessageParams,
      timestamp
    });
    const connectedWallet = await this._service.connectWallet({
      walletBlockchain,
      walletPublicKey,
      accountId: walletBlockchain === "APTOS" || walletBlockchain === "ACALA" || walletBlockchain === "NEAR" || walletBlockchain === "SUI" ? params.walletParams.accountAddress : void 0,
      signature,
      timestamp,
      connectWalletConflictResolutionTechnique: params.connectWalletConflictResolutionTechnique
    });
    return connectedWallet;
  }
  async getConversationMessages(input) {
    const query = await this._service.getConversationMessages(input);
    return query;
  }
  async sendConversationMessages(input) {
    const mutation = await this._service.sendConversationMessages(input);
    return mutation;
  }
  async createSupportConversation(input) {
    const mutation = await this._service.createSupportConversation(input);
    return mutation;
  }
  async createDiscordTarget(input) {
    const mutation = await this._service.createDiscordTarget({
      name: input,
      value: input
    });
    return mutation.createDiscordTarget;
  }
  async markFusionNotificationHistoryAsRead(input) {
    const mutation = await this._service.markFusionNotificationHistoryAsRead(
      input
    );
    return mutation;
  }
  async updateUserSettings(input) {
    const mutation = await this._service.updateUserSettings(input);
    return mutation;
  }
};
var newNotifiStorage = (config) => {
  var _a;
  const driver = ((_a = config.storageOption) == null ? void 0 : _a.driverType) === "InMemory" ? createInMemoryStorageDriver(config) : createLocalForageStorageDriver(config);
  return new NotifiFrontendStorage(driver);
};
var newNotifiService = (config) => {
  const url = envUrl(config.env);
  const client = new GraphQLClient(url);
  return new NotifiService(client);
};
var newFrontendClient = (args) => {
  const config = newFrontendConfig(args);
  const service = newNotifiService(config);
  const storage = newNotifiStorage(config);
  return new NotifiFrontendClient(config, service, storage);
};
var LABEL_TYPE_MENU_LABELS = {
  ChatCompanyName: "Chat Company Name",
  ChatFTUTitle: "Chat FTU Title",
  ChatFTUDescription: "Chat FTU Description",
  ChatFTUSubTitle: "Chat FTU Sub Title",
  ChatBannerTitle: "Chat Banner Title",
  ChatIntroQuestion: "Chat Intro Question"
};

export {
  require_localforage,
  checkIsConfigWithPublicKeyAndAddress,
  newFrontendConfig,
  envUrl,
  notNullOrEmpty,
  packFilterOptions,
  normalizeHexString,
  ensureSourceAndFilters,
  ensureTarget,
  ensureEmail,
  ensureSms,
  ensureTelegram,
  ensureDiscord,
  ensureWebhook,
  createInMemoryStorageDriver,
  NotifiFrontendStorage,
  createLocalForageStorageDriver,
  SIGNING_MESSAGE,
  NotifiFrontendClient,
  newNotifiStorage,
  newNotifiService,
  newFrontendClient,
  LABEL_TYPE_MENU_LABELS
};
/*! Bundled license information:

localforage/dist/localforage.js:
  (*!
      localForage -- Offline Storage, Improved
      Version 1.10.0
      https://localforage.github.io/localForage
      (c) 2013-2017 Mozilla, Apache License 2.0
  *)
*/
//# sourceMappingURL=chunk-32H7G742.js.map
