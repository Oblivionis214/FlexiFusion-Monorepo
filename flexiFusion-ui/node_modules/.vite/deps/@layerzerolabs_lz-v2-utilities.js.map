{
  "version": 3,
  "sources": ["../../@layerzerolabs/lz-v2-utilities/node_modules/base-x/src/index.js", "../../@layerzerolabs/lz-v2-utilities/node_modules/bs58/index.js", "../../@layerzerolabs/lz-v2-utilities/src/utils/hex.ts", "../../@layerzerolabs/lz-v2-utilities/src/utils/precrime.ts", "../../@layerzerolabs/lz-v2-utilities/src/utils/parse-error.ts", "../../@layerzerolabs/lz-v2-utilities/src/options/options.ts", "../../@layerzerolabs/lz-v2-utilities/src/model/packet.ts", "../../@layerzerolabs/lz-v2-utilities/src/codec/packet-v1-codec.ts", "../../@layerzerolabs/lz-v2-utilities/src/codec/packet-serializer.ts", "../../@layerzerolabs/lz-v2-utilities/src/commandCodec/commandCodec.ts"],
  "sourcesContent": ["'use strict'\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) {\n    } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = new Uint8Array(zeroes + (size - it4))\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n", "const basex = require('base-x')\nconst ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n", "import { getAddress } from '@ethersproject/address'\nimport { arrayify, hexZeroPad, hexlify } from '@ethersproject/bytes'\nimport base58 from 'bs58'\n\n/**\n * Pads a hexadecimal address to 32 bytes.\n *\n * @param addr - The address to pad.\n *\n * @returns {string} The padded address.\n */\nexport function hexZeroPadTo32(addr: string): string {\n    return hexZeroPad(addr, 32)\n}\n\n/**\n * Converts a bytes32 value to an Ethereum address.\n *\n * @param bytes32 - The bytes32 value.\n *\n * @returns {string} The Ethereum address.\n */\nexport function bytes32ToEthAddress(bytes32: string | Uint8Array): string {\n    if (bytes32 instanceof Uint8Array) {\n        bytes32 = hexlify(bytes32)\n    }\n    return getAddress(bytes32.slice(-40))\n}\n\n/**\n * Trims the '0x' prefix from a hexadecimal string.\n *\n * @param str - The hexadecimal string.\n *\n * @returns {string} The trimmed string.\n */\nexport function trim0x(str: string): string {\n    return str.replace(/^0x/, '')\n}\n\n/**\n * Converts an address to bytes32.\n *\n * @param address - The address to convert.\n *\n * @returns {Uint8Array} The bytes32 representation of the address.\n *\n * @throws {Error} If the address is invalid.\n */\nexport function addressToBytes32(address: string): Uint8Array {\n    if (isSolanaAddress(address)) {\n        return base58.decode(address)\n    } else if (address.startsWith('0x') && address.length <= 66) {\n        return arrayify(hexZeroPadTo32(address))\n    }\n    throw new Error('Invalid address')\n}\n\nconst solanaAddressRegex = /^([1-9A-HJ-NP-Za-km-z]{32,44})$/\n\n/**\n * Checks if an address is a Solana address.\n *\n * @param address - The address to check.\n *\n * @returns {boolean} True if the address is a Solana address, false otherwise.\n */\nexport function isSolanaAddress(address: string): boolean {\n    return solanaAddressRegex.test(address)\n}\n\nconst aptosAddressRegex = /^(0x)?[0-9a-fA-F]{1,64}$/\n\n/**\n * Checks if an address is an Aptos address.\n *\n * @param address - The address to check.\n *\n * @returns {boolean} True if the address is an Aptos address, false otherwise. Could be short address.\n */\nexport function isAptosAddress(address: string): boolean {\n    return aptosAddressRegex.test(address)\n}\n\nconst initiaAddressRegex = /^0x[a-fA-F0-9]{1,64}$/\n\n/**\n * Checks if an address is an Initia address. Could be short address.\n *\n * @param address - The address to check.\n *\n * @returns {boolean} True if the address is an Initia address, false otherwise.\n */\nexport function isInitiaAddress(address: string): boolean {\n    return initiaAddressRegex.test(address)\n}\n\n/**\n * Check if the address is a valid TON address\n *\n * A valid TON address should be a 64-character hexadecimal string\n *\n * Reference implementation:\n * https://github.com/ton-org/ton-core/blob/9c1b8f7e38c5aaef518cffb058c78a6768026e6d/src/address/Address.ts#L94\n *\n * @param address The address string to check\n * @returns true if it's a valid TON address, false otherwise\n */\nexport function isTonAddress(address: string): boolean {\n    const hash = trim0x(address).toLowerCase()\n    return /[a-f0-9]+/.test(hash) && hash.length === 64\n}\n", "import { PreCrimePeer, PrecrimeConfig, PrecrimeConfigV1, PrecrimeConfigV2 } from '../model'\n\nimport { trim0x } from './hex'\n\nconst CONFIG_VERSION_OFFSET = 0\nconst MAX_BATCH_SIZE_OFFSET = 2\nconst NUMBER_OF_PEERS_OFFSET = 10\nconst PEERS_OFFSET = 12\n\n/**\n * Parses the precrime configuration string.\n *\n * @param precrimeConfig - The precrime configuration string.\n *\n * @returns {PrecrimeConfig} The parsed precrime configuration.\n *\n * @throws {Error} If the precrime config version is unsupported.\n */\nexport function parsePrecrimeConfig(precrimeConfig: string): PrecrimeConfig {\n    const data = trim0x(precrimeConfig)\n    const version = parseInt(data.slice(0, 4), 16)\n    if (version === 1) {\n        return parsePrecrimeConfigV1(precrimeConfig)\n    } else if (version === 2) {\n        return parsePrecrimeConfigV2(precrimeConfig)\n    }\n    throw new Error(`Unsupported precrime config version: ${version}`)\n}\n\n/**\n * Parses the precrime configuration string for version 1.\n *\n * @param precrimeConfig - The precrime configuration string.\n *\n * @returns {PrecrimeConfigV1} The parsed precrime configuration for version 1.\n */\nfunction parsePrecrimeConfigV1(precrimeConfig: string): PrecrimeConfigV1 {\n    const data = trim0x(precrimeConfig)\n    const version = parseInt(data.slice(0, 4), 16)\n    const maxBatchSize = parseInt(data.slice(4, 20), 16)\n    const remoteChainsLength = parseInt(data.slice(20, 84), 16)\n    const remoteChainsBytes = data.slice(84, 84 + remoteChainsLength * 64)\n    const remoteAddressesBytes = data.slice(\n        84 + remoteChainsLength * 64,\n        84 + remoteChainsLength * 64 + remoteChainsLength * 64\n    )\n\n    const remoteChainsBytesArray: number[] = []\n    const remoteAddressesBytesArray: string[] = []\n    let start = 0\n    let end = 64\n    for (let i = 0; i < remoteChainsLength; i++) {\n        remoteChainsBytesArray.push(parseInt(remoteChainsBytes.slice(start, end), 16))\n        remoteAddressesBytesArray.push(`0x${remoteAddressesBytes.slice(start, end)}`)\n        start += 64\n        end += 64\n    }\n    return { version, maxBatchSize, remoteEids: remoteChainsBytesArray, remoteAddresses: remoteAddressesBytesArray }\n}\n\n/**\n * Parses the precrime configuration string for version 2.\n *\n * @param precrimeConfig - The precrime configuration string.\n *\n * @returns {PrecrimeConfigV2} The parsed precrime configuration for version 2.\n */\nfunction parsePrecrimeConfigV2(precrimeConfig: string): PrecrimeConfigV2 {\n    const buffer = Buffer.from(trim0x(precrimeConfig), 'hex')\n    const version = buffer.readUInt16BE(CONFIG_VERSION_OFFSET)\n    const maxBatchSize = buffer.readBigUint64BE(MAX_BATCH_SIZE_OFFSET)\n    const peers = new Array<PreCrimePeer>()\n    if (buffer.length > NUMBER_OF_PEERS_OFFSET) {\n        const numOfPeers = buffer.readUInt16BE(NUMBER_OF_PEERS_OFFSET)\n        for (let i = 0; i < numOfPeers; i++) {\n            const offset = PEERS_OFFSET + i * (4 + 2 * 32)\n            const eid = buffer.readUInt32BE(offset)\n            const preCrimeAddress = '0x' + buffer.slice(offset + 4, offset + 4 + 32).toString('hex')\n            const oappAddress = '0x' + buffer.slice(offset + 4 + 32, offset + 4 + 32 + 32).toString('hex')\n            peers.push({\n                eid,\n                preCrimeAddress,\n                oappAddress,\n            })\n        }\n    }\n    return {\n        version,\n        maxBatchSize,\n        peers,\n    }\n}\n", "import { type Interface, defaultAbiCoder } from '@ethersproject/abi'\n\n/**\n * Parses the error data.\n *\n * @param errorData - The error data string.\n * @param intf - The optional interface to parse the error.\n *\n * @returns {ReturnType<Interface['parseError']> | string | number | undefined} The parsed error.\n */\nexport const parseError = (\n    errorData: string,\n    intf?: Interface\n): ReturnType<Interface['parseError']> | string | number | undefined => {\n    const buildInError = parseBuildInError(errorData)\n    if (buildInError !== undefined) {\n        return buildInError\n    }\n\n    if (intf) {\n        try {\n            return intf.parseError(errorData)\n        } catch (e) {\n            console.error(e)\n        }\n    }\n    return undefined\n}\n\n/**\n * Parses built-in errors.\n *\n * @param errorData - The error data string.\n *\n * @returns {string | number | undefined} The parsed built-in error.\n */\nfunction parseBuildInError(errorData: string): string | number | undefined {\n    if (errorData.startsWith('0x08c379a0')) {\n        // decode Error(string)\n\n        const content = `0x${errorData.substring(10)}`\n        const reason = defaultAbiCoder.decode(['string'], content)\n\n        return reason[0] as string // reason: string; for standard revert error string\n    }\n\n    if (errorData.startsWith('0x4e487b71')) {\n        // decode Panic(uint)\n        const content = `0x${errorData.substring(10)}`\n        const code = defaultAbiCoder.decode(['uint'], content)\n\n        return code[0] as number\n    }\n\n    if (errorData === '0x') {\n        return ''\n    }\n\n    return undefined\n}\n", "/* eslint-disable @typescript-eslint/consistent-return, @typescript-eslint/no-unsafe-enum-comparison */\n\nimport { BigNumber } from '@ethersproject/bignumber'\nimport { arrayify, hexlify } from '@ethersproject/bytes'\nimport { pack as solidityPack } from '@ethersproject/solidity'\nimport invariant from 'tiny-invariant'\n\nimport { addressToBytes32, trim0x } from '../utils'\n\n// gasLimit input type\nexport type GasLimit = string | number | bigint\n\n// native drop input type\nexport type NativeDrop = string | number | bigint\n\nexport type DataSize = string | number | bigint\n\n/**\n * Enumerates the supported option types.\n */\nexport enum OptionType {\n    /**\n     * Allows the specification of the gas allowance for the remote executor transaction, measured in destination gas\n     * units.\n     *\n     * Format:\n     * bytes  [2     32      ]\n     * fields [type  extraGas]\n     */\n    TYPE_1 = 1,\n\n    /**\n     * Combines the functionality of TYPE_1 along with destination gas drop to a remote address.\n     *\n     * Format:\n     * bytes  [2     32        32            bytes[]         ]\n     * fields [type  extraGas  dstNativeAmt  dstNativeAddress]\n     */\n    TYPE_2 = 2,\n\n    /**\n     * EndpointV2 specific options.\n     */\n    TYPE_3 = 3,\n}\n\nconst MAX_UINT_128 = BigNumber.from('0xffffffffffffffffffffffffffffffff')\n\n/**\n * Builds OptionsType.TYPE_1.\n *\n * @param {GasLimit} _extraGas The gas allowance for the remote executor transaction, measured in destination gas units.\n */\nexport function optionsType1(_extraGas: GasLimit): string {\n    const extraGas = BigNumber.from(_extraGas)\n    invariant(extraGas.lte(MAX_UINT_128), 'extraGas should be less than MAX_UINT_128')\n    return solidityPack(['uint16', 'uint256'], [OptionType.TYPE_1, extraGas])\n}\n\n/**\n * Builds OptionsType.TYPE_2.\n *\n * @param {GasLimit} _extraGas The gas allowance for the remote executor transaction, measured in destination gas units.\n * @param {NativeDrop} _dstNativeAmt The amount of native token to be sent to the destination chain.\n * @param {string} _dstNativeAddress The destination address of _dstNativeAmt.\n */\nexport function optionsType2(_extraGas: GasLimit, _dstNativeAmt: NativeDrop, _dstNativeAddress: string): string {\n    const extraGas = BigNumber.from(_extraGas)\n    invariant(extraGas.lte(MAX_UINT_128), 'extraGas should be less than MAX_UINT_128')\n    const dstNativeAmt = BigNumber.from(_dstNativeAmt)\n    invariant(dstNativeAmt.lte(MAX_UINT_128), 'dstNativeAmt should be less than MAX_UINT_128')\n    return solidityPack(\n        ['uint16', 'uint256', 'uint256', 'bytes'],\n        [OptionType.TYPE_2, BigNumber.from(extraGas), BigNumber.from(dstNativeAmt), _dstNativeAddress]\n    )\n}\n\n/**\n * Enumerates the supported worker IDs.\n */\nexport enum WorkerId {\n    /**\n     * Executor worker ID.\n     */\n    EXECUTOR = 1,\n\n    /**\n     * Verifier worker ID.\n     */\n    VERIFIER = 2,\n\n    /**\n     * Treasury worker ID.\n     */\n    TREASURY = 255,\n}\n\n/**\n * Interface representing worker options.\n */\nexport interface WorkerOptions {\n    /**\n     * The worker ID.\n     */\n    workerId: number // uint8\n\n    /**\n     * The options.\n     */\n    options: Option[] // toBytes: num(uint8),[type(uint8),size(uint16),data],[type(uint8),size(uint16),data],[type(uint8),size(uint16),data]...\n}\n\n/**\n * Interface representing an option.\n */\nexport interface Option {\n    /**\n     * The option type.\n     */\n    type: number // uint8\n\n    /**\n     * The option parameters.\n     */\n    params: string // bytes\n}\n\n/**\n * Interface representing a verifier option.\n */\nexport type VerifierOption = Option & {\n    /**\n     * The verifier index.\n     */\n    index: number // uint8\n}\n\n/**\n * Enumerates the supported executor option types.\n */\nexport enum ExecutorOptionType {\n    /**\n     * LZ_RECEIVE option type.\n     */\n    LZ_RECEIVE = 1,\n\n    /**\n     * NATIVE_DROP option type.\n     */\n    NATIVE_DROP = 2,\n\n    /**\n     * COMPOSE option type.\n     */\n    COMPOSE = 3,\n\n    /**\n     * ORDERED option type.\n     */\n    ORDERED = 4,\n\n    /**\n     * LZ_READ option type.\n     */\n    LZ_READ = 5,\n}\n\n/**\n * Enumerates the supported verifier option types.\n */\nexport enum VerifierOptionType {\n    /**\n     * PRECRIME option type.\n     */\n    PRECRIME = 1,\n}\n\n/**\n * ExecutorLzReceiveOption type.\n */\nexport interface ExecutorLzReceiveOption {\n    /**\n     * The gas limit.\n     */\n    gas: bigint\n\n    /**\n     * The value.\n     */\n    value: bigint\n}\n\n/**\n * ExecutorLzReadOption type.\n */\nexport interface ExecutorLzReadOption {\n    /**\n     * The gas limit.\n     */\n    gas: bigint\n\n    /**\n     * The data size.\n     */\n    dataSize: bigint\n\n    /**\n     * The value.\n     */\n    value: bigint\n}\n\n/**\n * ExecutorNativeDropOption type.\n */\nexport type ExecutorNativeDropOption = { amount: bigint; receiver: string }[]\n\n/**\n * ComposeOption type.\n */\nexport type ComposeOption = { index: number; gas: bigint; value: bigint }[]\n\n/**\n * Options builder, available only for EndpointV2.\n */\nexport class Options {\n    protected workerOptions: WorkerOptions[] = []\n\n    // dissuade public instantiation\n    protected constructor() {}\n\n    /**\n     * Create a new options instance.\n     */\n    public static newOptions(): Options {\n        return new Options()\n    }\n\n    /**\n     * Create an options instance from a hex string.\n     * @param {string} optionsHex The hex string to decode.\n     */\n    public static fromOptions(optionsHex: string): Options {\n        const options = new Options()\n        const optionsBytes = arrayify(optionsHex)\n        // 0-2 bytes is options type\n        const optionsType = BigNumber.from(optionsBytes.slice(0, 2)).toNumber()\n        if (optionsType === OptionType.TYPE_3) {\n            let cursor = 2\n            while (cursor < optionsBytes.byteLength) {\n                const workerId = BigNumber.from(optionsBytes.slice(cursor, cursor + 1)).toNumber()\n                cursor += 1\n\n                const size = BigNumber.from(optionsBytes.slice(cursor, cursor + 2)).toNumber()\n                cursor += 2\n\n                if (workerId === WorkerId.EXECUTOR) {\n                    const optionType = BigNumber.from(optionsBytes.slice(cursor, cursor + 1)).toNumber()\n                    cursor += 1\n                    const params = optionsBytes.slice(cursor, cursor + size - 1)\n                    cursor += size - 1\n                    options.addOption(workerId, { type: optionType, params: hexlify(params) })\n                } else if (workerId === WorkerId.VERIFIER) {\n                    const verifierIdx = BigNumber.from(optionsBytes.slice(cursor, cursor + 1)).toNumber()\n                    cursor += 1\n                    const optionType = BigNumber.from(optionsBytes.slice(cursor, cursor + 1)).toNumber()\n                    cursor += 1\n                    const params = optionsBytes.slice(cursor, cursor + size - 2)\n                    cursor += size - 2\n                    const option: VerifierOption = {\n                        type: optionType,\n                        index: verifierIdx,\n                        params: hexlify(params),\n                    }\n                    options.addOption(workerId, option)\n                }\n                // TODO - other workerId\n            }\n        } else if (optionsType === OptionType.TYPE_2) {\n            const extraGas = BigNumber.from(optionsBytes.slice(2, 34)).toBigInt()\n            const dstNativeAmt = BigNumber.from(optionsBytes.slice(34, 66)).toBigInt()\n            const dstNativeAddress = hexlify(optionsBytes.slice(66, optionsBytes.byteLength))\n            options.addExecutorLzReceiveOption(extraGas).addExecutorNativeDropOption(dstNativeAmt, dstNativeAddress)\n        } else if (optionsType === OptionType.TYPE_1) {\n            const extraGas = BigNumber.from(optionsBytes.slice(2, 34)).toBigInt()\n            options.addExecutorLzReceiveOption(extraGas)\n        }\n\n        return options\n    }\n\n    /**\n     * Add ExecutorOptionType.LZ_RECEIVE option.\n     * @param {GasLimit} gasLimit\n     * @param {NativeDrop} nativeDrop\n     */\n    public addExecutorLzReceiveOption(gasLimit: GasLimit, nativeDrop: NativeDrop = 0): this {\n        const gasLimitBN = BigNumber.from(gasLimit)\n        invariant(gasLimitBN.lte(MAX_UINT_128), \"gasLimit shouldn't be greater than MAX_UINT_128\")\n        const nativeDropBN = BigNumber.from(nativeDrop)\n        invariant(nativeDropBN.lte(MAX_UINT_128), \"value shouldn't be greater than MAX_UINT_128\")\n        this.addOption(WorkerId.EXECUTOR, {\n            type: ExecutorOptionType.LZ_RECEIVE,\n            params: nativeDropBN.eq(0)\n                ? solidityPack(['uint128'], [gasLimitBN])\n                : solidityPack(['uint128', 'uint128'], [gasLimitBN, nativeDropBN]),\n        })\n        return this\n    }\n\n    /**\n     * Add ExecutorOptionType.NATIVE_DROP option.\n     * @param {NativeDrop} nativeDrop\n     * @param {string} receiver\n     */\n    public addExecutorNativeDropOption(nativeDrop: NativeDrop, receiver: string): this {\n        const amountBN = BigNumber.from(nativeDrop)\n        invariant(amountBN.lte(MAX_UINT_128), \"nativeDrop shouldn't be greater than MAX_UINT_128\")\n        this.addOption(WorkerId.EXECUTOR, {\n            type: ExecutorOptionType.NATIVE_DROP,\n            params: solidityPack(['uint128', 'bytes32'], [amountBN, addressToBytes32(receiver)]),\n        })\n        return this\n    }\n\n    /**\n     * Add ExecutorOptionType.COMPOSE option.\n     * @param {number} index\n     * @param {GasLimit} gasLimit\n     * @param {NativeDrop} nativeDrop\n     */\n    public addExecutorComposeOption(index: number, gasLimit: GasLimit, nativeDrop: NativeDrop = 0): this {\n        const gasLimitBN = BigNumber.from(gasLimit)\n        invariant(gasLimitBN.lte(MAX_UINT_128), \"gasLimit shouldn't be greater than MAX_UINT_128\")\n        const nativeDropBN = BigNumber.from(nativeDrop)\n        invariant(nativeDropBN.lte(MAX_UINT_128), \"nativeDrop shouldn't be greater than MAX_UINT_128\")\n        const option = nativeDropBN.gt(0)\n            ? {\n                  type: ExecutorOptionType.COMPOSE,\n                  params: solidityPack(['uint16', 'uint128', 'uint128'], [index, gasLimitBN, nativeDropBN]),\n              }\n            : {\n                  type: ExecutorOptionType.COMPOSE,\n                  params: solidityPack(['uint16', 'uint128'], [index, gasLimitBN]),\n              }\n\n        this.addOption(WorkerId.EXECUTOR, option)\n        return this\n    }\n\n    /**\n     * Add ExecutorOptionType.ORDERED option.\n     *\n     * @returns {this} The options instance.\n     */\n    public addExecutorOrderedExecutionOption(): this {\n        this.addOption(WorkerId.EXECUTOR, {\n            type: ExecutorOptionType.ORDERED,\n            params: '0x',\n        })\n        return this\n    }\n\n    /**\n     * Add ExecutorOptionType.LZ_READ option.\n     *\n     * @param {GasLimit} gasLimit - The gas limit.\n     * @param {DataSize} dataSize - The data size.\n     * @param {NativeDrop} [nativeDrop=0] - The native drop.\n     * @returns {this} The options instance.\n     */\n    public addExecutorLzReadOption(gasLimit: GasLimit, dataSize: DataSize, nativeDrop: NativeDrop = 0): this {\n        const gasLimitBN = BigNumber.from(gasLimit)\n        const dataSizeBN = BigNumber.from(dataSize)\n        const nativeDropBN = BigNumber.from(nativeDrop)\n        this.addOption(WorkerId.EXECUTOR, {\n            type: ExecutorOptionType.LZ_READ,\n            params: nativeDropBN.eq(0)\n                ? solidityPack(['uint128', 'uint32'], [gasLimitBN, dataSizeBN])\n                : solidityPack(['uint128', 'uint32', 'uint128'], [gasLimitBN, dataSizeBN, nativeDropBN]),\n        })\n        return this\n    }\n\n    /**\n     * Add VerifierOptionType.PRECRIME option.\n     *\n     * @param {number} verifierIdx - The verifier index.\n     * @returns {this} The options instance.\n     */\n    public addVerifierPrecrimeOption(verifierIdx: number): this {\n        const option: VerifierOption = {\n            type: VerifierOptionType.PRECRIME,\n            index: verifierIdx,\n            params: '0x',\n        }\n        this.addOption(WorkerId.VERIFIER, option)\n        return this\n    }\n\n    /**\n     * Serialize Options to hex string.\n     *\n     * @returns {string} The serialized hex string.\n     */\n    public toHex(): string {\n        // output encoded hex, type(uint16)\n        let hex = solidityPack(['uint16'], [OptionType.TYPE_3])\n        this.workerOptions.forEach((w) => {\n            for (const option of w.options) {\n                if (w.workerId === WorkerId.EXECUTOR) {\n                    hex += trim0x(\n                        solidityPack(\n                            ['uint8', 'uint16', 'uint8', 'bytes'],\n                            [w.workerId, trim0x(option.params).length / 2 + 1, option.type, option.params]\n                        )\n                    )\n                } else if (w.workerId === WorkerId.VERIFIER) {\n                    const verifierOption = option as VerifierOption\n                    hex += trim0x(\n                        solidityPack(\n                            ['uint8', 'uint16', 'uint8', 'uint8', 'bytes'],\n                            [\n                                w.workerId,\n                                trim0x(option.params).length / 2 + 2,\n                                verifierOption.index,\n                                verifierOption.type,\n                                verifierOption.params,\n                            ]\n                        )\n                    )\n                }\n                // TODO other workerId\n            }\n        })\n        return hex\n    }\n\n    /**\n     * Serialize Options to Uint8Array.\n     *\n     * @returns {Uint8Array} The serialized Uint8Array.\n     */\n    public toBytes(): Uint8Array {\n        return arrayify(this.toHex())\n    }\n\n    /**\n     * Adds an option to the specified worker.\n     *\n     * @param {number} workerId - The ID of the worker.\n     * @param {Option} option - The option to add.\n     */\n    private addOption(workerId: number, option: Option): void {\n        const worker = this.workerOptions.find((w) => w.workerId === workerId)\n        if (worker) {\n            worker.options.push(option)\n        } else {\n            this.workerOptions.push({ workerId, options: [option] })\n        }\n    }\n\n    /**\n     * Decode ExecutorOptionType.LZ_RECEIVE option. Returns undefined if the option is not present.\n     *\n     * @returns {ExecutorLzReceiveOption | undefined} The decoded option or undefined if not present.\n     */\n    public decodeExecutorLzReceiveOption(): ExecutorLzReceiveOption | undefined {\n        let options = this.findOptions(WorkerId.EXECUTOR, ExecutorOptionType.LZ_RECEIVE)\n        if (options === undefined || (Array.isArray(options) && options.length === 0)) {\n            return\n        }\n        let totalGas = BigNumber.from(0).toBigInt()\n        let totalValue = BigNumber.from(0).toBigInt()\n        options = Array.isArray(options) ? options : [options]\n        for (const option of options) {\n            const buffer = Buffer.from(trim0x(option.params), 'hex')\n            const gas = BigNumber.from(buffer.subarray(0, 16)).toBigInt()\n            const value = BigNumber.from(buffer.length === 16 ? 0 : buffer.subarray(16, 32)).toBigInt()\n            totalGas = totalGas + gas\n            totalValue = totalValue + value\n        }\n\n        return { gas: totalGas, value: totalValue }\n    }\n\n    /**\n     * Decode ExecutorOptionType.NATIVE_DROP options. Returns undefined if the options is not present.\n     *\n     * @returns {ExecutorNativeDropOption} The decoded options.\n     */\n    public decodeExecutorNativeDropOption(): ExecutorNativeDropOption {\n        const options = this.findOptions(WorkerId.EXECUTOR, ExecutorOptionType.NATIVE_DROP) as Option[] | undefined\n        if (!options || options.length === 0) {\n            return []\n        }\n\n        const results = options.reduce((acc: { [key: string]: { amount: bigint; receiver: string } }, cur: Option) => {\n            const buffer = Buffer.from(trim0x(cur.params), 'hex')\n            const amount = BigNumber.from(buffer.subarray(0, 16)).toBigInt()\n            const receiver = hexlify(buffer.subarray(16, 48))\n            if (receiver in acc) {\n                acc[receiver].amount = acc[receiver].amount + amount\n            } else {\n                acc[receiver] = { amount, receiver }\n            }\n            return acc\n        }, {})\n        return Object.values(results)\n    }\n\n    /**\n     * Decode ExecutorOptionType.COMPOSE options. Returns undefined if the options is not present.\n     *\n     * @returns {ComposeOption} The decoded options.\n     */\n    public decodeExecutorComposeOption(): ComposeOption {\n        const options = this.findOptions(WorkerId.EXECUTOR, ExecutorOptionType.COMPOSE) as Option[] | undefined\n        if (!options || options.length === 0) {\n            return []\n        }\n        const results = options.reduce(\n            (acc: { [key: number]: { index: number; gas: bigint; value: bigint } }, cur: Option) => {\n                const buffer = Buffer.from(trim0x(cur.params), 'hex')\n                const index = BigNumber.from(buffer.subarray(0, 2)).toNumber()\n                const gas = BigNumber.from(buffer.subarray(2, 18)).toBigInt()\n                const value = (\n                    buffer.length === 34 ? BigNumber.from(buffer.subarray(18, 34)) : BigNumber.from(0)\n                ).toBigInt()\n                if (index in acc) {\n                    acc[index].gas = acc[index].gas + gas\n                    acc[index].value = acc[index].value + value\n                } else {\n                    acc[index] = { index, gas, value }\n                }\n                return acc\n            },\n            {}\n        )\n        return Object.values(results)\n    }\n\n    /**\n     * Decode ExecutorOptionType.ORDERED options. Returns undefined if the options is not present.\n     *\n     * @returns {boolean} True if the option is present, false otherwise.\n     */\n    public decodeExecutorOrderedExecutionOption(): boolean {\n        const option = this.findOptions(WorkerId.EXECUTOR, ExecutorOptionType.ORDERED)\n        return option !== undefined\n    }\n\n    /**\n     * Decodes ExecutorOptionType.LZ_READ options. Returns undefined if the option is not present.\n     *\n     * @returns {ExecutorLzReadOption | undefined} The decoded ExecutorLzReadOption or undefined if not present.\n     */\n    public decodeExecutorLzReadOption(): ExecutorLzReadOption | undefined {\n        let options = this.findOptions(WorkerId.EXECUTOR, ExecutorOptionType.LZ_READ)\n        if (options === undefined || (Array.isArray(options) && options.length === 0)) {\n            return undefined\n        }\n        let totalGas = BigNumber.from(0).toBigInt()\n        let dataSize = BigNumber.from(0).toBigInt()\n        let totalValue = BigNumber.from(0).toBigInt()\n        options = Array.isArray(options) ? options : [options]\n        for (const option of options) {\n            const buffer = Buffer.from(trim0x(option.params), 'hex')\n            const gas = BigNumber.from(buffer.subarray(0, 16)).toBigInt() // uint128\n            const size = BigNumber.from(buffer.subarray(16, 20)).toBigInt() // uint32\n            const value = BigNumber.from(buffer.length === 20 ? 0 : buffer.subarray(20, 36)).toBigInt() // uint128\n            totalGas = totalGas + gas\n            dataSize = dataSize + size\n            totalValue = totalValue + value\n        }\n\n        return { gas: totalGas, dataSize, value: totalValue }\n    }\n\n    /**\n     * Finds options for a given worker and option type.\n     *\n     * @param {number} workerId - The ID of the worker.\n     * @param {number} optionType - The type of the option.\n     * @returns {Option[] | Option | undefined} The found options or undefined if not present.\n     */\n    private findOptions(workerId: number, optionType: number): Option[] | Option | undefined {\n        const worker = this.workerOptions.find((w) => w.workerId === workerId)\n        if (worker) {\n            if (optionType === ExecutorOptionType.ORDERED) {\n                return worker.options.find((o) => o.type === optionType)\n            }\n            return worker.options.filter((o) => o.type === optionType)\n        }\n    }\n\n    /**\n     * Finds a VerifierOption by verifier index and option type. Returns undefined if the option is not present.\n     *\n     * @param {number} verifierIdx - The index of the verifier.\n     * @param {number} optionType - The type of the option.\n     * @returns {VerifierOption | undefined} The found VerifierOption or undefined if not present.\n     */\n    public findVerifierOption(verifierIdx: number, optionType: number): VerifierOption | undefined {\n        const worker = this.workerOptions.find((w) => w.workerId === WorkerId.VERIFIER)\n        if (worker) {\n            const opt = worker.options.find((o) => o.type === optionType && (o as VerifierOption).index === verifierIdx)\n            if (opt) {\n                return opt as VerifierOption\n            }\n        }\n    }\n}\n", "/**\n * Path information for a packet.\n */\nexport interface PacketPath {\n    /**\n     * Source EID.\n     */\n    srcEid: number\n    /**\n     * Sender address.\n     */\n    sender: string\n    /**\n     * Destination EID.\n     */\n    dstEid: number\n    /**\n     * Receiver address.\n     */\n    receiver: string\n}\n\n/**\n * Header information for a packet.\n *\n * @extends PacketPath\n */\nexport type PacketHeader = {\n    /**\n     * Version number.\n     */\n    version: number\n    /**\n     * Nonce value.\n     */\n    nonce: string\n} & PacketPath\n\n/**\n * Packet structure.\n *\n * @extends PacketHeader\n */\nexport type Packet = PacketHeader & {\n    /**\n     * GUID of the packet.\n     */\n    guid: string\n    /**\n     * Message content.\n     */\n    message: string\n    /**\n     * Derived payload.\n     *\n     * payload = guid + message\n     */\n    payload: string // payload = guid + message\n}\n\n/**\n * Origin information for a message.\n */\nexport interface MessageOrigin {\n    /**\n     * Source EID.\n     */\n    srcEid: number\n    /**\n     * Sender address.\n     */\n    sender: string\n    /**\n     * Nonce value.\n     */\n    nonce: string\n}\n\n/**\n * Converts a packet to a message origin.\n *\n * @param {Packet} packet - The packet to convert.\n *\n * @returns {MessageOrigin} The message origin.\n */\nexport function packetToMessageOrigin(packet: Packet): MessageOrigin {\n    return {\n        srcEid: packet.srcEid,\n        sender: packet.sender,\n        nonce: packet.nonce,\n    }\n}\n", "import { BigNumber } from '@ethersproject/bignumber'\nimport { keccak256 } from '@ethersproject/keccak256'\nimport { pack as solidityPack } from '@ethersproject/solidity'\n\nimport { Packet, PacketHeader } from '../model'\nimport { addressToBytes32, bytes32ToEthAddress, trim0x } from '../utils'\n\n// header (version + path + guid)\n// version\nconst PACKET_VERSION_OFFSET = 0\n//    nonce\nconst NONCE_OFFSET = 1\n//    path\nconst SRC_CHAIN_OFFSET = 9\nconst SRC_ADDRESS_OFFSET = 13\nconst DST_CHAIN_OFFSET = 45\nconst DST_ADDRESS_OFFSET = 49\n// payload (guid + message)\nconst GUID_OFFSET = 81 // keccak256(nonce + path)\nconst MESSAGE_OFFSET = 113\n\n/**\n * Class representing the PacketV1Codec.\n */\nexport class PacketV1Codec {\n    /**\n     * Buffer to hold the encoded packet data.\n     */\n    buffer: Buffer\n\n    /**\n     * Create a PacketV1Codec instance from an encoded payload string.\n     *\n     * @param payloadEncoded - The encoded payload string.\n     * @returns A new PacketV1Codec instance.\n     */\n    static from(payloadEncoded: string): PacketV1Codec {\n        return new PacketV1Codec(payloadEncoded)\n    }\n\n    /**\n     * Create a PacketV1Codec instance from a byte array.\n     *\n     * @param payload - The byte array representing the payload.\n     * @returns A new PacketV1Codec instance.\n     */\n    static fromBytes(payload: Uint8Array): PacketV1Codec {\n        return new PacketV1Codec('0x' + Buffer.from(payload).toString('hex'))\n    }\n\n    /**\n     * Constructor for the PacketV1Codec class.\n     *\n     * @param payloadEncoded - The encoded payload string.\n     */\n    protected constructor(payloadEncoded: string) {\n        this.buffer = Buffer.from(trim0x(payloadEncoded), 'hex')\n    }\n\n    /**\n     * Encode a packet to a hex string.\n     *\n     * @param packet - The packet to encode.\n     * @returns The encoded packet as a hex string.\n     */\n    static encode(packet: Packet): string {\n        const buff = this.encodeBytes(packet)\n        return '0x' + Buffer.from(buff).toString('hex')\n    }\n\n    /**\n     * Encode a packet to a Uint8Array.\n     *\n     * @param packet - The packet to encode.\n     * @returns The encoded packet as a Uint8Array.\n     */\n    static encodeBytes(packet: Packet): Uint8Array {\n        const message = trim0x(packet.message)\n        const buffer = Buffer.alloc(MESSAGE_OFFSET + message.length / 2)\n        buffer.writeUInt8(packet.version, PACKET_VERSION_OFFSET)\n        buffer.writeBigUInt64BE(BigInt(packet.nonce), NONCE_OFFSET)\n        buffer.writeUInt32BE(packet.srcEid, SRC_CHAIN_OFFSET)\n        buffer.write(Buffer.from(addressToBytes32(packet.sender)).toString('hex'), SRC_ADDRESS_OFFSET, 32, 'hex')\n        buffer.writeUInt32BE(packet.dstEid, DST_CHAIN_OFFSET)\n        buffer.write(Buffer.from(addressToBytes32(packet.receiver)).toString('hex'), DST_ADDRESS_OFFSET, 32, 'hex')\n        buffer.write(trim0x(packet.guid), GUID_OFFSET, 32, 'hex')\n        buffer.write(message, MESSAGE_OFFSET, message.length / 2, 'hex')\n        return new Uint8Array(buffer)\n    }\n\n    /**\n     * Get the version of the packet.\n     *\n     * @returns The version of the packet.\n     */\n    version(): number {\n        return this.buffer.readUInt8(PACKET_VERSION_OFFSET)\n    }\n\n    /**\n     * Get the nonce of the packet.\n     *\n     * @returns The nonce of the packet as a string.\n     */\n    nonce(): string {\n        return this.buffer.readBigUint64BE(NONCE_OFFSET).toString()\n    }\n\n    /**\n     * Get the source chain ID of the packet.\n     *\n     * @returns The source chain ID of the packet.\n     */\n    srcEid(): number {\n        return this.buffer.readUint32BE(SRC_CHAIN_OFFSET)\n    }\n\n    /**\n     * Get the sender address of the packet.\n     *\n     * @returns The sender address of the packet.\n     */\n    sender(): string {\n        return '0x' + this.buffer.slice(SRC_ADDRESS_OFFSET, DST_CHAIN_OFFSET).toString('hex')\n    }\n\n    /**\n     * Get the sender address in B20 format.\n     *\n     * @returns The sender address in B20 format.\n     */\n    senderAddressB20(): string {\n        return bytes32ToEthAddress(this.sender())\n    }\n\n    /**\n     * Get the destination chain ID of the packet.\n     *\n     * @returns The destination chain ID of the packet.\n     */\n    dstEid(): number {\n        return this.buffer.readUint32BE(DST_CHAIN_OFFSET)\n    }\n\n    /**\n     * Get the receiver address of the packet.\n     *\n     * @returns The receiver address of the packet.\n     */\n    receiver(): string {\n        return '0x' + this.buffer.slice(DST_ADDRESS_OFFSET, GUID_OFFSET).toString('hex')\n    }\n\n    /**\n     * Get the receiver address in B20 format.\n     *\n     * @returns The receiver address in B20 format.\n     */\n    receiverAddressB20(): string {\n        return bytes32ToEthAddress(this.receiver())\n    }\n\n    /**\n     * Get the GUID of the packet.\n     *\n     * @returns The GUID of the packet.\n     */\n    guid(): string {\n        return '0x' + this.buffer.slice(GUID_OFFSET, MESSAGE_OFFSET).toString('hex')\n    }\n\n    /**\n     * Get the message of the packet.\n     *\n     * @returns The message of the packet.\n     */\n    message(): string {\n        return '0x' + this.buffer.slice(MESSAGE_OFFSET).toString('hex')\n    }\n\n    /**\n     * Get the hash of the payload.\n     *\n     * @returns The hash of the payload.\n     */\n    payloadHash(): string {\n        return keccak256(this.payload())\n    }\n\n    /**\n     * Get the payload of the packet.\n     *\n     * @returns The payload of the packet.\n     */\n    payload(): string {\n        return '0x' + this.buffer.slice(GUID_OFFSET).toString('hex')\n    }\n\n    /**\n     * Get the header of the packet.\n     *\n     * @returns The header of the packet.\n     */\n    header(): string {\n        return '0x' + this.buffer.slice(0, GUID_OFFSET).toString('hex')\n    }\n\n    /**\n     * Get the hash of the header.\n     *\n     * @returns The hash of the header.\n     */\n    headerHash(): string {\n        return keccak256(this.header())\n    }\n\n    /**\n     * Deserialize packet from hex string.\n     *\n     * @deprecated Use toPacket instead.\n     * @returns The deserialized packet.\n     */\n    decode(): Packet {\n        return this.toPacket()\n    }\n\n    /**\n     * Convert the encoded data to a Packet object.\n     *\n     * @returns The Packet object.\n     */\n    toPacket(): Packet {\n        return {\n            version: this.version(),\n            nonce: this.nonce(),\n            srcEid: this.srcEid(),\n            sender: this.sender(),\n            dstEid: this.dstEid(),\n            receiver: this.receiver(),\n            guid: this.guid(),\n            message: this.message(),\n            // derived\n            payload: this.payload(),\n        }\n    }\n}\n\n/**\n * Calculate the GUID for a packet header.\n *\n * @param packetHead - The packet header.\n * @returns The calculated GUID.\n */\nexport function calculateGuid(packetHead: PacketHeader): string {\n    return keccak256(\n        solidityPack(\n            ['uint64', 'uint32', 'bytes32', 'uint32', 'bytes32'],\n            [\n                BigNumber.from(packetHead.nonce),\n                packetHead.srcEid,\n                addressToBytes32(packetHead.sender),\n                packetHead.dstEid,\n                addressToBytes32(packetHead.receiver),\n            ]\n        )\n    )\n}\n\nexport { keccak256 } from '@ethersproject/keccak256'\n", "import { Packet } from '../model'\n\nimport { PacketV1Codec } from './packet-v1-codec'\n\n/**\n * Serializer for Packet objects.\n */\nexport class PacketSerializer {\n    /**\n     * Serializes a Packet object to a string.\n     *\n     * @param {Packet} packet - The packet to serialize.\n     * @returns {string} The serialized packet as a string.\n     */\n    static serialize(packet: Packet): string {\n        return PacketV1Codec.encode(packet)\n    }\n\n    /**\n     * Serializes a Packet object to a Uint8Array.\n     *\n     * @param {Packet} packet - The packet to serialize.\n     * @returns {Uint8Array} The serialized packet as a Uint8Array.\n     */\n    static serializeBytes(packet: Packet): Uint8Array {\n        return PacketV1Codec.encodeBytes(packet)\n    }\n\n    /**\n     * Deserializes a Uint8Array or string to a Packet object.\n     *\n     * @param {Uint8Array | string} bytesLike - The bytes or string to deserialize.\n     * @returns {Packet} The deserialized Packet object.\n     */\n    static deserialize(bytesLike: Uint8Array | string): Packet {\n        let codec: PacketV1Codec\n        if (bytesLike instanceof Uint8Array) {\n            codec = PacketV1Codec.fromBytes(bytesLike)\n        } else {\n            codec = PacketV1Codec.from(bytesLike)\n        }\n        return codec.toPacket()\n    }\n}\n", "/**\n * Abstract class representing a codec.\n */\nabstract class Codec {\n    protected byteLength: number\n\n    /**\n     * Creates an instance of the Codec class.\n     */\n    constructor() {\n        this.byteLength = 0\n    }\n\n    /**\n     * Gets the byte length of the codec.\n     *\n     * @returns {number} The byte length.\n     */\n    getByteLength(): number {\n        return this.byteLength\n    }\n\n    /**\n     * Gets the hex length of the codec.\n     *\n     * @returns {number} The hex length.\n     */\n    getHexLength(): number {\n        return this.byteLength * 2\n    }\n\n    /**\n     * Encodes the codec to a hex string.\n     *\n     * @returns {string} The encoded hex string.\n     */\n    abstract encode(): string\n\n    /**\n     * Decodes a hex string to a codec.\n     *\n     * @param {string} hex - The hex string to decode.\n     * @returns {Codec} The decoded codec.\n     * @throws {Error} If the method is not implemented.\n     */\n    static decode(hex: string): Codec {\n        throw new Error('Not implemented')\n    }\n}\n\n/**\n * Enum representing the timestamp block configuration.\n */\nexport enum TimestampBlockConfiguration {\n    /**\n     * Represents a timestamp.\n     */\n    Timestamp = 0,\n\n    /**\n     * Represents a block number.\n     */\n    BlockNumber = 1,\n}\n\n/**\n * Enum representing the resolver type.\n */\nexport enum ResolverType {\n    /**\n     * Represents a single view function EVM call.\n     */\n    SingleViewFunctionEVMCall = 1,\n}\n\n/**\n * Enum representing the compute setting.\n */\nexport enum ComputeSetting {\n    /**\n     * Only map.\n     */\n    OnlyMap = 0,\n\n    /**\n     * Only reduce.\n     */\n    OnlyReduce = 1,\n\n    /**\n     * Map and reduce.\n     */\n    MapReduce = 2,\n}\n\n/**\n * Enum representing the compute type.\n */\nexport enum ComputeType {\n    /**\n     * Represents a single view function EVM call.\n     */\n    SingleViewFunctionEVMCall = 1,\n}\n\n/**\n * Interface representing an EVM timestamp.\n */\nexport interface EVMTimestamp {\n    /**\n     * The timestamp.\n     */\n    timestamp: bigint // 8 bytes (if timestampBlockFlag indicates Unix timestamp)\n}\n\n/**\n * Interface representing an EVM block.\n */\nexport interface EVMBlock {\n    /**\n     * The block number.\n     */\n    blockNumber: bigint // 8 bytes (if timestampBlockFlag indicates block number)\n}\n\n/**\n * Interface representing a command request.\n * @see {@link Codec}\n */\nexport interface CommandRequest extends Codec {\n    /**\n     * The request header.\n     */\n    requestHeader: RequestHeader\n}\n\n/**\n * Interface representing a compute.\n * @see {@link Codec}\n */\nexport interface Compute extends Codec {\n    /**\n     * The compute header.\n     */\n    computeHeader: ComputeHeader\n}\n\n/**\n * Class representing a header.\n * @see {@link Codec}\n */\nexport class Header extends Codec {\n    globalVersion: number // 2 bytes\n    appCommandLabel: string // 2 bytes\n    requestCount: number // 2 bytes\n\n    private static GLOBAL_VERSION_BYTES = 2\n    private static APP_COMMAND_LABEL_BYTES = 2\n    private static REQUEST_COUNT_BYTES = 2\n\n    /**\n     * Creates an instance of the Header class.\n     *\n     * @param {number} globalVersion - The global version.\n     * @param {string} appCommandLabel - The application command label.\n     * @param {number} requestCount - The number of requests.\n     */\n    constructor(globalVersion: number, appCommandLabel: string, requestCount: number) {\n        super()\n        this.globalVersion = globalVersion\n        this.appCommandLabel = appCommandLabel\n        this.requestCount = requestCount\n        this.byteLength = Header.GLOBAL_VERSION_BYTES + Header.APP_COMMAND_LABEL_BYTES + Header.REQUEST_COUNT_BYTES\n    }\n\n    /**\n     * Encodes the header to a hex string.\n     *\n     * @returns {string} The encoded hex string.\n     */\n    encode(): string {\n        const globalVersionHex = numberToHex(this.globalVersion, Header.GLOBAL_VERSION_BYTES) // 2 bytes\n        const appCommandLabelHex = this.appCommandLabel.padStart(bytesToHexLength(Header.APP_COMMAND_LABEL_BYTES), '0')\n        const requestCountHex = numberToHex(this.requestCount, Header.REQUEST_COUNT_BYTES) // 2 bytes\n        return globalVersionHex + appCommandLabelHex + requestCountHex\n    }\n\n    /**\n     * Decodes a hex string to a header.\n     *\n     * @param {string} hex - The hex string to decode.\n     * @param {number} [offset] - The offset to start decoding from.\n     * @returns {Header} The decoded header.\n     */\n    static decode(hex: string, offset?: number): Header {\n        let internalOffset = offset ?? 0\n        const globalVersion = hexToNumber(sliceHex(hex, internalOffset, Header.GLOBAL_VERSION_BYTES)) // 2 bytes\n        internalOffset += bytesToHexLength(Header.GLOBAL_VERSION_BYTES)\n        const appCommandLabel = sliceHex(hex, internalOffset, Header.APP_COMMAND_LABEL_BYTES) // 2 bytes\n        internalOffset += bytesToHexLength(Header.APP_COMMAND_LABEL_BYTES)\n        const requestCount = hexToNumber(sliceHex(hex, internalOffset, Header.REQUEST_COUNT_BYTES)) // 2 bytes\n        return new Header(globalVersion, appCommandLabel, requestCount)\n    }\n}\n\n/**\n * Class representing a request header.\n * @see {@link Codec}\n */\nexport class RequestHeader extends Codec {\n    requestVersion: number // 1 byte\n    appRequestLabel: string // 2 bytes (hex or string)\n    resolverType: ResolverType // 2 bytes\n    requestSize: number // 2 bytes\n\n    private static REQUEST_VERSION_BYTES = 1\n    private static APP_REQUEST_LABEL_BYTES = 2\n    private static RESOLVER_TYPE_BYTES = 2\n    private static REQUEST_SIZE_BYTES = 2\n\n    /**\n     * Creates an instance of the RequestHeader class.\n     *\n     * @param {number} requestVersion - The request version.\n     * @param {string} appRequestLabel - The application request label.\n     * @param {ResolverType} resolverType - The resolver type.\n     * @param {number} requestSize - The request size.\n     */\n    constructor(requestVersion: number, appRequestLabel: string, resolverType: ResolverType, requestSize: number) {\n        super()\n        this.requestVersion = requestVersion\n        this.appRequestLabel = appRequestLabel\n        this.resolverType = resolverType\n        this.requestSize = requestSize\n\n        this.byteLength =\n            RequestHeader.REQUEST_VERSION_BYTES +\n            RequestHeader.APP_REQUEST_LABEL_BYTES +\n            RequestHeader.RESOLVER_TYPE_BYTES +\n            RequestHeader.REQUEST_SIZE_BYTES\n    }\n\n    /**\n     * Encodes the request header to a hex string.\n     *\n     * @returns {string} The encoded hex string.\n     */\n    encode(): string {\n        const requestVersionHex = numberToHex(this.requestVersion, RequestHeader.REQUEST_VERSION_BYTES)\n        const appRequestLabelHex = this.appRequestLabel.padStart(\n            bytesToHexLength(RequestHeader.APP_REQUEST_LABEL_BYTES),\n            '0'\n        )\n        const resolverTypeHex = numberToHex(this.resolverType, RequestHeader.RESOLVER_TYPE_BYTES)\n        const requestSizeHex = numberToHex(this.requestSize, RequestHeader.REQUEST_SIZE_BYTES)\n        return requestVersionHex + appRequestLabelHex + resolverTypeHex + requestSizeHex\n    }\n\n    /**\n     * Decodes a hex string to a request header.\n     *\n     * @param {string} hex - The hex string to decode.\n     * @param {number} [offset] - The offset to start decoding from.\n     * @returns {RequestHeader} The decoded request header.\n     */\n    static decode(hex: string, offset?: number): RequestHeader {\n        let internalOffset = offset ?? 0\n        const requestVersion = hexToNumber(sliceHex(hex, internalOffset, RequestHeader.REQUEST_VERSION_BYTES))\n        internalOffset += bytesToHexLength(RequestHeader.REQUEST_VERSION_BYTES)\n        const appRequestLabel = sliceHex(hex, internalOffset, RequestHeader.APP_REQUEST_LABEL_BYTES)\n        internalOffset += bytesToHexLength(RequestHeader.APP_REQUEST_LABEL_BYTES)\n        const resolverType = hexToNumber(sliceHex(hex, internalOffset, RequestHeader.RESOLVER_TYPE_BYTES))\n        internalOffset += bytesToHexLength(RequestHeader.RESOLVER_TYPE_BYTES)\n        const requestSize = hexToNumber(sliceHex(hex, internalOffset, RequestHeader.REQUEST_SIZE_BYTES))\n        return new RequestHeader(requestVersion, appRequestLabel, resolverType, requestSize)\n    }\n}\n\n/**\n * Class representing an EVM base.\n * @see {@link Codec}\n */\nexport class EVMBase extends Codec {\n    targetEid: number // 4 bytes\n    timestampBlockFlag: TimestampBlockConfiguration // 1 byte\n    blockConfirmations: number // 2 bytes\n    to: string // 20 bytes (hex or string)\n    timestamp?: bigint // 8 bytes (if timestampBlockFlag indicates Unix timestamp)\n    blockNumber?: bigint // 8 bytes (if timestampBlockFlag indicates block number)\n\n    private static TARGET_EID_BYTES = 4\n    private static TIMESTAMP_BLOCK_FLAG_BYTES = 1\n    private static BLOCK_CONFIRMATIONS_BYTES = 2\n    private static TO_BYTES = 20\n    private static TIMESTAMP_BYTES = 8\n    private static BLOCK_NUMBER_BYTES = 8\n\n    /**\n     * Creates an instance of the EVMBase class.\n     *\n     * @param {number} targetEid - The target endpoint ID.\n     * @param {TimestampBlockConfiguration} timestampBlockFlag - The timestamp block configuration.\n     * @param {number} blockConfirmations - The number of block confirmations.\n     * @param {string} to - The recipient address.\n     * @param {bigint} [timestamp] - The timestamp.\n     * @param {bigint} [blockNumber] - The block number.\n     */\n    protected constructor(\n        targetEid: number,\n        timestampBlockFlag: TimestampBlockConfiguration,\n        blockConfirmations: number,\n        to: string,\n        timestamp?: bigint,\n        blockNumber?: bigint\n    ) {\n        super()\n        this.targetEid = targetEid\n        this.timestampBlockFlag = timestampBlockFlag\n        this.blockConfirmations = blockConfirmations\n        this.to = to\n        this.timestamp = timestamp\n        this.blockNumber = blockNumber\n        this.byteLength =\n            EVMBase.TARGET_EID_BYTES +\n            EVMBase.TIMESTAMP_BLOCK_FLAG_BYTES +\n            EVMBase.BLOCK_CONFIRMATIONS_BYTES +\n            EVMBase.TO_BYTES +\n            (timestamp !== undefined ? EVMBase.TIMESTAMP_BYTES : 0) +\n            (blockNumber !== undefined ? EVMBase.BLOCK_NUMBER_BYTES : 0)\n    }\n\n    /**\n     * Encodes the EVM base to a hex string.\n     *\n     * @returns {string} The encoded hex string.\n     */\n    encode(): string {\n        const targetEidHex = numberToHex(this.targetEid, EVMBase.TARGET_EID_BYTES) // 4 bytes\n        const timestampBlockFlagHex = numberToHex(this.timestampBlockFlag, EVMBase.TIMESTAMP_BLOCK_FLAG_BYTES) // 1 byte\n        const blockNumberHex =\n            this.blockNumber !== undefined ? bigIntToHex(this.blockNumber, EVMBase.BLOCK_NUMBER_BYTES) : undefined\n        const timestampHex =\n            this.timestamp !== undefined ? bigIntToHex(this.timestamp, EVMBase.TIMESTAMP_BYTES) : undefined\n\n        if (timestampHex !== undefined && blockNumberHex !== undefined) {\n            throw new Error('Cannot have both timestamp and block number')\n        }\n        const blockConfirmationsHex = numberToHex(this.blockConfirmations, EVMBase.BLOCK_CONFIRMATIONS_BYTES) // 2 bytes\n        const toHex = this.to.padStart(bytesToHexLength(EVMBase.TO_BYTES), '0') // 20 bytes (hex or string)\n\n        const blockOrTimestampHex = blockNumberHex ?? timestampHex\n        if (blockOrTimestampHex === undefined) {\n            throw new Error('Either block number or timestamp must be set')\n        }\n        return targetEidHex + timestampBlockFlagHex + blockOrTimestampHex + blockConfirmationsHex + toHex\n    }\n\n    /**\n     * Decodes a hex string to an EVM base.\n     *\n     * @param {string} hex - The hex string to decode.\n     * @param {number} [offset] - The offset to start decoding from.\n     * @returns {EVMBase} The decoded EVM base.\n     */\n    static decode(hex: string, offset?: number): EVMBase {\n        let internalOffset = offset ?? 0\n        const targetEid = hexToNumber(sliceHex(hex, internalOffset, EVMBase.TARGET_EID_BYTES)) // 4 bytes\n        internalOffset += bytesToHexLength(EVMBase.TARGET_EID_BYTES)\n\n        const timestampBlockFlag: TimestampBlockConfiguration = hexToNumber(\n            sliceHex(hex, internalOffset, EVMBase.TIMESTAMP_BLOCK_FLAG_BYTES)\n        )\n        internalOffset += bytesToHexLength(EVMBase.TIMESTAMP_BLOCK_FLAG_BYTES)\n\n        let timestamp: bigint | undefined\n        let blockNumber: bigint | undefined\n        if (timestampBlockFlag === TimestampBlockConfiguration.Timestamp) {\n            timestamp = hexToBigInt(sliceHex(hex, internalOffset, EVMBase.TIMESTAMP_BYTES)) // 8 bytes\n            internalOffset += bytesToHexLength(EVMBase.TIMESTAMP_BYTES)\n        } else {\n            blockNumber = hexToBigInt(sliceHex(hex, internalOffset, EVMBase.BLOCK_NUMBER_BYTES)) // 8 bytes\n            internalOffset += bytesToHexLength(EVMBase.BLOCK_NUMBER_BYTES)\n        }\n\n        const blockConfirmations = hexToNumber(sliceHex(hex, internalOffset, EVMBase.BLOCK_CONFIRMATIONS_BYTES)) // 2 bytes\n        internalOffset += bytesToHexLength(EVMBase.BLOCK_CONFIRMATIONS_BYTES)\n        const to = sliceHex(hex, internalOffset, EVMBase.TO_BYTES) // 20 bytes\n\n        return new EVMBase(targetEid, timestampBlockFlag, blockConfirmations, to, timestamp, blockNumber)\n    }\n}\n\n/**\n * Class representing a single view function EVM call.\n * @see {@link EVMBase}, {@link CommandRequest}\n */\nexport class SingleViewFunctionEVMCall extends EVMBase implements CommandRequest {\n    requestHeader: RequestHeader\n    calldata: string // Calldata (size specified by calldataSize)\n\n    /**\n     * Creates an instance of the SingleViewFunctionEVMCall class.\n     *\n     * @param {RequestHeader} requestHeader - The request header.\n     * @param {number} targetEid - The target endpoint ID.\n     * @param {TimestampBlockConfiguration} timestampBlockFlag - The timestamp block configuration.\n     * @param {number} blockConfirmations - The number of block confirmations.\n     * @param {string} to - The recipient address.\n     * @param {string} calldata - The calldata.\n     * @param {bigint} [timestamp] - The timestamp.\n     * @param {bigint} [blockNumber] - The block number.\n     */\n    constructor(\n        requestHeader: RequestHeader,\n        targetEid: number,\n        timestampBlockFlag: TimestampBlockConfiguration,\n        blockConfirmations: number,\n        to: string,\n        calldata: string,\n        timestamp?: bigint,\n        blockNumber?: bigint\n    ) {\n        super(targetEid, timestampBlockFlag, blockConfirmations, to, timestamp, blockNumber)\n        this.requestHeader = requestHeader\n        this.calldata = calldata\n        const evmByteLength = super.getByteLength()\n        const callDataSize = this.requestHeader.requestSize - evmByteLength\n        this.byteLength = this.requestHeader.getByteLength() + evmByteLength + callDataSize\n    }\n\n    /**\n     * Encodes the single view function EVM call to a hex string.\n     *\n     * @returns {string} The encoded hex string.\n     */\n    encode(): string {\n        const requestHeaderHex = this.requestHeader.encode() // Encodes the request header from CommandRequest\n        const evmBaseHex = super.encode() // Encodes the EVMBase fields\n        const callDataSize = this.requestHeader.requestSize - super.getByteLength()\n        const calldataHex = this.calldata.padStart(callDataSize * 2, '0') // Calldata (hex string)\n\n        return requestHeaderHex + evmBaseHex + calldataHex\n    }\n\n    /**\n     * Decodes a hex string to a single view function EVM call.\n     *\n     * @param {string} hex - The hex string to decode.\n     * @param {number} [offset] - The offset to start decoding from.\n     * @returns {SingleViewFunctionEVMCall} The decoded single view function EVM call.\n     */\n    static decode(hex: string, offset?: number): SingleViewFunctionEVMCall {\n        let internalOffset = offset ?? 0\n        const requestHeader = RequestHeader.decode(hex, internalOffset) // Decodes the CommandRequest\n        internalOffset += requestHeader.getHexLength()\n        const evmBase = super.decode(hex, internalOffset) // Decodes the EVMBase\n        internalOffset += evmBase.getHexLength()\n        const calldataSize = requestHeader.requestSize - evmBase.getByteLength()\n        const calldata = sliceHex(hex, internalOffset, calldataSize)\n        return new SingleViewFunctionEVMCall(\n            requestHeader,\n            evmBase.targetEid,\n            evmBase.timestampBlockFlag,\n            evmBase.blockConfirmations,\n            evmBase.to,\n            calldata,\n            evmBase.timestamp,\n            evmBase.blockNumber\n        )\n    }\n}\n\n/**\n * Class representing a compute header.\n * @see {@link Codec}\n */\nexport class ComputeHeader extends Codec {\n    computeVersion: number // 1 byte\n    computeType: ComputeType // 2 bytes\n    computeSetting: ComputeSetting // 1 byte\n\n    private static COMPUTE_VERSION_BYTES = 1\n    private static COMPUTE_TYPE_BYTES = 2\n    private static COMPUTE_SETTING_BYTES = 1\n\n    /**\n     * Creates an instance of the ComputeHeader class.\n     *\n     * @param {number} computeVersion - The compute version.\n     * @param {ComputeType} computeType - The compute type.\n     * @param {ComputeSetting} computeSetting - The compute setting.\n     */\n    constructor(computeVersion: number, computeType: ComputeType, computeSetting: ComputeSetting) {\n        super()\n        this.computeVersion = computeVersion\n        this.computeType = computeType\n        this.computeSetting = computeSetting\n        this.byteLength =\n            ComputeHeader.COMPUTE_VERSION_BYTES + ComputeHeader.COMPUTE_TYPE_BYTES + ComputeHeader.COMPUTE_SETTING_BYTES\n    }\n\n    /**\n     * Encodes the compute header to a hex string.\n     *\n     * @returns {string} The encoded hex string.\n     */\n    encode(): string {\n        const computeVersionHex = numberToHex(this.computeVersion, ComputeHeader.COMPUTE_VERSION_BYTES)\n        const computeTypeHex = numberToHex(this.computeType, ComputeHeader.COMPUTE_TYPE_BYTES)\n        const computeSettingHex = numberToHex(this.computeSetting, ComputeHeader.COMPUTE_SETTING_BYTES)\n        return computeVersionHex + computeTypeHex + computeSettingHex\n    }\n\n    /**\n     * Decodes a hex string to a compute header.\n     *\n     * @param {string} hex - The hex string to decode.\n     * @param {number} [offset] - The offset to start decoding from.\n     * @returns {ComputeHeader} The decoded compute header.\n     */\n    static decode(hex: string, offset?: number): ComputeHeader {\n        let internalOffset = offset ?? 0\n        const computeVersion = hexToNumber(sliceHex(hex, internalOffset, ComputeHeader.COMPUTE_VERSION_BYTES))\n        internalOffset += bytesToHexLength(ComputeHeader.COMPUTE_VERSION_BYTES)\n        const computeType = hexToNumber(sliceHex(hex, internalOffset, ComputeHeader.COMPUTE_TYPE_BYTES))\n        internalOffset += bytesToHexLength(ComputeHeader.COMPUTE_TYPE_BYTES)\n        const computeSetting = hexToNumber(sliceHex(hex, internalOffset, ComputeHeader.COMPUTE_SETTING_BYTES))\n        return new ComputeHeader(computeVersion, computeType, computeSetting)\n    }\n}\n\n/**\n * Class representing a compute EVM.\n * @see {@link EVMBase}, {@link Compute}\n */\nexport class ComputeEVM extends EVMBase implements Compute {\n    computeHeader: ComputeHeader\n\n    /**\n     * Creates an instance of the ComputeEVM class.\n     *\n     * @param {ComputeHeader} computeHeader - The compute header.\n     * @param {number} targetEid - The target endpoint ID.\n     * @param {TimestampBlockConfiguration} timestampBlockFlag - The timestamp block configuration.\n     * @param {number} blockConfirmations - The number of block confirmations.\n     * @param {string} to - The recipient address.\n     * @param {bigint} [timestamp] - The timestamp.\n     * @param {bigint} [blockNumber] - The block number.\n     */\n    constructor(\n        computeHeader: ComputeHeader,\n        targetEid: number,\n        timestampBlockFlag: TimestampBlockConfiguration,\n        blockConfirmations: number,\n        to: string,\n        timestamp?: bigint,\n        blockNumber?: bigint\n    ) {\n        super(targetEid, timestampBlockFlag, blockConfirmations, to, timestamp, blockNumber)\n        this.computeHeader = computeHeader\n        const evmByteLength = super.getByteLength()\n        this.byteLength += evmByteLength + this.computeHeader.getByteLength()\n    }\n\n    /**\n     * Encodes the compute EVM to a hex string.\n     *\n     * @returns {string} The encoded hex string.\n     */\n    encode(): string {\n        const computeHeaderHex = this.computeHeader.encode() // Encodes the ComputeHeader fields\n        const evmBaseHex = super.encode() // Encodes the EVMBase fields\n        return computeHeaderHex + evmBaseHex\n    }\n\n    /**\n     * Decodes a hex string to a compute EVM.\n     *\n     * @param {string} hex - The hex string to decode.\n     * @param {number} [offset] - The offset to start decoding from.\n     * @returns {ComputeEVM} The decoded compute EVM.\n     */\n    static decode(hex: string, offset?: number): ComputeEVM {\n        let internalOffset = offset ?? 0\n        const computeHeader = ComputeHeader.decode(hex, internalOffset) // Decodes the ComputeHeader\n        internalOffset += computeHeader.getHexLength()\n        const evmBase = EVMBase.decode(hex, internalOffset) // Decodes the EVMBase part\n        internalOffset += evmBase.getHexLength()\n\n        return new ComputeEVM(\n            computeHeader,\n            evmBase.targetEid,\n            evmBase.timestampBlockFlag,\n            evmBase.blockConfirmations,\n            evmBase.to,\n            evmBase.timestamp,\n            evmBase.blockNumber\n        )\n    }\n}\n\n/**\n * Class representing a command.\n * @see {@link Codec}\n */\nexport class Command extends Codec {\n    header: Header\n    requests: CommandRequest[]\n    compute?: Compute\n\n    /**\n     * Creates an instance of the Command class.\n     *\n     * @param {Header} header - The command header.\n     * @param {CommandRequest[]} requests - The command requests.\n     * @param {Compute} [compute] - The compute object.\n     */\n    constructor(header: Header, requests: CommandRequest[], compute?: Compute) {\n        super()\n        this.header = header\n        this.requests = requests\n        this.compute = compute\n        this.byteLength =\n            this.header.getByteLength() +\n            this.requests.reduce((acc, req) => acc + req.getByteLength(), 0) +\n            (this.compute ? this.compute.getByteLength() : 0)\n    }\n\n    /**\n     * Encodes a command request.\n     *\n     * @param {CommandRequest} request - The command request to encode.\n     * @returns {string} The encoded command request.\n     * @throws {Error} If the resolver type is invalid.\n     */\n    private encodeCommandRequest(request: CommandRequest): string {\n        switch (request.requestHeader.resolverType) {\n            case ResolverType.SingleViewFunctionEVMCall:\n                return (request as SingleViewFunctionEVMCall).encode()\n            default:\n                throw new Error('Invalid resolver type')\n        }\n    }\n\n    /**\n     * Encodes the compute object.\n     *\n     * @returns {string} The encoded compute object.\n     * @throws {Error} If the compute type is invalid.\n     */\n    private encodeCompute(): string {\n        if (!this.compute) {\n            return ''\n        }\n        switch (this.compute.computeHeader.computeType) {\n            case ComputeType.SingleViewFunctionEVMCall:\n                return (this.compute as ComputeEVM).encode()\n            default:\n                throw new Error('Invalid compute type')\n        }\n    }\n\n    /**\n     * Encodes the command.\n     *\n     * @returns {string} The encoded command.\n     */\n    encode(): string {\n        const headerHex = this.header.encode()\n        const requestsHex = this.requests.map((req) => this.encodeCommandRequest(req)).join('')\n        const computeHex = this.encodeCompute()\n        return headerHex + requestsHex + computeHex\n    }\n\n    /**\n     * Decodes a command request.\n     *\n     * @param {string} hex - The hex string to decode.\n     * @param {number} offset - The offset to start decoding from.\n     * @returns {CommandRequest} The decoded command request.\n     * @throws {Error} If the resolver type is invalid.\n     */\n    private static decodeRequest(hex: string, offset: number): CommandRequest {\n        const requestHeader = RequestHeader.decode(hex, offset)\n        switch (requestHeader.resolverType) {\n            case ResolverType.SingleViewFunctionEVMCall:\n                return SingleViewFunctionEVMCall.decode(hex, offset)\n            default:\n                throw new Error('Invalid resolver type')\n        }\n    }\n\n    /**\n     * Decodes the compute object.\n     *\n     * @param {string} hex - The hex string to decode.\n     * @param {number} offset - The offset to start decoding from.\n     * @returns {Compute} The decoded compute object.\n     * @throws {Error} If the compute type is invalid.\n     */\n    private static decodeCompute(hex: string, offset: number): Compute {\n        const computeHeader = ComputeHeader.decode(hex, offset)\n\n        switch (computeHeader.computeType) {\n            case ComputeType.SingleViewFunctionEVMCall:\n                return ComputeEVM.decode(hex, offset)\n            default:\n                throw new Error('Invalid compute type')\n        }\n    }\n\n    /**\n     * Decodes a command.\n     *\n     * @param {string} hex - The hex string to decode.\n     * @param {number} [offset=0] - The offset to start decoding from.\n     * @returns {Command} The decoded command.\n     */\n    static decode(hex: string, offset?: number): Command {\n        let internalOffset = offset ?? 0\n        const header = Header.decode(hex, internalOffset)\n        internalOffset += header.getHexLength()\n\n        const requests: CommandRequest[] = []\n        for (let i = 0; i < header.requestCount; i++) {\n            const request = Command.decodeRequest(hex, internalOffset)\n            requests.push(request)\n            internalOffset += request.getHexLength()\n        }\n\n        const command =\n            internalOffset === hex.length\n                ? new Command(header, requests)\n                : new Command(header, requests, Command.decodeCompute(hex, internalOffset))\n\n        return command\n    }\n}\n\n/**\n * Converts bytes to hex length.\n *\n * @param {number} bytes - The number of bytes.\n * @returns {number} The hex length.\n */\nfunction bytesToHexLength(bytes: number): number {\n    return bytes * 2\n}\n\n/**\n * Slices a hex string.\n *\n * @param {string} hex - The hex string to slice.\n * @param {number} offset - The offset to start slicing from.\n * @param {number} bytes - The number of bytes to slice.\n * @returns {string} The sliced hex string.\n */\nfunction sliceHex(hex: string, offset: number, bytes: number): string {\n    const length = bytesToHexLength(bytes) // Convert bytes to hex characters\n    const slice = hex.slice(offset, offset + length)\n    return slice\n}\n\n/**\n * Converts a hex string to a number.\n *\n * @param {string} hexStr - The hex string to convert.\n * @returns {number} The converted number.\n */\nfunction hexToNumber(hexStr: string): number {\n    return parseInt(hexStr, 16)\n}\n\n/**\n * Converts a hex string to a bigint.\n *\n * @param {string} hexStr - The hex string to convert.\n * @returns {bigint} The converted bigint.\n */\nfunction hexToBigInt(hexStr: string): bigint {\n    return BigInt(`0x${hexStr}`)\n}\n\n/**\n * Converts a number to a hex string.\n *\n * @param {number} num - The number to convert.\n * @param {number} bytes - The number of bytes.\n * @returns {string} The converted hex string.\n */\nfunction numberToHex(num: number, bytes: number): string {\n    return num.toString(16).padStart(bytes * 2, '0') // Ensure it has the correct byte size in hex\n}\n\n/**\n * Converts a bigint to a hex string.\n *\n * @param {bigint} bigInt - The bigint to convert.\n * @param {number} bytes - The number of bytes.\n * @returns {string} The converted hex string.\n */\nfunction bigIntToHex(bigInt: bigint, bytes: number): string {\n    return bigInt.toString(16).padStart(bytes * 2, '0')\n}\n"],
  "mappings": "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",
  "names": ["i", "j", "base58", "OptionType", "solidityPack", "WorkerId", "ExecutorOptionType", "VerifierOptionType", "arrayify", "hexlify", "BigNumber", "TimestampBlockConfiguration", "ResolverType", "ComputeSetting", "ComputeType", "_a"]
}
